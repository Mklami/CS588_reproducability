Summary,Method
"<summary>
Represents the json array.
</summary>","public override string ToString()
        {
            return SimpleJson.SerializeObject(this) ?? string.Empty;
        }"
"<summary>
Represents the json object.
</summary>","internal static object GetAtIndex(IDictionary<string, object> obj, int index)
        {
            if (obj"
"<summary>
Adds the specified key.
</summary>","public void Add(string key, object value)
        {
            _members.Add(key, value);
        }"
"<summary>
Determines whether the specified key contains key.
</summary>","public bool ContainsKey(string key)
        {
            return _members.ContainsKey(key);
        }"
"<summary>
Gets the keys.
</summary>","public bool Remove(string key)
        {
            return _members.Remove(key);
        }"
"<summary>
Tries the get value.
</summary>","public bool TryGetValue(string key, out object value)
        {
            return _members.TryGetValue(key, out value);
        }"
"<summary>
Gets the values.
</summary>","public void Add(KeyValuePair<string, object> item)
        {
            _members.Add(item.Key, item.Value);
        }"
"<summary>
Clears this instance.
</summary>","public void Clear()
        {
            _members.Clear();
        }"
"<summary>
Determines whether [contains] [the specified item].
</summary>","public bool Contains(KeyValuePair<string, object> item)
        {
            return _members.ContainsKey(item.Key) && _members[item.Key]"
"<summary>
Copies to.
</summary>","public void CopyTo(KeyValuePair<string, object>[] array, int arrayIndex)
        {
            int num = Count;
            foreach (KeyValuePair<string, object> kvp in this)
            {
                array[arrayIndex++] = kvp;
                if (--num <= 0)
                    return;
            }
        }"
"<summary>
Gets the count.
</summary>","public bool Remove(KeyValuePair<string, object> item)
        {
            return _members.Remove(item.Key);
        }"
"<summary>
Gets the enumerator.
</summary>","public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
        {
            return _members.GetEnumerator();
        }"
"<summary>
Returns an enumerator that iterates through a collection.
</summary>","public override string ToString()
        {
            return SimpleJson.SerializeObject(this);
        }"
"<summary>
Provides implementation for type conversion operations. Classes derived from the <see cref=""T:System.Dynamic.DynamicObject""/> class can override this method to specify dynamic behavior for operations that convert an object from one type to another.
</summary>","public override bool TryConvert(ConvertBinder binder, out object result)
        {
            if (binder"
"<summary>
Provides the implementation for operations that delete an object member. This method is not intended for use in C# or Visual Basic.
</summary>","public override bool TryDeleteMember(DeleteMemberBinder binder)
        {
            if (binder"
"<summary>
Provides the implementation for operations that get a value by index. Classes derived from the <see cref=""T:System.Dynamic.DynamicObject""/> class can override this method to specify dynamic behavior for indexing operations.
</summary>","public override bool TryGetIndex(GetIndexBinder binder, object[] indexes, out object result)
        {
            if (indexes.Length"
"<summary>
Provides the implementation for operations that get member values. Classes derived from the <see cref=""T:System.Dynamic.DynamicObject""/> class can override this method to specify dynamic behavior for operations such as getting a value for a property.
</summary>","public override bool TryGetMember(GetMemberBinder binder, out object result)
        {
            object value;
            if (_members.TryGetValue(binder.Name, out value))
            {
                result = value;
                return true;
            }
            result = (object)null;
            return true;
        }"
"<summary>
Provides the implementation for operations that set a value by index. Classes derived from the <see cref=""T:System.Dynamic.DynamicObject""/> class can override this method to specify dynamic behavior for operations that access objects by a specified index.
</summary>","public override bool TrySetIndex(SetIndexBinder binder, object[] indexes, object value)
        {
            if (indexes.Length"
"<summary>
Provides the implementation for operations that set member values. Classes derived from the <see cref=""T:System.Dynamic.DynamicObject""/> class can override this method to specify dynamic behavior for operations such as setting a value for a property.
</summary>","public override bool TrySetMember(SetMemberBinder binder, object value)
        {
            if (binder"
"<summary>
Returns the enumeration of all dynamic member names.
</summary>","public override IEnumerable<string> GetDynamicMemberNames()
        {
            foreach (var key in Keys)
                yield return key;
        }"
"<summary>
This class encodes and decodes JSON strings.
Spec. details, see http://www.json.org/

JSON uses Arrays and Objects. These correspond here to the datatypes JsonArray(IList&lt;object>) and JsonObject(IDictionary&lt;string,object>).
All numbers are parsed to doubles.
</summary>","public static object DeserializeObject(string json)
        {
            object @object;
            if (TryDeserializeObject(json, out @object))
                return @object;
            throw new System.Runtime.Serialization.SerializationException(""Invalid JSON string"");
        }"
"<summary>
Try parsing the json string into a value.
</summary>","public static bool TryDeserializeObject(string json, out object @object)
        {
            bool success = true;
            if (json != null)
            {
                char[] charArray = json.ToCharArray();
                int index = 0;
                @object = ParseValue(charArray, ref index, ref success);
            }
            else
                @object = null;
            return success;
        }"
"<summary>
Converts a IDictionary&lt;string,object> / IList&lt;object> object into a JSON string
</summary>","public static string SerializeObject(object json, IJsonSerializerStrategy jsonSerializerStrategy)
        {
            StringBuilder builder = new StringBuilder(BUILDER_CAPACITY);
            bool success = SerializeValue(jsonSerializerStrategy, json, builder);
            return (success ? builder.ToString() : null);
        }"
"<summary>
Determines if a given object is numeric in any way
(can be integer, double, null, etc).
</summary>","protected static bool IsNumeric(object value)
        {
            if (value is sbyte) return true;
            if (value is byte) return true;
            if (value is short) return true;
            if (value is ushort) return true;
            if (value is int) return true;
            if (value is uint) return true;
            if (value is long) return true;
            if (value is ulong) return true;
            if (value is float) return true;
            if (value is double) return true;
            if (value is decimal) return true;
            return false;
        }"
"<summary>
DnsQuery Class
Handles the dns message transport and interpretation of result.
Use Send() to activate Result object.
</summary>","public bool Send()
        {
            CheckForServers();
            foreach (IPEndPoint Server in Servers)
            {
                int port = Server.Port;
                try
                {
                    SendQuery2(Server.Address, port);
                    break;
                }
                catch
                {
                    continue;
                }
            }
            return (this.Response != null);
        }"
"<summary>
Uses UDPClient to send byte array to
DNS Server Specified
</summary>","private void SendQuery(string ipAddress)
        {
            if (ipAddress"
"<summary>
Packs question into byte array format
accepted by DNS servers
</summary>","private byte[] MakeQuery()
        {
            int QueryID = new Random().Next(55555);
            byte[] Question = new byte[512];
            for (int i = 0; i < 512; i++)
                Question[i] = 0;
            Question[0] = (byte)(QueryID >> 8);
            Question[1] = (byte)(QueryID & byte.MaxValue);
            Question[2] = (byte)1; 
            Question[2] = (byte)((this.RecursionDesired) ? (Question[2] | 1) : (Question[2] & 254));
            Question[3] = (byte)0;
            Question[4] = (byte)0;
            Question[5] = (byte)1;
            string[] tokens = this.Domain.Split(new char[] { '.' });
            string label;
            int Cursor = 12;
            for (int j = 0; j < tokens.Length; j++)
            {
                label = tokens[j];
                Question[Cursor++] = (byte)(label.Length & byte.MaxValue);
                byte[] b = Encoding.ASCII.GetBytes(label);
                for (int k = 0; k < b.Length; k++)
                {
                    Question[Cursor++] = b[k];
                }
            }
            Question[Cursor++] = (byte)0;
            Question[Cursor++] = (byte)0;
            Question[Cursor++] = (byte)QueryType;
            Question[Cursor++] = (byte)0;
            Question[Cursor++] = (byte)QueryClass;
            return Question;
        }"
"<summary>
Gets name string segments from byte array.
Uses the DNS ""compression"" support
that gives a pointer to a previous
occurrence of repeat names.
-- not so pretty, consider killing
</summary>","private int ExtractName(int ResourceDataCursor, StringBuilder Name)
        {
            int LengthLabel = (data[ResourceDataCursor++] & byte.MaxValue);
            if (LengthLabel"
"<summary>
Checks for any DNS servers
on the public collection. If user
did not add any manually gets
the default ones from the TCP/IP
Configuration.
</summary>","private bool CheckForServers()
        {
            if (Servers.Count"
"<summary>
TODO:
Gets DNS Servers from TCP/IP Configuration of
network adapter.
</summary>","private ArrayList GetDefaultServers()
        {
            ArrayList LocalServers = new ArrayList();
            try
            {
            }
            catch (Exception Ex)
            {
                Trace.WriteLine(""Could not get DNS servers from network adapter: "" + Ex.Message, ""OpenDNS"");
            }
            finally
            {
            }
            return LocalServers;
        }"
"<summary>
Base Resource Record class for objects returned in
answers, authorities and additional record DNS responses.
</summary>","public override string ToString()
		{
			StringBuilder sb = new StringBuilder();
			sb.Append(""Name="" + Name + ""&Type="" + Type + ""&Class="" + Class + ""&TTL=""+TimeToLive);
			return sb.ToString();
		}"
"<summary>
The Collection Class inherits from ArrayList.  It has its own implemenation
of Sort based on the sortable fields.
</summary>","public void Sort(SortFields sortField, bool isAscending)
		{
			switch (sortField)
			{
				case SortFields.Name:
					base.Sort(new NameComparer());
					break;
				case SortFields.TTL:
					base.Sort(new TTLComparer());
					break;
			}
			if (!isAscending) base.Reverse();
		}"
"<summary> The purpose of this class hierarchy is to abstract different bitmap implementations across
platforms into a standard interface for requesting greyscale luminance values. The interface
only provides immutable methods; therefore crop and rotation create copies. This is to ensure
that one Reader does not modify the original luminance source and leave it in an unknown state
for other Readers in the chain.
</summary>","public abstract byte[] getRow(int y, byte[] row);
      public abstract byte[] Matrix { get; }"
"<summary> Returns a new object with cropped image data. Implementations may keep a reference to the
original data rather than a copy. Only callable if CropSupported is true.

</summary>","public virtual LuminanceSource crop(int left, int top, int width, int height)
      {
         throw new NotSupportedException(""This luminance source does not support cropping."");
      }"
"<summary>
Returns a new object with rotated image data by 90 degrees counterclockwise.
Only callable if {@link #isRotateSupported()} is true.
</summary>","public virtual LuminanceSource rotateCounterClockwise()
      {
         throw new NotSupportedException(""This luminance source does not support rotation."");
      }"
"<summary>
Returns a new object with rotated image data by 45 degrees counterclockwise.
Only callable if {@link #isRotateSupported()} is true.
</summary>","public virtual LuminanceSource rotateCounterClockwise45()
      {
         throw new NotSupportedException(""This luminance source does not support rotation by 45 degrees."");
      }"
"<summary> This class hierarchy provides a set of methods to convert luminance data to 1 bit data.
It allows the algorithm to vary polymorphically, for example allowing a very expensive
thresholding technique for servers and a fast one for mobile. It also permits the implementation
to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.

<author>dswitkin@google.com (Daniel Switkin)</author>
</summary>","protected internal Binarizer(LuminanceSource source)
      {
         if (source"
"<summary>
Gets the luminance source object.
</summary>","public abstract BitArray getBlackRow(int y, BitArray row);
      public abstract BitMatrix BlackMatrix { get; }"
"<summary> Creates a new object with the same type as this Binarizer implementation, but with pristine
state. This is needed because Binarizer implementations may be stateful, e.g. keeping a cache
of 1 bit data. See Effective Java for why we can't use Java's clone() method.
</summary>","public abstract Binarizer createBinarizer(LuminanceSource source);
      public int Width
      {
         get { return source.Width; }
      }"
"<summary> This class is the core bitmap class used by ZXing to represent 1 bit data. Reader objects
accept a BinaryBitmap and attempt to decode it.

</summary>","public BitArray getBlackRow(int y, BitArray row)
      {
         return binarizer.getBlackRow(y, row);
      }"
"<summary> Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive
and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or
may not apply sharpening. Therefore, a row from this matrix may not be identical to one
fetched using getBlackRow(), so don't mix and match between them.

</summary>","public BinaryBitmap crop(int left, int top, int width, int height)
      {
         var newSource = binarizer.LuminanceSource.crop(left, top, width, height);
         return new BinaryBitmap(binarizer.createBinarizer(newSource));
      }"
"<summary>
Returns a new object with rotated image data by 90 degrees counterclockwise.
Only callable if {@link #isRotateSupported()} is true.
</summary>","public BinaryBitmap rotateCounterClockwise()
      {
         var newSource = binarizer.LuminanceSource.rotateCounterClockwise();
         return new BinaryBitmap(binarizer.createBinarizer(newSource));
      }"
"<summary>
Returns a new object with rotated image data by 45 degrees counterclockwise.
Only callable if {@link #isRotateSupported()} is true.
</summary>","public BinaryBitmap rotateCounterClockwise45()
      {
         LuminanceSource newSource = binarizer.LuminanceSource.rotateCounterClockwise45();
         return new BinaryBitmap(binarizer.createBinarizer(newSource));
      }"
"<summary>
Returns a <see cref=""System.String""/> that represents this instance.
</summary>","public override string ToString()
      {
         var blackMatrix = BlackMatrix;
         return blackMatrix != null ? blackMatrix.ToString() : String.Empty;
      }"
"<summary>
Encapsulates the result of decoding a barcode within an image.
</summary>","public void putMetadata(ResultMetadataType type, Object value)
      {
         if (ResultMetadata"
"<summary>
Adds a list of metadata to the result
</summary>","public void putAllMetadata(IDictionary<ResultMetadataType, object> metadata)
      {
         if (metadata != null)
         {
            if (ResultMetadata"
"<summary>
Adds the result points.
</summary>","public void addResultPoints(ResultPoint[] newPoints)
      {
         var oldPoints = ResultPoints;
         if (oldPoints"
"<summary>
Returns a <see cref=""System.String""/> that represents this instance.
</summary>","public override String ToString()
      {
         if (Text"
"<summary>
Encapsulates a point of interest in an image containing a barcode. Typically, this
would be the location of a finder pattern or the corner of the barcode, for example.
</summary>","public override bool Equals(Object other)
      {
         var otherPoint = other as ResultPoint;
         if (otherPoint"
"<summary>
Returns a hash code for this instance.
</summary>","public override int GetHashCode()
      {
         return 31 * ((bytesX[0] << 24) + (bytesX[1] << 16) + (bytesX[2] << 8) + bytesX[3]) +
                      (bytesY[0] << 24) + (bytesY[1] << 16) + (bytesY[2] << 8) + bytesY[3];
      }"
"<summary>
Returns a <see cref=""System.String""/> that represents this instance.
</summary>","public override String ToString()
      {
         if (toString"
"<summary>
Orders an array of three ResultPoints in an order [A,B,C] such that AB &lt; AC and
BC &lt; AC and the angle between BC and BA is less than 180 degrees.
</summary>","public static void orderBestPatterns(ResultPoint[] patterns)
      {
         float zeroOneDistance = distance(patterns[0], patterns[1]);
         float oneTwoDistance = distance(patterns[1], patterns[2]);
         float zeroTwoDistance = distance(patterns[0], patterns[2]);
         ResultPoint pointA, pointB, pointC;
         if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance)
         {
            pointB = patterns[0];
            pointA = patterns[1];
            pointC = patterns[2];
         }
         else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance)
         {
            pointB = patterns[1];
            pointA = patterns[0];
            pointC = patterns[2];
         }
         else
         {
            pointB = patterns[2];
            pointA = patterns[0];
            pointC = patterns[1];
         }
         if (crossProductZ(pointA, pointB, pointC) < 0.0f)
         {
            ResultPoint temp = pointA;
            pointA = pointC;
            pointC = temp;
         }
         patterns[0] = pointA;
         patterns[1] = pointB;
         patterns[2] = pointC;
      }"
"<summary>
Returns the z component of the cross product between vectors BC and BA.
</summary>","private static float crossProductZ(ResultPoint pointA, ResultPoint pointB, ResultPoint pointC)
      {
         float bX = pointB.x;
         float bY = pointB.y;
         return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));
      }"
"<summary>
The base class for luminance sources which supports
cropping and rotating based upon the luminance values.
</summary>","override public byte[] getRow(int y, byte[] row)
      {
         int width = Width;
         if (row"
"<summary>
Returns a new object with rotated image data by 90 degrees counterclockwise.
Only callable if {@link #isRotateSupported()} is true.
</summary>","public override LuminanceSource rotateCounterClockwise()
      {
         var rotatedLuminances = new byte[Width * Height];
         var newWidth = Height;
         var newHeight = Width;
         var localLuminances = Matrix;
         for (var yold = 0; yold < Height; yold++)
         {
            for (var xold = 0; xold < Width; xold++)
            {
               var ynew = newHeight - xold - 1;
               var xnew = yold;
               rotatedLuminances[ynew * newWidth + xnew] = localLuminances[yold * Width + xold];
            }
         }
         return CreateLuminanceSource(rotatedLuminances, newWidth, newHeight);
      }"
"<summary>
TODO: not implemented yet
</summary>","public override LuminanceSource rotateCounterClockwise45()
      {
         return base.rotateCounterClockwise45();
      }"
"<summary>
Initializes a new instance of the <see cref=""BitmapLuminanceSource""/> class.
</summary>","protected override LuminanceSource CreateLuminanceSource(byte[] newLuminances, int width, int height)
      {
         return new BitmapLuminanceSource(width, height) { luminances = newLuminances };
      }"
"<summary>
This implementation can detect and decode QR Codes in an image.
<author>Sean Owen</author>
</summary>","protected Decoder getDecoder()
      {
         return decoder;
      }"
"<summary>
Locates and decodes a QR code in an image.

<returns>a String representing the content encoded by the QR code</returns>
</summary>","public Result decode(BinaryBitmap image)
      {
         return decode(image, null);
      }"
"<summary>
Locates and decodes a barcode in some format within an image. This method also accepts
hints, each possibly associated to some data, which may help the implementation decode.
</summary>","public Result decode(BinaryBitmap image, IDictionary<DecodeHintType, object> hints)
      {
         DecoderResult decoderResult;
         ResultPoint[] points;
         if (image"
"<summary>
Resets any internal state the implementation has after a decode, to prepare it
for reuse.
</summary>","public void reset()
      {
      }"
"<summary>
This method detects a code in a ""pure"" image -- that is, pure monochrome image
which contains only an unrotated, unskewed, image of a code, with some white border
around it. This is a specialized method that works exceptionally fast in this special
case.

<seealso cref=""ZXing.Datamatrix.DataMatrixReader.extractPureBits(BitMatrix)"" />
</summary>","private static BitMatrix extractPureBits(BitMatrix image)
      {
         int[] leftTopBlack = image.getTopLeftOnBit();
         int[] rightBottomBlack = image.getBottomRightOnBit();
         if (leftTopBlack"
"<summary>
Encode ""bytes"" with the error correction level ""ecLevel"". The encoding mode will be chosen
internally by chooseMode(). On success, store the result in ""qrCode"".
We recommend you to use QRCode.EC_LEVEL_L (the lowest level) for
""getECLevel"" since our primary use is to show QR code on desktop screens. We don't need very
strong error correction for this purpose.
Note that there is no way to encode bytes in MODE_KANJI. We might want to add EncodeWithMode()
with which clients can specify the encoding mode. For now, we don't need the functionality.
</summary>","public static QRCode encode(String content, ErrorCorrectionLevel ecLevel)
      {
         return encode(content, ecLevel, null);
      }"
"<summary>
Encodes the specified content.
</summary>","public static QRCode encode(String content,
                                ErrorCorrectionLevel ecLevel,
                                IDictionary<EncodeHintType, object> hints)
      {
#if !SILVERLIGHT || WINDOWS_PHONE
         String encoding = hints"
"<summary>
Gets the alphanumeric code.
</summary>","internal static int getAlphanumericCode(int code)
      {
         if (code < ALPHANUMERIC_TABLE.Length)
         {
            return ALPHANUMERIC_TABLE[code];
         }
         return -1;
      }"
"<summary>
Chooses the mode.
</summary>","public static Mode chooseMode(String content)
      {
         return chooseMode(content, null);
      }"
"<summary>
Choose the best mode by examining the content. Note that 'encoding' is used as a hint;
if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.
</summary>","private static Mode chooseMode(String content, String encoding)
      {
         return Mode.BYTE;
      }"
"<summary>
Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
</summary>","internal static void terminateBits(int numDataBytes, BitArray bits)
      {
         int capacity = numDataBytes << 3;
         if (bits.Size > capacity)
         {
            throw new WriterException(""data bits cannot fit in the QR Code"" + bits.Size + "" > "" +
                capacity);
         }
         for (int i = 0; i < 4 && bits.Size < capacity; ++i)
         {
            bits.appendBit(false);
         }
         int numBitsInLastByte = bits.Size & 0x07;
         if (numBitsInLastByte > 0)
         {
            for (int i = numBitsInLastByte; i < 8; i++)
            {
               bits.appendBit(false);
            }
         }
         int numPaddingBytes = numDataBytes - bits.SizeInBytes;
         for (int i = 0; i < numPaddingBytes; ++i)
         {
            bits.appendBits((i & 0x01)"
"<summary>
Get number of data bytes and number of error correction bytes for block id ""blockID"". Store
the result in ""numDataBytesInBlock"", and ""numECBytesInBlock"". See table 12 in 8.5.1 of
JISX0510:2004 (p.30)
</summary>","internal static void getNumDataBytesAndNumECBytesForBlockID(int numTotalBytes,
                                                         int numDataBytes,
                                                         int numRSBlocks,
                                                         int blockID,
                                                         int[] numDataBytesInBlock,
                                                         int[] numECBytesInBlock)
      {
         if (blockID >= numRSBlocks)
         {
            throw new WriterException(""Block ID too large"");
         }
         int numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
         int numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
         int numTotalBytesInGroup1 = numTotalBytes / numRSBlocks;
         int numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
         int numDataBytesInGroup1 = numDataBytes / numRSBlocks;
         int numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
         int numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
         int numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
         if (numEcBytesInGroup1 != numEcBytesInGroup2)
         {
            throw new WriterException(""EC bytes mismatch"");
         }
         if (numRSBlocks != numRsBlocksInGroup1 + numRsBlocksInGroup2)
         {
            throw new WriterException(""RS blocks mismatch"");
         }
         if (numTotalBytes !=
             ((numDataBytesInGroup1 + numEcBytesInGroup1) *
                 numRsBlocksInGroup1) +
                 ((numDataBytesInGroup2 + numEcBytesInGroup2) *
                     numRsBlocksInGroup2))
         {
            throw new WriterException(""Total bytes mismatch"");
         }
         if (blockID < numRsBlocksInGroup1)
         {
            numDataBytesInBlock[0] = numDataBytesInGroup1;
            numECBytesInBlock[0] = numEcBytesInGroup1;
         }
         else
         {
            numDataBytesInBlock[0] = numDataBytesInGroup2;
            numECBytesInBlock[0] = numEcBytesInGroup2;
         }
      }"
"<summary>
Interleave ""bits"" with corresponding error correction bytes. On success, store the result in
""result"". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.
</summary>","internal static BitArray interleaveWithECBytes(BitArray bits,
                                             int numTotalBytes,
                                             int numDataBytes,
                                             int numRSBlocks)
      {
         if (bits.SizeInBytes != numDataBytes)
         {
            throw new WriterException(""Number of bits and data bytes does not match"");
         }
         int dataBytesOffset = 0;
         int maxNumDataBytes = 0;
         int maxNumEcBytes = 0;
         var blocks = new List<BlockPair>(numRSBlocks);
         for (int i = 0; i < numRSBlocks; ++i)
         {
            int[] numDataBytesInBlock = new int[1];
            int[] numEcBytesInBlock = new int[1];
            getNumDataBytesAndNumECBytesForBlockID(
                numTotalBytes, numDataBytes, numRSBlocks, i,
                numDataBytesInBlock, numEcBytesInBlock);
            int size = numDataBytesInBlock[0];
            byte[] dataBytes = new byte[size];
            bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);
            byte[] ecBytes = generateECBytes(dataBytes, numEcBytesInBlock[0]);
            blocks.Add(new BlockPair(dataBytes, ecBytes));
            maxNumDataBytes = Math.Max(maxNumDataBytes, size);
            maxNumEcBytes = Math.Max(maxNumEcBytes, ecBytes.Length);
            dataBytesOffset += numDataBytesInBlock[0];
         }
         if (numDataBytes != dataBytesOffset)
         {
            throw new WriterException(""Data bytes does not match offset"");
         }
         BitArray result = new BitArray();
         for (int i = 0; i < maxNumDataBytes; ++i)
         {
            foreach (BlockPair block in blocks)
            {
               byte[] dataBytes = block.DataBytes;
               if (i < dataBytes.Length)
               {
                  result.appendBits(dataBytes[i], 8);
               }
            }
         }
         for (int i = 0; i < maxNumEcBytes; ++i)
         {
            foreach (BlockPair block in blocks)
            {
               byte[] ecBytes = block.ErrorCorrectionBytes;
               if (i < ecBytes.Length)
               {
                  result.appendBits(ecBytes[i], 8);
               }
            }
         }
         if (numTotalBytes != result.SizeInBytes)
         {  
            throw new WriterException(""Interleaving error: "" + numTotalBytes + "" and "" +
                result.SizeInBytes + "" differ."");
         }
         return result;
      }"
"<summary>
Append mode info. On success, store the result in ""bits"".
</summary>","internal static void appendModeInfo(Mode mode, BitArray bits)
      {
         bits.appendBits(mode.Bits, 4);
      }"
"<summary>
Append length info. On success, store the result in ""bits"".
</summary>","internal static void appendLengthInfo(int numLetters, Version version, Mode mode, BitArray bits)
      {
         int numBits = mode.getCharacterCountBits(version);
         if (numLetters >= (1 << numBits))
         {
            throw new WriterException(numLetters + "" is bigger than "" + ((1 << numBits) - 1));
         }
         bits.appendBits(numLetters, numBits);
      }"
"<summary>
Append ""bytes"" in ""mode"" mode (encoding) into ""bits"". On success, store the result in ""bits"".
</summary>","internal static void appendBytes(String content,
                              Mode mode,
                              BitArray bits,
                              String encoding)
      {
        if (mode.Equals(Mode.BYTE))
            append8BitBytes(content, bits, encoding);
            else
                throw new WriterException(""Invalid mode: "" + mode);
      }"
"<summary>
JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned
0, 1 and 2 I'm going to use less memory and go with bytes.
</summary>","public void set(int x, int y, byte value)
      {
         bytes[y][x] = value;
      }"
"<summary>
Sets the specified x.
</summary>","public void set(int x, int y, bool value)
      {
         bytes[y][x] = (byte)(value ? 1 : 0);
      }"
"<summary>
Clears the specified value.
</summary>","public void clear(byte value)
      {
         for (int y = 0; y < height; ++y)
         {
            for (int x = 0; x < width; ++x)
            {
               bytes[y][x] = value;
            }
         }
      }"
"<summary>
Returns a <see cref=""System.String""/> that represents this instance.
</summary>","override public String ToString()
      {
         var result = new StringBuilder(2 * width * height + 2);
         for (int y = 0; y < height; ++y)
         {
            for (int x = 0; x < width; ++x)
            {
               switch (bytes[y][x])
               {
                  case 0:
                     result.Append("" 0"");
                     break;
                  case 1:
                     result.Append("" 1"");
                     break;
                  default:
                     result.Append(""  "");
                     break;
               }
            }
            result.Append('\n');
         }
         return result.ToString();
      }"
"<summary>
Build 2D matrix of QR Code from ""dataBits"" with ""ecLevel"", ""version"" and ""getMaskPattern"". On
success, store the result in ""matrix"" and return true.
</summary>","public static void buildMatrix(BitArray dataBits, ErrorCorrectionLevel ecLevel, Version version, int maskPattern, ByteMatrix matrix)
      {
         clearMatrix(matrix);
         embedBasicPatterns(version, matrix);
         embedTypeInfo(ecLevel, maskPattern, matrix);
         maybeEmbedVersionInfo(version, matrix);
         embedDataBits(dataBits, maskPattern, matrix);
      }"
"<summary>
Embed basic patterns. On success, modify the matrix and return true.
The basic patterns are:
- Position detection patterns
- Timing patterns
- Dark dot at the left bottom corner
- Position adjustment patterns, if need be
</summary>","public static void embedBasicPatterns(Version version, ByteMatrix matrix)
      {
         embedPositionDetectionPatternsAndSeparators(matrix);
         embedDarkDotAtLeftBottomCorner(matrix);
         maybeEmbedPositionAdjustmentPatterns(version, matrix);
         embedTimingPatterns(matrix);
      }"
"<summary>
Embed type information. On success, modify the matrix.
</summary>","public static void embedTypeInfo(ErrorCorrectionLevel ecLevel, int maskPattern, ByteMatrix matrix)
      {
         BitArray typeInfoBits = new BitArray();
         makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
         for (int i = 0; i < typeInfoBits.Size; ++i)
         {
            int bit = typeInfoBits[typeInfoBits.Size - 1 - i] ? 1 : 0;
            int x1 = TYPE_INFO_COORDINATES[i][0];
            int y1 = TYPE_INFO_COORDINATES[i][1];
            matrix[x1, y1] = bit;
            if (i < 8)
            {
               int x2 = matrix.Width - i - 1;
               int y2 = 8;
               matrix[x2, y2] = bit;
            }
            else
            {
               int x2 = 8;
               int y2 = matrix.Height - 7 + (i - 8);
               matrix[x2, y2] = bit;
            }
         }
      }"
"<summary>
Embed version information if need be. On success, modify the matrix and return true.
See 8.10 of JISX0510:2004 (p.47) for how to embed version information.
</summary>","public static void maybeEmbedVersionInfo(Version version, ByteMatrix matrix)
      {
         if (version.VersionNumber < 7)
         {
            return; 
         }
         BitArray versionInfoBits = new BitArray();
         makeVersionInfoBits(version, versionInfoBits);
         int bitIndex = 6 * 3 - 1; 
         for (int i = 0; i < 6; ++i)
         {
            for (int j = 0; j < 3; ++j)
            {
               var bit = versionInfoBits[bitIndex] ? 1 : 0;
               bitIndex--;
               matrix[i, matrix.Height - 11 + j] = bit;
               matrix[matrix.Height - 11 + j, i] = bit;
            }
         }
      }"
"<summary>
Embed ""dataBits"" using ""getMaskPattern"". On success, modify the matrix and return true.
For debugging purposes, it skips masking process if ""getMaskPattern"" is -1.
See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.
</summary>","public static void embedDataBits(BitArray dataBits, int maskPattern, ByteMatrix matrix)
      {
         int bitIndex = 0;
         int direction = -1;
         int x = matrix.Width - 1;
         int y = matrix.Height - 1;
         while (x > 0)
         {
            if (x"
"<summary>
Return the position of the most significant bit set (to one) in the ""value"". The most
significant bit is position 32. If there is no bit set, return 0. Examples:
- findMSBSet(0) => 0
- findMSBSet(1) => 1
- findMSBSet(255) => 8
</summary>","public static int findMSBSet(int value_Renamed)
      {
         int numDigits = 0;
         while (value_Renamed != 0)
         {
            value_Renamed = (int)((uint)value_Renamed >> 1);
            ++numDigits;
         }
         return numDigits;
      }"
"<summary>
Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for ""value"" using polynomial ""poly"". The BCH
code is used for encoding type information and version information.
Example: Calculation of version information of 7.
f(x) is created from 7.
- 7 = 000111 in 6 bits
- f(x) = x^2 + x^2 + x^1
g(x) is given by the standard (p. 67)
- g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1
Multiply f(x) by x^(18 - 6)
- f'(x) = f(x) * x^(18 - 6)
- f'(x) = x^14 + x^13 + x^12
Calculate the remainder of f'(x) / g(x)
x^2
__________________________________________________
g(x) )x^14 + x^13 + x^12
x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2
--------------------------------------------------
x^11 + x^10 + x^7 + x^4 + x^2

The remainder is x^11 + x^10 + x^7 + x^4 + x^2
Encode it in binary: 110010010100
The return value is 0xc94 (1100 1001 0100)

Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit
operations. We don't care if cofficients are positive or negative.
</summary>","public static int calculateBCHCode(int value, int poly)
      {
         int msbSetInPoly = findMSBSet(poly);
         value <<= msbSetInPoly - 1;
         while (findMSBSet(value) >= msbSetInPoly)
         {
            value ^= poly << (findMSBSet(value) - msbSetInPoly);
         }
         return value;
      }"
"<summary>
Make bit vector of type information. On success, store the result in ""bits"" and return true.
Encode error correction level and mask pattern. See 8.9 of
JISX0510:2004 (p.45) for details.
</summary>","public static void makeTypeInfoBits(ErrorCorrectionLevel ecLevel, int maskPattern, BitArray bits)
      {
         if (!QRCode.isValidMaskPattern(maskPattern))
         {
            throw new WriterException(""Invalid mask pattern"");
         }
         int typeInfo = (ecLevel.Bits << 3) | maskPattern;
         bits.appendBits(typeInfo, 5);
         int bchCode = calculateBCHCode(typeInfo, TYPE_INFO_POLY);
         bits.appendBits(bchCode, 10);
         BitArray maskBits = new BitArray();
         maskBits.appendBits(TYPE_INFO_MASK_PATTERN, 15);
         bits.xor(maskBits);
         if (bits.Size != 15)
         {
            throw new WriterException(""should not happen but we got: "" + bits.Size);
         }
      }"
"<summary>
Make bit vector of version information. On success, store the result in ""bits"" and return true.
See 8.10 of JISX0510:2004 (p.45) for details.
</summary>","public static void makeVersionInfoBits(Version version, BitArray bits)
      {
         bits.appendBits(version.VersionNumber, 6);
         int bchCode = calculateBCHCode(version.VersionNumber, VERSION_INFO_POLY);
         bits.appendBits(bchCode, 12);
         if (bits.Size != 18)
         {
            throw new WriterException(""should not happen but we got: "" + bits.Size);
         }
      }"
"<summary>
Check if ""value"" is empty.
</summary>","private static bool isEmpty(int value)
      {
         return value"
"<summary>
Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)
</summary>","private static void embedDarkDotAtLeftBottomCorner(ByteMatrix matrix)
      {
         if (matrix[8, matrix.Height - 8]"
"<summary>
Note that we cannot unify the function with embedPositionDetectionPattern() despite they are
almost identical, since we cannot write a function that takes 2D arrays in different sizes in
C/C++. We should live with the fact.
</summary>","private static void embedPositionAdjustmentPattern(int xStart, int yStart, ByteMatrix matrix)
      {
         for (int y = 0; y < 5; ++y)
         {
            for (int x = 0; x < 5; ++x)
            {
               matrix[xStart + x, yStart + y] = POSITION_ADJUSTMENT_PATTERN[y][x];
            }
         }
      }"
"<summary>
Embed position detection patterns and surrounding vertical/horizontal separators.
</summary>","private static void embedPositionDetectionPatternsAndSeparators(ByteMatrix matrix)
      {
         int pdpWidth = POSITION_DETECTION_PATTERN[0].Length;
         embedPositionDetectionPattern(0, 0, matrix);
         embedPositionDetectionPattern(matrix.Width - pdpWidth, 0, matrix);
         embedPositionDetectionPattern(0, matrix.Width - pdpWidth, matrix);
         const int hspWidth = 8;
         embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
         embedHorizontalSeparationPattern(matrix.Width - hspWidth, hspWidth - 1, matrix);
         embedHorizontalSeparationPattern(0, matrix.Width - hspWidth, matrix);
         const int vspSize = 7;
         embedVerticalSeparationPattern(vspSize, 0, matrix);
         embedVerticalSeparationPattern(matrix.Height - vspSize - 1, 0, matrix);
         embedVerticalSeparationPattern(vspSize, matrix.Height - vspSize, matrix);
      }"
"<summary>
Embed position adjustment patterns if need be.
</summary>","private static void maybeEmbedPositionAdjustmentPatterns(Version version, ByteMatrix matrix)
      {
         if (version.VersionNumber < 2)
         {
            return;
         }
         int index = version.VersionNumber - 1;
         int[] coordinates = POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
         int numCoordinates = POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index].Length;
         for (int i = 0; i < numCoordinates; ++i)
         {
            for (int j = 0; j < numCoordinates; ++j)
            {
               int y = coordinates[i];
               int x = coordinates[j];
               if (x"
"<summary>
Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give
penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a
penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.
</summary>","public static int applyMaskPenaltyRule2(ByteMatrix matrix)
      {
         int penalty = 0;
         var array = matrix.Array;
         int width = matrix.Width;
         int height = matrix.Height;
         for (int y = 0; y < height - 1; y++)
         {
            for (int x = 0; x < width - 1; x++)
            {
               int value = array[y][x];
               if (value"
"<summary>
Apply mask penalty rule 3 and return the penalty. Find consecutive cells of 00001011101 or
10111010000, and give penalty to them.  If we find patterns like 000010111010000, we give
penalties twice (i.e. 40 * 2).
</summary>","public static int applyMaskPenaltyRule3(ByteMatrix matrix)
      {
         int numPenalties = 0;
         byte[][] array = matrix.Array;
         int width = matrix.Width;
         int height = matrix.Height;
         for (int y = 0; y < height; y++)
         {
            for (int x = 0; x < width; x++)
            {
               byte[] arrayY = array[y];  
               if (x + 6 < width &&
                   arrayY[x]"
"<summary>
Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give
penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.
</summary>","public static int applyMaskPenaltyRule4(ByteMatrix matrix)
      {
         int numDarkCells = 0;
         var array = matrix.Array;
         int width = matrix.Width;
         int height = matrix.Height;
         for (int y = 0; y < height; y++)
         {
            var arrayY = array[y];
            for (int x = 0; x < width; x++)
            {
               if (arrayY[x]"
"<summary>
Return the mask bit for ""getMaskPattern"" at ""x"" and ""y"". See 8.8 of JISX0510:2004 for mask
pattern conditions.
</summary>","public static bool getDataMaskBit(int maskPattern, int x, int y)
      {
         int intermediate, temp;
         switch (maskPattern)
         {
            case 0:
               intermediate = (y + x) & 0x1;
               break;
            case 1:
               intermediate = y & 0x1;
               break;
            case 2:
               intermediate = x % 3;
               break;
            case 3:
               intermediate = (y + x) % 3;
               break;
            case 4:
               intermediate = (((int)((uint)y >> 1)) + (x / 3)) & 0x1;
               break;
            case 5:
               temp = y * x;
               intermediate = (temp & 0x1) + (temp % 3);
               break;
            case 6:
               temp = y * x;
               intermediate = (((temp & 0x1) + (temp % 3)) & 0x1);
               break;
            case 7:
               temp = y * x;
               intermediate = (((temp % 3) + ((y + x) & 0x1)) & 0x1);
               break;
            default:
               throw new ArgumentException(""Invalid mask pattern: "" + maskPattern);
         }
         return intermediate"
"<summary>
Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both
vertical and horizontal orders respectively.
</summary>","private static int applyMaskPenaltyRule1Internal(ByteMatrix matrix, bool isHorizontal)
      {
         int penalty = 0;
         int iLimit = isHorizontal ? matrix.Height : matrix.Width;
         int jLimit = isHorizontal ? matrix.Width : matrix.Height;
         var array = matrix.Array;
         for (int i = 0; i < iLimit; i++)
         {
            int numSameBitCells = 0;
            int prevBit = -1;
            for (int j = 0; j < jLimit; j++)
            {
               int bit = isHorizontal ? array[i][j] : array[j][i];
               if (bit"
"<summary> <p>Encapsulates a QR Code's format information, including the data mask used and
error correction level.</p>

</summary>","internal static int numBitsDiffering(int a, int b)
      {
         a ^= b; 
         return BITS_SET_IN_HALF_BYTE[a & 0x0F] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 4)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 8)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 12)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 16)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 20)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 24)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 28)) & 0x0F)];
      }"
"<summary>
Decodes the format information.
</summary>","internal static FormatInformation decodeFormatInformation(int maskedFormatInfo1, int maskedFormatInfo2)
      {
         FormatInformation formatInfo = doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
         if (formatInfo != null)
         {
            return formatInfo;
         }
         return doDecodeFormatInformation(maskedFormatInfo1 ^ FORMAT_INFO_MASK_QR,
                                          maskedFormatInfo2 ^ FORMAT_INFO_MASK_QR);
      }"
"<summary>
<p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels
defined by the QR code standard.</p>
</summary>","public int ordinal()
      {
         return ordinal_Renamed_Field;
      }"
"<summary>
Returns a <see cref=""System.String""/> that represents this instance.
</summary>","public override String ToString()
      {
         return name;
      }"
"<summary>
Fors the bits.
</summary>","public static ErrorCorrectionLevel forBits(int bits)
      {
         if (bits < 0 || bits >= FOR_BITS.Length)
         {
            throw new ArgumentException();
         }
         return FOR_BITS[bits];
      }"
"<summary> <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes
in one QR Code. This class decodes the bits back into text.</p>

<p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>
<author>Sean Owen</author>
</summary>","internal static DecoderResult decode(byte[] bytes,
                                           Version version,
                                           ErrorCorrectionLevel ecLevel,
                                           IDictionary<DecodeHintType, object> hints)
      {
         var bits = new BitSource(bytes);
         var result = new StringBuilder(50);
         var byteSegments = new List<byte[]>(1);
         var symbolSequence = -1;
         var parityData = -1;
         try
         {
            bool fc1InEffect = false;
            Mode mode;
            do
            {
               if (bits.available() < 4)
               {
                  mode = Mode.TERMINATOR;
               }
               else
               {
                  try
                  {
                     mode = Mode.forBits(bits.readBits(4)); 
                  }
                  catch (ArgumentException)
                  {
                     return null;
                  }
               }
               if (mode != Mode.TERMINATOR)
               {
                  if (mode"
"<summary>
See specification GBT 18284-2000
</summary>","private static bool decodeHanziSegment(BitSource bits,
                                             StringBuilder result,
                                             int count)
      {
         if (count * 13 > bits.available())
         {
            return false;
         }
         byte[] buffer = new byte[2 * count];
         int offset = 0;
         while (count > 0)
         {
            int twoBytes = bits.readBits(13);
            int assembledTwoBytes = ((twoBytes / 0x060) << 8) | (twoBytes % 0x060);
            if (assembledTwoBytes < 0x003BF)
            {
               assembledTwoBytes += 0x0A1A1;
            }
            else
            {
               assembledTwoBytes += 0x0A6A1;
            }
            buffer[offset] = (byte)((assembledTwoBytes >> 8) & 0xFF);
            buffer[offset + 1] = (byte)(assembledTwoBytes & 0xFF);
            offset += 2;
            count--;
         }
         try
         {
            result.Append(Encoding.GetEncoding(StringUtils.GB2312).GetString(buffer, 0, buffer.Length));
         }
#if (WINDOWS_PHONE70 || WINDOWS_PHONE71 || SILVERLIGHT4 || SILVERLIGHT5 || NETFX_CORE || MONOANDROID || MONOTOUCH)
         catch (ArgumentException)
         {
            try
            {
               result.Append(Encoding.GetEncoding(""UTF-8"").GetString(buffer, 0, buffer.Length));
            }
            catch (Exception)
            {
               return false;
            }
         }
#endif
         catch (Exception)
         {
            return false;
         }
         return true;
      }"
"<summary>
<p>The main class which implements QR Code decoding -- as opposed to locating and extracting
the QR Code from an image.</p>
</summary>","public DecoderResult decode(bool[][] image, IDictionary<DecodeHintType, object> hints)
      {
         var dimension = image.Length;
         var bits = new BitMatrix(dimension);
         for (int i = 0; i < dimension; i++)
         {
            for (int j = 0; j < dimension; j++)
            {
               bits[j, i] = image[i][j];
            }
         }
         return decode(bits, hints);
      }"
"<summary>
<p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or ""true"" is taken to mean a black module.</p>
</summary>","public DecoderResult decode(BitMatrix bits, IDictionary<DecodeHintType, object> hints)
      {
         var parser = BitMatrixParser.createBitMatrixParser(bits);
         if (parser"
"<summary>
<p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
correct the errors in-place using Reed-Solomon error correction.</p>
</summary>","private bool correctErrors(byte[] codewordBytes, int numDataCodewords)
      {
         int numCodewords = codewordBytes.Length;
         int[] codewordsInts = new int[numCodewords];
         for (int i = 0; i < numCodewords; i++)
         {
            codewordsInts[i] = codewordBytes[i] & 0xFF;
         }
         int numECCodewords = codewordBytes.Length - numDataCodewords;
         if (!rsDecoder.decode(codewordsInts, numECCodewords))
            return false;
         for (int i = 0; i < numDataCodewords; i++)
         {
            codewordBytes[i] = (byte)codewordsInts[i];
         }
         return true;
      }"
"<summary> <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into
multiple blocks, each of which is a unit of data and error-correction codewords. Each
is represented by an instance of this class.</p>

</summary>","internal static DataBlock[] getDataBlocks(byte[] rawCodewords, Version version, ErrorCorrectionLevel ecLevel)
      {
         if (rawCodewords.Length != version.TotalCodewords)
         {
            throw new System.ArgumentException();
         }
         Version.ECBlocks ecBlocks = version.getECBlocksForLevel(ecLevel);
         int totalBlocks = 0;
         Version.ECB[] ecBlockArray = ecBlocks.getECBlocks();
         foreach (var ecBlock in ecBlockArray)
         {
            totalBlocks += ecBlock.Count;
         }
         DataBlock[] result = new DataBlock[totalBlocks];
         int numResultBlocks = 0;
         foreach (var ecBlock in ecBlockArray)
         {
            for (int i = 0; i < ecBlock.Count; i++)
            {
               int numDataCodewords = ecBlock.DataCodewords;
               int numBlockCodewords = ecBlocks.ECCodewordsPerBlock + numDataCodewords;
               result[numResultBlocks++] = new DataBlock(numDataCodewords, new byte[numBlockCodewords]);
            }
         }
         int shorterBlocksTotalCodewords = result[0].codewords.Length;
         int longerBlocksStartAt = result.Length - 1;
         while (longerBlocksStartAt >= 0)
         {
            int numCodewords = result[longerBlocksStartAt].codewords.Length;
            if (numCodewords"
"<summary> <p>Deduces version information purely from QR Code dimensions.</p>

</summary>","public static Version getProvisionalVersionForDimension(int dimension)
      {
         if (dimension % 4 != 1)
         {
            return null;
         }
         try
         {
            return getVersionForNumber((dimension - 17) >> 2);
         }
         catch (ArgumentException)
         {
            return null;
         }
      }"
"<summary>
Gets the version for number.
</summary>","public static Version getVersionForNumber(int versionNumber)
      {
         if (versionNumber < 1 || versionNumber > 40)
         {
            throw new ArgumentException();
         }
         return VERSIONS[versionNumber - 1];
      }"
<summary> See ISO 18004:2006 Annex E</summary>,"internal BitMatrix buildFunctionPattern()
      {
         int dimension = DimensionForVersion;
         BitMatrix bitMatrix = new BitMatrix(dimension);
         bitMatrix.setRegion(0, 0, 9, 9);
         bitMatrix.setRegion(dimension - 8, 0, 8, 9);
         bitMatrix.setRegion(0, dimension - 8, 9, 8);
         int max = alignmentPatternCenters.Length;
         for (int x = 0; x < max; x++)
         {
            int i = alignmentPatternCenters[x] - 2;
            for (int y = 0; y < max; y++)
            {
               if ((x"
"<summary> <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will
use blocks of differing sizes within one version, so, this encapsulates the parameters for
each set of blocks. It also holds the number of error-correction codewords per block since it
will be the same across all blocks within one version.</p>
</summary>","public ECB[] getECBlocks()
         {
            return ecBlocks;
         }"
"<summary> <p>Encapsualtes the parameters for one error-correction block in one symbol version.
This includes the number of data codewords, and the number of times a block with these
parameters is used consecutively in the QR code version's format.</p>
</summary>","public override String ToString()
      {
         return Convert.ToString(versionNumber);
      }"
<summary> See ISO 18004:2006 6.5.1 Table 9</summary>,"private static Version[] buildVersions()
      {
         return new Version[]{
            new Version(1, new int[]{},
               new ECBlocks(7, new ECB(1, 19)),
               new ECBlocks(10, new ECB(1, 16)),
               new ECBlocks(13, new ECB(1, 13)),
               new ECBlocks(17, new ECB(1, 9))),
            new Version(2, new int[]{6, 18},
               new ECBlocks(10, new ECB(1, 34)),
               new ECBlocks(16, new ECB(1, 28)),
               new ECBlocks(22, new ECB(1, 22)),
               new ECBlocks(28, new ECB(1, 16))),
            new Version(3, new int[]{6, 22},
               new ECBlocks(15, new ECB(1, 55)),
               new ECBlocks(26, new ECB(1, 44)),
               new ECBlocks(18, new ECB(2, 17)),
               new ECBlocks(22, new ECB(2, 13))),
            new Version(4, new int[]{6, 26},
               new ECBlocks(20, new ECB(1, 80)),
               new ECBlocks(18, new ECB(2, 32)),
               new ECBlocks(26, new ECB(2, 24)),
               new ECBlocks(16, new ECB(4, 9))),
            new Version(5, new int[]{6, 30},
               new ECBlocks(26, new ECB(1, 108)),
               new ECBlocks(24, new ECB(2, 43)),
               new ECBlocks(18, new ECB(2, 15),
                  new ECB(2, 16)),
               new ECBlocks(22, new ECB(2, 11),
                  new ECB(2, 12))),
            new Version(6, new int[]{6, 34},
               new ECBlocks(18, new ECB(2, 68)),
               new ECBlocks(16, new ECB(4, 27)),
               new ECBlocks(24, new ECB(4, 19)),
               new ECBlocks(28, new ECB(4, 15))),
            new Version(7, new int[]{6, 22, 38},
               new ECBlocks(20, new ECB(2, 78)),
               new ECBlocks(18, new ECB(4, 31)),
               new ECBlocks(18, new ECB(2, 14),
                  new ECB(4, 15)),
               new ECBlocks(26, new ECB(4, 13),
                  new ECB(1, 14))),
            new Version(8, new int[]{6, 24, 42},
               new ECBlocks(24, new ECB(2, 97)),
               new ECBlocks(22, new ECB(2, 38),
                  new ECB(2, 39)),
               new ECBlocks(22, new ECB(4, 18),
                  new ECB(2, 19)),
               new ECBlocks(26, new ECB(4, 14),
                  new ECB(2, 15))),
            new Version(9, new int[]{6, 26, 46},
               new ECBlocks(30, new ECB(2, 116)),
               new ECBlocks(22, new ECB(3, 36),
                  new ECB(2, 37)),
               new ECBlocks(20, new ECB(4, 16),
                  new ECB(4, 17)),
               new ECBlocks(24, new ECB(4, 12),
                  new ECB(4, 13))),
            new Version(10, new int[]{6, 28, 50},
               new ECBlocks(18, new ECB(2, 68),
                  new ECB(2, 69)),
               new ECBlocks(26, new ECB(4, 43),
                  new ECB(1, 44)),
               new ECBlocks(24, new ECB(6, 19),
                  new ECB(2, 20)),
               new ECBlocks(28, new ECB(6, 15),
                  new ECB(2, 16))),
            new Version(11, new int[]{6, 30, 54}, new ECBlocks(20, new ECB(4, 81)),
				new ECBlocks(30, new ECB(1, 50), new ECB(4, 51)), new ECBlocks(28, new ECB(4, 22), new ECB(4, 23)), new ECBlocks(24, new ECB(3, 12), new ECB(8, 13))), new Version(12, new int[]{6, 32, 58}, new ECBlocks(24, new ECB(2, 92), new ECB(2, 93)), new ECBlocks(22, new ECB(6, 36), new ECB(2, 37)), new ECBlocks(26, new ECB(4, 20), new ECB(6, 21)), new ECBlocks(28, new ECB(7, 14), new ECB(4, 15))), new Version(13, new int[]{6, 34, 62}, new ECBlocks(26, new ECB(4, 107)), new ECBlocks(22, new ECB(8, 37), new ECB(1, 38)), new ECBlocks(24, new ECB(8, 20), new ECB(4, 21)), new ECBlocks(22, new ECB(12, 11), new ECB(4, 12))), new Version(14, new int[]{6, 26, 46, 66}, new ECBlocks(30, new ECB(3, 115), new ECB(1, 116)), new ECBlocks(24, new ECB(4, 40), new ECB(5, 41)), new ECBlocks(20, new ECB(11, 16), new ECB(5, 17)), new ECBlocks(24, new ECB(11, 12), new ECB(5, 13))), new Version(15, new int[]{6, 26, 48, 70}, new ECBlocks(22, new ECB(5, 87), new ECB(1, 88)), new ECBlocks(24, new ECB(5, 41), new ECB(5, 42)), new ECBlocks(30, new ECB(5, 24), new ECB(7, 25)), new ECBlocks(24, new ECB(11, 12), new ECB(7, 13))), new Version(16, new int[]{6, 26, 50, 74}, new ECBlocks(24, new ECB(5, 98), new ECB(1, 99)), new ECBlocks(28, new ECB(7, 45), new ECB(3, 46)), new ECBlocks(24, new ECB(15, 19), new ECB(2, 20)), new ECBlocks(30, new ECB(3, 15), new ECB(13, 16))), new Version(17, new int[]{6, 30, 54, 78}, new ECBlocks(28, new ECB(1, 107), new ECB(5, 108)), new ECBlocks(28, new ECB(10, 46), new ECB(1, 47)), new ECBlocks(28, new ECB(1, 22), new ECB(15, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(17, 15))), new Version(18, new int[]{6, 30, 56, 82}, new ECBlocks(30, new ECB(5, 120), new ECB(1, 121)), new ECBlocks(26, new ECB(9, 43), new ECB(4, 44)), new ECBlocks(28, new ECB(17, 22), new ECB(1, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(19, 15))), new Version(19, new int[]{6, 30, 58, 86}, new ECBlocks(28, new ECB(3, 113), new ECB(4, 114)), new ECBlocks(26, new ECB(3, 44), new ECB(11, 45)), new ECBlocks(26, new ECB(17, 21),
				new ECB(4, 22)), new ECBlocks(26, new ECB(9, 13), new ECB(16, 14))), new Version(20, new int[]{6, 34, 62, 90}, new ECBlocks(28, new ECB(3, 107), new ECB(5, 108)), new ECBlocks(26, new ECB(3, 41), new ECB(13, 42)), new ECBlocks(30, new ECB(15, 24), new ECB(5, 25)), new ECBlocks(28, new ECB(15, 15), new ECB(10, 16))), new Version(21, new int[]{6, 28, 50, 72, 94}, new ECBlocks(28, new ECB(4, 116), new ECB(4, 117)), new ECBlocks(26, new ECB(17, 42)), new ECBlocks(28, new ECB(17, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(19, 16), new ECB(6, 17))), new Version(22, new int[]{6, 26, 50, 74, 98}, new ECBlocks(28, new ECB(2, 111), new ECB(7, 112)), new ECBlocks(28, new ECB(17, 46)), new ECBlocks(30, new ECB(7, 24), new ECB(16, 25)), new ECBlocks(24, new ECB(34, 13))), new Version(23, new int[]{6, 30, 54, 74, 102}, new ECBlocks(30, new ECB(4, 121), new ECB(5, 122)), new ECBlocks(28, new ECB(4, 47), new ECB(14, 48)), new ECBlocks(30, new ECB(11, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(16, 15), new ECB(14, 16))), new Version(24, new int[]{6, 28, 54, 80, 106}, new ECBlocks(30, new ECB(6, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(6, 45), new ECB(14, 46)), new ECBlocks(30, new ECB(11, 24), new ECB(16, 25)), new ECBlocks(30, new ECB(30, 16), new ECB(2, 17))), new Version(25, new int[]{6, 32, 58, 84, 110}, new ECBlocks(26, new ECB(8, 106), new ECB(4, 107)), new ECBlocks(28, new ECB(8, 47), new ECB(13, 48)), new ECBlocks(30, new ECB(7, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(13, 16))), new Version(26, new int[]{6, 30, 58, 86, 114}, new ECBlocks(28, new ECB(10, 114), new ECB(2, 115)), new ECBlocks(28, new ECB(19, 46), new ECB(4, 47)), new ECBlocks(28, new ECB(28, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(33, 16), new ECB(4, 17))), new Version(27, new int[]{6, 34, 62, 90, 118}, new ECBlocks(30, new ECB(8, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(22, 45), new ECB(3, 46)), new ECBlocks(30, new ECB(8, 23), new ECB(26, 24)), new ECBlocks(30, new ECB(12, 15),
				new ECB(28, 16))), new Version(28, new int[]{6, 26, 50, 74, 98, 122}, new ECBlocks(30, new ECB(3, 117), new ECB(10, 118)), new ECBlocks(28, new ECB(3, 45), new ECB(23, 46)), new ECBlocks(30, new ECB(4, 24), new ECB(31, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(31, 16))), new Version(29, new int[]{6, 30, 54, 78, 102, 126}, new ECBlocks(30, new ECB(7, 116), new ECB(7, 117)), new ECBlocks(28, new ECB(21, 45), new ECB(7, 46)), new ECBlocks(30, new ECB(1, 23), new ECB(37, 24)), new ECBlocks(30, new ECB(19, 15), new ECB(26, 16))), new Version(30, new int[]{6, 26, 52, 78, 104, 130}, new ECBlocks(30, new ECB(5, 115), new ECB(10, 116)), new ECBlocks(28, new ECB(19, 47), new ECB(10, 48)), new ECBlocks(30, new ECB(15, 24), new ECB(25, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(25, 16))), new Version(31, new int[]{6, 30, 56, 82, 108, 134}, new ECBlocks(30, new ECB(13, 115), new ECB(3, 116)), new ECBlocks(28, new ECB(2, 46), new ECB(29, 47)), new ECBlocks(30, new ECB(42, 24), new ECB(1, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(28, 16))), new Version(32, new int[]{6, 34, 60, 86, 112, 138}, new ECBlocks(30, new ECB(17, 115)), new ECBlocks(28, new ECB(10, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(10, 24), new ECB(35, 25)), new ECBlocks(30, new ECB(19, 15), new ECB(35, 16))), new Version(33, new int[]{6, 30, 58, 86, 114, 142}, new ECBlocks(30, new ECB(17, 115), new ECB(1, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(21, 47)), new ECBlocks(30, new ECB(29, 24), new ECB(19, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(46, 16))), new Version(34, new int[]{6, 34, 62, 90, 118, 146}, new ECBlocks(30, new ECB(13, 115), new ECB(6, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(44, 24), new ECB(7, 25)), new ECBlocks(30, new ECB(59, 16), new ECB(1, 17))), new Version(35, new int[]{6, 30, 54, 78, 102, 126, 150}, new ECBlocks(30, new ECB(12, 121), new ECB(7, 122)), new ECBlocks(28, new ECB(12, 47), new ECB(26, 48)), new ECBlocks(30, new ECB(39, 24), new
				ECB(14, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(41, 16))), new Version(36, new int[]{6, 24, 50, 76, 102, 128, 154}, new ECBlocks(30, new ECB(6, 121), new ECB(14, 122)), new ECBlocks(28, new ECB(6, 47), new ECB(34, 48)), new ECBlocks(30, new ECB(46, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(2, 15), new ECB(64, 16))), new Version(37, new int[]{6, 28, 54, 80, 106, 132, 158}, new ECBlocks(30, new ECB(17, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(29, 46), new ECB(14, 47)), new ECBlocks(30, new ECB(49, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(24, 15), new ECB(46, 16))), new Version(38, new int[]{6, 32, 58, 84, 110, 136, 162}, new ECBlocks(30, new ECB(4, 122), new ECB(18, 123)), new ECBlocks(28, new ECB(13, 46), new ECB(32, 47)), new ECBlocks(30, new ECB(48, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(42, 15), new ECB(32, 16))), new Version(39, new int[]{6, 26, 54, 82, 110, 138, 166}, new ECBlocks(30, new ECB(20, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(40, 47), new ECB(7, 48)), new ECBlocks(30, new ECB(43, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(10, 15), new ECB(67, 16))), new Version(40, new int[]{6, 30, 58, 86, 114, 142, 170}, new ECBlocks(30, new ECB(19, 118), new ECB(6, 119)), new ECBlocks(28, new ECB(18, 47), new ECB(31, 48)), new ECBlocks(30, new ECB(34, 24), new ECB(34, 25)), new ECBlocks(30, new ECB(20, 15), new ECB(61, 16)))};
      }"
"<summary> <p>Reads format information from one of its two locations within the QR Code.</p>

</summary>","internal FormatInformation readFormatInformation()
      {
         if (parsedFormatInfo != null)
         {
            return parsedFormatInfo;
         }
         int formatInfoBits1 = 0;
         for (int i = 0; i < 6; i++)
         {
            formatInfoBits1 = copyBit(i, 8, formatInfoBits1);
         }
         formatInfoBits1 = copyBit(7, 8, formatInfoBits1);
         formatInfoBits1 = copyBit(8, 8, formatInfoBits1);
         formatInfoBits1 = copyBit(8, 7, formatInfoBits1);
         for (int j = 5; j >= 0; j--)
         {
            formatInfoBits1 = copyBit(8, j, formatInfoBits1);
         }
         int dimension = bitMatrix.Height;
         int formatInfoBits2 = 0;
         int jMin = dimension - 7;
         for (int j = dimension - 1; j >= jMin; j--)
         {
            formatInfoBits2 = copyBit(8, j, formatInfoBits2);
         }
         for (int i = dimension - 8; i < dimension; i++)
         {
            formatInfoBits2 = copyBit(i, 8, formatInfoBits2);
         }
         parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
         if (parsedFormatInfo != null)
         {
            return parsedFormatInfo;
         }
         return null;
      }"
"<summary> <p>Reads version information from one of its two locations within the QR Code.</p>

</summary>","internal Version readVersion()
      {
         if (parsedVersion != null)
         {
            return parsedVersion;
         }
         int dimension = bitMatrix.Height;
         int provisionalVersion = (dimension - 17) >> 2;
         if (provisionalVersion <= 6)
         {
            return Version.getVersionForNumber(provisionalVersion);
         }
         int versionBits = 0;
         int ijMin = dimension - 11;
         for (int j = 5; j >= 0; j--)
         {
            for (int i = dimension - 9; i >= ijMin; i--)
            {
               versionBits = copyBit(i, j, versionBits);
            }
         }
         parsedVersion = Version.decodeVersionInformation(versionBits);
         if (parsedVersion != null && parsedVersion.DimensionForVersion"
"<summary> <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the
correct order in order to reconstruct the codewords bytes contained within the
QR Code.</p>

</summary>","internal byte[] readCodewords()
      {
         FormatInformation formatInfo = readFormatInformation();
         if (formatInfo"
"<summary>
<p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which
data can be encoded to bits in the QR code standard.</p>
</summary>","public static Mode forBits(int bits)
      {
         switch (bits)
         {
            case 0x0:
               return TERMINATOR;
            case 0x1:
               return NUMERIC;
            case 0x2:
               return ALPHANUMERIC;
            case 0x3:
               return STRUCTURED_APPEND;
            case 0x4:
               return BYTE;
            case 0x5:
               return FNC1_FIRST_POSITION;
            case 0x7:
               return ECI;
            case 0x8:
               return KANJI;
            case 0x9:
               return FNC1_SECOND_POSITION;
            case 0xD:
               return HANZI;
            default:
               throw new ArgumentException();
         }
      }"
"<summary>
Gets the bits.
</summary>","public override String ToString()
      {
         return name;
      }"
"<summary>
Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the
decoding caller. Callers are expected to process this.
</summary>","public void applyMirroredCorrection(ResultPoint[] points)
      {
         if (!mirrored || points"
"<summary> <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations
of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,
including areas used for finder patterns, timing patterns, etc. These areas should be unused
after the point they are unmasked anyway.</p>

<p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position
and j is row position. In fact, as the text says, i is row position and j is column position.</p>

</summary>","internal void unmaskBitMatrix(BitMatrix bits, int dimension)
      {
         for (int i = 0; i < dimension; i++)
         {
            for (int j = 0; j < dimension; j++)
            {
               if (isMasked(i, j))
               {
                  bits.flip(j, i);
               }
            }
         }
      }"
<summary> 000: mask bits for which (x + y) mod 2 == 0</summary>,"internal override bool isMasked(int i, int j)
         {
            return ((i + j) & 0x01)"
<summary> 001: mask bits for which x mod 2 == 0</summary>,"internal override bool isMasked(int i, int j)
         {
            return (i & 0x01)"
<summary> 010: mask bits for which y mod 3 == 0</summary>,"internal override bool isMasked(int i, int j)
         {
            return j % 3"
<summary> 011: mask bits for which (x + y) mod 3 == 0</summary>,"internal override bool isMasked(int i, int j)
         {
            return (i + j) % 3"
<summary> 100: mask bits for which (x/2 + y/3) mod 2 == 0</summary>,"internal override bool isMasked(int i, int j)
         {
            return ((((int)((uint)i >> 1)) + (j / 3)) & 0x01)"
<summary> 101: mask bits for which xy mod 2 + xy mod 3 == 0</summary>,"internal override bool isMasked(int i, int j)
         {
            int temp = i * j;
            return (temp & 0x01) + (temp % 3)"
<summary> 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0</summary>,"internal override bool isMasked(int i, int j)
         {
            int temp = i * j;
            return (((temp & 0x01) + (temp % 3)) & 0x01)"
<summary> 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0</summary>,"internal override bool isMasked(int i, int j)
         {
            return ((((i + j) & 0x01) + ((i * j) % 3)) & 0x01)"
"<summary>
<p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code
is rotated or skewed, or partially obscured.</p>
</summary>","public virtual DetectorResult detect()
      {
         return detect(null);
      }"
"<summary>
<p>Detects a QR Code in an image, simply.</p>
</summary>","public virtual DetectorResult detect(IDictionary<DecodeHintType, object> hints)
      {
         resultPointCallback = hints"
"<summary>
Processes the finder pattern info.
</summary>","protected internal virtual DetectorResult processFinderPatternInfo(FinderPatternInfo info)
      {
         FinderPattern topLeft = info.TopLeft;
         FinderPattern topRight = info.TopRight;
         FinderPattern bottomLeft = info.BottomLeft;
         float moduleSize = calculateModuleSize(topLeft, topRight, bottomLeft);
         if (moduleSize < 1.0f)
         {
            return null;
         }
         int dimension;
         if (!computeDimension(topLeft, topRight, bottomLeft, moduleSize, out dimension))
            return null;
         Internal.Version provisionalVersion = Internal.Version.getProvisionalVersionForDimension(dimension);
         if (provisionalVersion"
"<summary> <p>Computes the dimension (number of modules on a size) of the QR Code based on the position
of the finder patterns and estimated module size.</p>
</summary>","private static bool computeDimension(ResultPoint topLeft, ResultPoint topRight, ResultPoint bottomLeft, float moduleSize, out int dimension)
      {
         int tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);
         int tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);
         dimension = ((tltrCentersDimension + tlblCentersDimension) >> 1) + 7;
         switch (dimension & 0x03)
         {
            case 0:
               dimension++;
               break;
            case 2:
               dimension--;
               break;
            case 3:
               return true;
         }
         return true;
      }"
"<summary> <p>Computes an average estimated module size based on estimated derived from the positions
of the three finder patterns.</p>
</summary>","protected internal virtual float calculateModuleSize(ResultPoint topLeft, ResultPoint topRight, ResultPoint bottomLeft)
      {
         return (calculateModuleSizeOneWay(topLeft, topRight) + calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0f;
      }"
"<summary> <p>Estimates module size based on two finder patterns -- it uses
{@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the
width of each, measuring along the axis between their centers.</p>
</summary>","private float calculateModuleSizeOneWay(ResultPoint pattern, ResultPoint otherPattern)
      {
         float moduleSizeEst1 = sizeOfBlackWhiteBlackRunBothWays((int)pattern.X, (int)pattern.Y, (int)otherPattern.X, (int)otherPattern.Y);
         float moduleSizeEst2 = sizeOfBlackWhiteBlackRunBothWays((int)otherPattern.X, (int)otherPattern.Y, (int)pattern.X, (int)pattern.Y);
         if (Single.IsNaN(moduleSizeEst1))
         {
            return moduleSizeEst2 / 7.0f;
         }
         if (Single.IsNaN(moduleSizeEst2))
         {
            return moduleSizeEst1 / 7.0f;
         }
         return (moduleSizeEst1 + moduleSizeEst2) / 14.0f;
      }"
"<summary> See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of
a finder pattern by looking for a black-white-black run from the center in the direction
of another point (another finder pattern center), and in the opposite direction too.
</summary>","private float sizeOfBlackWhiteBlackRunBothWays(int fromX, int fromY, int toX, int toY)
      {
         float result = sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
         float scale = 1.0f;
         int otherToX = fromX - (toX - fromX);
         if (otherToX < 0)
         {
            scale = (float)fromX / (float)(fromX - otherToX);
            otherToX = 0;
         }
         else if (otherToX >= image.Width)
         {
            scale = (float)(image.Width - 1 - fromX) / (float)(otherToX - fromX);
            otherToX = image.Width - 1;
         }
         int otherToY = (int)(fromY - (toY - fromY) * scale);
         scale = 1.0f;
         if (otherToY < 0)
         {
            scale = (float)fromY / (float)(fromY - otherToY);
            otherToY = 0;
         }
         else if (otherToY >= image.Height)
         {
            scale = (float)(image.Height - 1 - fromY) / (float)(otherToY - fromY);
            otherToY = image.Height - 1;
         }
         otherToX = (int)(fromX + (otherToX - fromX) * scale);
         result += sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
         return result - 1.0f; 
      }"
"<summary> <p>This method traces a line from a point in the image, in the direction towards another point.
It begins in a black region, and keeps going until it finds white, then black, then white again.
It reports the distance from the start to this point.</p>

<p>This is used when figuring out how wide a finder pattern is, when the finder pattern
may be skewed or rotated.</p>
</summary>","private float sizeOfBlackWhiteBlackRun(int fromX, int fromY, int toX, int toY)
      {
         bool steep = Math.Abs(toY - fromY) > Math.Abs(toX - fromX);
         if (steep)
         {
            int temp = fromX;
            fromX = fromY;
            fromY = temp;
            temp = toX;
            toX = toY;
            toY = temp;
         }
         int dx = Math.Abs(toX - fromX);
         int dy = Math.Abs(toY - fromY);
         int error = -dx >> 1;
         int xstep = fromX < toX ? 1 : -1;
         int ystep = fromY < toY ? 1 : -1;
         int state = 0;"
"<summary>
<p>Attempts to locate an alignment pattern in a limited region of the image, which is
guessed to contain it. This method uses {@link AlignmentPattern}.</p>
</summary>","protected AlignmentPattern findAlignmentInRegion(float overallEstModuleSize, int estAlignmentX, int estAlignmentY, float allowanceFactor)
      {
         int allowance = (int)(allowanceFactor * overallEstModuleSize);
         int alignmentAreaLeftX = Math.Max(0, estAlignmentX - allowance);
         int alignmentAreaRightX = Math.Min(image.Width - 1, estAlignmentX + allowance);
         if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3)
         {
            return null;
         }
         int alignmentAreaTopY = Math.Max(0, estAlignmentY - allowance);
         int alignmentAreaBottomY = Math.Min(image.Height - 1, estAlignmentY + allowance);
         var alignmentFinder = new AlignmentPatternFinder(
            image,
            alignmentAreaLeftX,
            alignmentAreaTopY,
            alignmentAreaRightX - alignmentAreaLeftX,
            alignmentAreaBottomY - alignmentAreaTopY,
            overallEstModuleSize,
            resultPointCallback);
         return alignmentFinder.find();
      }"
"<summary>
<p>Encapsulates a finder pattern, which are the three square patterns found in
the corners of QR Codes. It also encapsulates a count of similar finder patterns,
as a convenience to the finder's bookkeeping.</p>
</summary>","internal void incrementCount()
      {
         this.count++;
      }"
"<summary> <p>Determines if this finder pattern ""about equals"" a finder pattern at the stated
position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
</summary>","internal bool aboutEquals(float moduleSize, float i, float j)
      {
         if (Math.Abs(i - Y) <= moduleSize && Math.Abs(j - X) <= moduleSize)
         {
            float moduleSizeDiff = Math.Abs(moduleSize - estimatedModuleSize);
            return moduleSizeDiff <= 1.0f || moduleSizeDiff <= estimatedModuleSize;
         }
         return false;
      }"
"<summary>
Combines this object's current estimate of a finder pattern position and module size
with a new estimate. It returns a new {@code FinderPattern} containing a weighted average
based on count.
</summary>","internal FinderPattern combineEstimate(float i, float j, float newModuleSize)
      {
         int combinedCount = count + 1;
         float combinedX = (count * X + j) / combinedCount;
         float combinedY = (count * Y + i) / combinedCount;
         float combinedModuleSize = (count * estimatedModuleSize + newModuleSize) / combinedCount;
         return new FinderPattern(combinedX, combinedY, combinedModuleSize, combinedCount);
      }"
"<summary>
<p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square
markers at three corners of a QR Code.</p>

<p>This class is thread-safe but not reentrant. Each thread must allocate its own object.
</summary>","internal virtual FinderPatternInfo find(IDictionary<DecodeHintType, object> hints)
      {
         bool tryHarder = hints != null && hints.ContainsKey(DecodeHintType.TRY_HARDER);
         bool pureBarcode = hints != null && hints.ContainsKey(DecodeHintType.PURE_BARCODE);
         int maxI = image.Height;
         int maxJ = image.Width;
         int iSkip = (3 * maxI) / (4 * MAX_MODULES);
         if (iSkip < MIN_SKIP || tryHarder)
         {
            iSkip = MIN_SKIP;
         }
         bool done = false;
         int[] stateCount = new int[5];
         for (int i = iSkip - 1; i < maxI && !done; i += iSkip)
         {
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            stateCount[3] = 0;
            stateCount[4] = 0;
            int currentState = 0;
            for (int j = 0; j < maxJ; j++)
            {
               if (image[j, i])
               {
                  if ((currentState & 1)"
"<summary> Given a count of black/white/black/white/black pixels just seen and an end position,
figures the location of the center of this run.
</summary>","protected internal static bool foundPatternCross(int[] stateCount)
      {
         int totalModuleSize = 0;
         for (int i = 0; i < 5; i++)
         {
            int count = stateCount[i];
            if (count"
"<summary>
After a vertical and horizontal scan finds a potential finder pattern, this method
""cross-cross-cross-checks"" by scanning down diagonally through the center of the possible
finder pattern to see if the same proportion is detected.
</summary>","private bool crossCheckDiagonal(int startI, int centerJ, int maxCount, int originalStateCountTotal)
      {
         int maxI = image.Height;
         int maxJ = image.Width;
         int[] stateCount = CrossCheckStateCount;
         int i = 0;
         while (startI - i >= 0 && image[centerJ - i, startI - i])
         {
            stateCount[2]++;
            i++;
         }
         if ((startI - i < 0) || (centerJ - i < 0))
         {
            return false;
         }
         while ((startI - i >= 0) && (centerJ - i >= 0) && !image[centerJ - i, startI - i] && stateCount[1] <= maxCount)
         {
            stateCount[1]++;
            i++;
         }
         if ((startI - i < 0) || (centerJ - i < 0) || stateCount[1] > maxCount)
         {
            return false;
         }
         while ((startI - i >= 0) && (centerJ - i >= 0) && image[centerJ - i, startI - i] && stateCount[0] <= maxCount)
         {
            stateCount[0]++;
            i++;
         }
         if (stateCount[0] > maxCount)
         {
            return false;
         }
         i = 1;
         while ((startI + i < maxI) && (centerJ + i < maxJ) && image[centerJ + i, startI + i])
         {
            stateCount[2]++;
            i++;
         }
         if ((startI + i >= maxI) || (centerJ + i >= maxJ))
         {
            return false;
         }
         while ((startI + i < maxI) && (centerJ + i < maxJ) && !image[centerJ + i, startI + i] && stateCount[3] < maxCount)
         {
            stateCount[3]++;
            i++;
         }
         if ((startI + i >= maxI) || (centerJ + i >= maxJ) || stateCount[3] >= maxCount)
         {
            return false;
         }
         while ((startI + i < maxI) && (centerJ + i < maxJ) && image[centerJ + i, startI + i] && stateCount[4] < maxCount)
         {
            stateCount[4]++;
            i++;
         }
         if (stateCount[4] >= maxCount)
         {
            return false;
         }
         int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
         return Math.Abs(stateCountTotal - originalStateCountTotal) < 2*originalStateCountTotal &&
                foundPatternCross(stateCount);
      }"
"<summary>
<p>After a horizontal scan finds a potential finder pattern, this method
""cross-checks"" by scanning down vertically through the center of the possible
finder pattern to see if the same proportion is detected.</p>
</summary>","protected bool handlePossibleCenter(int[] stateCount, int i, int j, bool pureBarcode)
      {
         int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
             stateCount[4];
         float? centerJ = centerFromEnd(stateCount, j);
         if (centerJ"
"<summary>
Orders by furthest from average
</summary>","public int Compare(FinderPattern x, FinderPattern y)
         {
            float dA = Math.Abs(y.EstimatedModuleSize - average);
            float dB = Math.Abs(x.EstimatedModuleSize - average);
            return dA < dB ? -1 : dA"
"<summary> <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder
patterns but are smaller and appear at regular intervals throughout the image.</p>

<p>At the moment this only looks for the bottom-right alignment pattern.</p>

<p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,
pasted and stripped down here for maximum performance but does unfortunately duplicate
some code.</p>

<p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>

</summary>","internal AlignmentPattern find()
      {
         int startX = this.startX;
         int height = this.height;
         int maxJ = startX + width;
         int middleI = startY + (height >> 1);
         int[] stateCount = new int[3];
         for (int iGen = 0; iGen < height; iGen++)
         {
            int i = middleI + ((iGen & 0x01)"
"<summary> Given a count of black/white/black pixels just seen and an end position,
figures the location of the center of this black/white/black run.
</summary>","private bool foundPatternCross(int[] stateCount)
      {
         float maxVariance = moduleSize / 2.0f;
         for (int i = 0; i < 3; i++)
         {
            if (Math.Abs(moduleSize - stateCount[i]) >= maxVariance)
            {
               return false;
            }
         }
         return true;
      }"
"<summary>
<p>After a horizontal scan finds a potential alignment pattern, this method
""cross-checks"" by scanning down vertically through the center of the possible
alignment pattern to see if the same proportion is detected.</p>
</summary>","private AlignmentPattern handlePossibleCenter(int[] stateCount, int i, int j)
      {
         int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
         float? centerJ = centerFromEnd(stateCount, j);
         if (centerJ"
"<summary> <p>Encapsulates an alignment pattern, which are the smaller square patterns found in
all but the simplest QR Codes.</p>

</summary>","internal bool aboutEquals(float moduleSize, float i, float j)
      {
         if (Math.Abs(i - Y) <= moduleSize && Math.Abs(j - X) <= moduleSize)
         {
            float moduleSizeDiff = Math.Abs(moduleSize - estimatedModuleSize);
            return moduleSizeDiff <= 1.0f || moduleSizeDiff <= estimatedModuleSize;
         }
         return false;
      }"
"<summary>
Combines this object's current estimate of a finder pattern position and module size
with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.
</summary>","internal AlignmentPattern combineEstimate(float i, float j, float newModuleSize)
      {
         float combinedX = (X + j) / 2.0f;
         float combinedY = (Y + i) / 2.0f;
         float combinedModuleSize = (estimatedModuleSize + newModuleSize) / 2.0f;
         return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
      }"
"<summary>
Common string-related functions.
</summary>","public static String guessEncoding(byte[] bytes, IDictionary<DecodeHintType, object> hints)
      {
         if (hints != null && hints.ContainsKey(DecodeHintType.CHARACTER_SET))
         {
            String characterSet = (String)hints[DecodeHintType.CHARACTER_SET];
            if (characterSet != null)
            {
               return characterSet;
            }
         }
         int length = bytes.Length;
         bool canBeISO88591 = true;
         bool canBeShiftJIS = true;
         bool canBeUTF8 = true;
         int utf8BytesLeft = 0;
         int utf2BytesChars = 0;
         int utf3BytesChars = 0;
         int utf4BytesChars = 0;
         int sjisBytesLeft = 0;
         int sjisKatakanaChars = 0;
         int sjisCurKatakanaWordLength = 0;
         int sjisCurDoubleBytesWordLength = 0;
         int sjisMaxKatakanaWordLength = 0;
         int sjisMaxDoubleBytesWordLength = 0;
         int isoHighOther = 0;
         bool utf8bom = bytes.Length > 3 &&
             bytes[0]"
"<summary>
A simple, fast array of bits, represented compactly by an array of ints internally.
</summary>","private void ensureCapacity(int size)
      {
         if (size > bits.Length << 5)
         {
            int[] newBits = makeArray(size);
            System.Array.Copy(bits, 0, newBits, 0, bits.Length);
            bits = newBits;
         }
      }"
"<summary> Sets a block of 32 bits, starting at bit i.

</summary>","public void setBulk(int i, int newBits)
      {
         bits[i >> 5] = newBits;
      }"
<summary> Clears all bits (sets to false).</summary>,"public void clear()
      {
         int max = bits.Length;
         for (int i = 0; i < max; i++)
         {
            bits[i] = 0;
         }
      }"
"<summary>
Appends the bit.
</summary>","public void appendBit(bool bit)
      {
         ensureCapacity(size + 1);
         if (bit)
         {
            bits[size >> 5] |= 1 << (size & 0x1F);
         }
         size++;
      }"
"<summary>
Appends the least-significant bits, from value, in order from most-significant to
least-significant. For example, appending 6 bits from 0x000001E will append the bits
0, 1, 1, 1, 1, 0 in that order.
</summary>","public void appendBits(int value, int numBits)
      {
         if (numBits < 0 || numBits > 32)
         {
            throw new ArgumentException(""Num bits must be between 0 and 32"");
         }
         ensureCapacity(size + numBits);
         for (int numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--)
         {
            appendBit(((value >> (numBitsLeft - 1)) & 0x01)"
"<summary>
Toes the bytes.
</summary>","public void toBytes(int bitOffset, byte[] array, int offset, int numBytes)
      {
         for (int i = 0; i < numBytes; i++)
         {
            int theByte = 0;
            for (int j = 0; j < 8; j++)
            {
               if (this[bitOffset])
               {
                  theByte |= 1 << (7 - j);
               }
               bitOffset++;
            }
            array[offset + i] = (byte)theByte;
         }
      }"
"<summary>
Determines whether the specified <see cref=""System.Object""/> is equal to this instance.
</summary>","public override bool Equals(Object o)
      {
         var other = o as BitArray;
         if (other"
"<summary>
Returns a hash code for this instance.
</summary>","public override int GetHashCode()
      {
         var hash = size;
         foreach (var bit in bits)
         {
            hash = 31 * hash + bit.GetHashCode();
         }
         return hash;
      }"
"<summary>
<p>Represents a 2D matrix of bits. In function arguments below, and throughout the common
module, x is the column position, and y is the row position. The ordering is always x, y.
The origin is at the top-left.</p>
<p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins
with a new int. This is done intentionally so that we can copy out a row into a BitArray very
efficiently.</p>
<p>The ordering of bits is row-major. Within each int, the least significant bits are used first,
meaning they represent lower x values. This is compatible with BitArray's implementation.</p>
</summary>","public void flip(int x, int y)
      {
         int offset = y * rowSize + (x >> 5);
         bits[offset] ^= 1 << (x & 0x1f);
      }"
"<summary> <p>Sets a square region of the bit matrix to true.</p>

</summary>","public void setRegion(int left, int top, int width, int height)
      {
         if (top < 0 || left < 0)
         {
            throw new System.ArgumentException(""Left and top must be nonnegative"");
         }
         if (height < 1 || width < 1)
         {
            throw new System.ArgumentException(""Height and width must be at least 1"");
         }
         int right = left + width;
         int bottom = top + height;
         if (bottom > this.height || right > this.width)
         {
            throw new System.ArgumentException(""The region must fit inside the matrix"");
         }
         for (int y = top; y < bottom; y++)
         {
            int offset = y * rowSize;
            for (int x = left; x < right; x++)
            {
               bits[offset + (x >> 5)] |= 1 << (x & 0x1f);
            }
         }
      }"
"<summary> A fast method to retrieve one row of data from the matrix as a BitArray.

</summary>","public BitArray getRow(int y, BitArray row)
      {
         if (row"
"<summary>
Sets the row.
</summary>","public void setRow(int y, BitArray row)
      {
         Array.Copy(row.Array, 0, bits, y * rowSize, rowSize);
      }"
"<summary>
This is useful in detecting a corner of a 'pure' barcode.
</summary>","public int[] getTopLeftOnBit()
      {
         int bitsOffset = 0;
         while (bitsOffset < bits.Length && bits[bitsOffset]"
"<summary> <p>This class implements a perspective transform in two dimensions. Given four source and four
destination points, it will compute the transformation implied between them. The code is based
directly upon section 3.4.2 of George Wolberg's ""Digital Image Warping""; see pages 54-56.</p>

</summary>","public static PerspectiveTransform quadrilateralToQuadrilateral(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float x0p, float y0p, float x1p, float y1p, float x2p, float y2p, float x3p, float y3p)
      {
         PerspectiveTransform qToS = quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
         PerspectiveTransform sToQ = squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
         return sToQ.times(qToS);
      }"
"<summary>Convenience method, not optimized for performance. </summary>","public void transformPoints(float[] xValues, float[] yValues)
      {
         int n = xValues.Length;
         for (int i = 0; i < n; i++)
         {
            float x = xValues[i];
            float y = yValues[i];
            float denominator = a13 * x + a23 * y + a33;
            xValues[i] = (a11 * x + a21 * y + a31) / denominator;
            yValues[i] = (a12 * x + a22 * y + a32) / denominator;
         }
      }"
"<summary> Implementations of this class can, given locations of finder patterns for a QR code in an
image, sample the right points in the image to reconstruct the QR code, accounting for
perspective distortion. It is abstracted since it is relatively expensive and should be allowed
to take advantage of platform-specific optimized implementations, like Sun's Java Advanced
Imaging library, but which may not be available in other environments such as J2ME, and vice
versa.

The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}
with an instance of a class which implements this interface.

</summary>","public static void setGridSampler(GridSampler newGridSampler)
      {
         if (newGridSampler"
"<summary> <p>Samples an image for a square matrix of bits of the given dimension. This is used to extract
the black/white modules of a 2D barcode like a QR Code found in an image. Because this barcode
may be rotated or perspective-distorted, the caller supplies four points in the source image
that define known points in the barcode, so that the image may be sampled appropriately.</p>

<p>The last eight ""from"" parameters are four X/Y coordinate pairs of locations of points in
the image that define some significant points in the image to be sample. For example,
these may be the location of finder pattern in a QR Code.</p>

<p>The first eight ""to"" parameters are four X/Y coordinate pairs measured in the destination
{@link BitMatrix}, from the top left, where the known points in the image given by the ""from""
parameters map to.</p>

<p>These 16 parameters define the transformation needed to sample the image.</p>

</summary>","public abstract BitMatrix sampleGrid(BitMatrix image, int dimensionX, int dimensionY, float p1ToX, float p1ToY, float p2ToX, float p2ToY, float p3ToX, float p3ToY, float p4ToX, float p4ToY, float p1FromX, float p1FromY, float p2FromX, float p2FromY, float p3FromX, float p3FromY, float p4FromX, float p4FromY);
      public virtual BitMatrix sampleGrid(BitMatrix image, int dimensionX, int dimensionY, PerspectiveTransform transform)
      {
         throw new System.NotSupportedException();
      }"
"<summary> <p>Checks a set of points that have been transformed to sample points on an image against
the image's dimensions to see if the point are even within the image.</p>

<p>This method will actually ""nudge"" the endpoints back onto the image if they are found to be
barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder
patterns in an image where the QR Code runs all the way to the image border.</p>

<p>For efficiency, the method will check points from either end of the line until one is found
to be within the image. Because the set of points are assumed to be linear, this is valid.</p>

</summary>","protected internal static bool checkAndNudgePoints(BitMatrix image, float[] points)
      {
         int width = image.Width;
         int height = image.Height;
         bool nudged = true;
         for (int offset = 0; offset < points.Length && nudged; offset += 2)
         {
            int x = (int)points[offset];
            int y = (int)points[offset + 1];
            if (x < -1 || x > width || y < -1 || y > height)
            {
               return false;
            }
            nudged = false;
            if (x"
"<summary> This Binarizer implementation uses the old ZXing global histogram approach. It is suitable
for low-end mobile devices which don't have enough CPU or memory to use a local thresholding
algorithm. However, because it picks a global black point, it cannot handle difficult shadows
and gradients.

Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.

<author>dswitkin@google.com (Daniel Switkin)</author>
<author>Sean Owen</author>
</summary>","public override BitArray getBlackRow(int y, BitArray row)
      {
         LuminanceSource source = LuminanceSource;
         int width = source.Width;
         if (row"
"<summary>
Does not sharpen the data, as this call is intended to only be used by 2D Readers.
</summary>","public override Binarizer createBinarizer(LuminanceSource source)
      {
         return new GlobalHistogramBinarizer(source);
      }"
"<summary> <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the
number of bits read is not often a multiple of 8.</p>

<p>This class is thread-safe but not reentrant. Unless the caller modifies the bytes array
it passed in, in which case all bets are off.</p>

</summary>","public int readBits(int numBits)
      {
         if (numBits < 1 || numBits > 32 || numBits > available())
         {
            throw new ArgumentException(numBits.ToString(), ""numBits"");
         }
         int result = 0;
         if (bitOffset > 0)
         {
            int bitsLeft = 8 - bitOffset;
            int toRead = numBits < bitsLeft ? numBits : bitsLeft;
            int bitsToNotRead = bitsLeft - toRead;
            int mask = (0xFF >> (8 - toRead)) << bitsToNotRead;
            result = (bytes[byteOffset] & mask) >> bitsToNotRead;
            numBits -= toRead;
            bitOffset += toRead;
            if (bitOffset"
"<summary> This class implements a local thresholding algorithm, which while slower than the
GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for
high frequency images of barcodes with black data on white backgrounds. For this application,
it does a much better job than a global blackpoint with severe shadows and gradients.
However it tends to produce artifacts on lower frequency images and is therefore not
a good general purpose binarizer for uses outside ZXing.

This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,
and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already
inherently local, and only fails for horizontal gradients. We can revisit that problem later,
but for now it was not a win to use local blocks for 1D.

This Binarizer is the default for the unit tests and the recommended class for library users.

</summary>","public override Binarizer createBinarizer(LuminanceSource source)
      {
         return new HybridBinarizer(source);
      }"
"<summary>
Calculates the final BitMatrix once for all requests. This could be called once from the
constructor instead, but there are some advantages to doing it lazily, such as making
profiling easier, and not doing heavy lifting when callers don't expect it.
</summary>","private void binarizeEntireImage()
      {
         if (matrix"
"<summary>
For each 8x8 block in the image, calculate the average black point using a 5x5 grid
of the blocks around it. Also handles the corner cases (fractional blocks are computed based
on the last 8 pixels in the row/column which are also used in the previous block).
</summary>","private static void calculateThresholdForBlock(byte[] luminances, int subWidth, int subHeight, int width, int height, int[][] blackPoints, BitMatrix matrix)
      {
         for (int y = 0; y < subHeight; y++)
         {
            int yoffset = y << BLOCK_SIZE_POWER;
            int maxYOffset = height - BLOCK_SIZE;
            if (yoffset > maxYOffset)
            {
               yoffset = maxYOffset;
            }
            for (int x = 0; x < subWidth; x++)
            {
               int xoffset = x << BLOCK_SIZE_POWER;
               int maxXOffset = width - BLOCK_SIZE;
               if (xoffset > maxXOffset)
               {
                  xoffset = maxXOffset;
               }
               int left = cap(x, 2, subWidth - 3);
               int top = cap(y, 2, subHeight - 3);
               int sum = 0;
               for (int z = -2; z <= 2; z++)
               {
                  int[] blackRow = blackPoints[top + z];
                  sum += blackRow[left - 2];
                  sum += blackRow[left - 1];
                  sum += blackRow[left];
                  sum += blackRow[left + 1];
                  sum += blackRow[left + 2];
               }
               int average = sum / 25;
               thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
            }
         }
      }"
"<summary>
Applies a single threshold to an 8x8 block of pixels.
</summary>","private static void thresholdBlock(byte[] luminances, int xoffset, int yoffset, int threshold, int stride, BitMatrix matrix)
      {
         int offset = (yoffset * stride) + xoffset;
         for (int y = 0; y < BLOCK_SIZE; y++, offset += stride)
         {
            for (int x = 0; x < BLOCK_SIZE; x++)
            {
               int pixel = luminances[offset + x] & 0xff;"
"<summary>
Calculates a single black point for each 8x8 block of pixels and saves it away.
See the following thread for a discussion of this algorithm:
http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
</summary>","private static int[][] calculateBlackPoints(byte[] luminances, int subWidth, int subHeight, int width, int height)
      {
         int[][] blackPoints = new int[subHeight][];
         for (int i = 0; i < subHeight; i++)
         {
            blackPoints[i] = new int[subWidth];
         }
         for (int y = 0; y < subHeight; y++)
         {
            int yoffset = y << BLOCK_SIZE_POWER;
            int maxYOffset = height - BLOCK_SIZE;
            if (yoffset > maxYOffset)
            {
               yoffset = maxYOffset;
            }
            for (int x = 0; x < subWidth; x++)
            {
               int xoffset = x << BLOCK_SIZE_POWER;
               int maxXOffset = width - BLOCK_SIZE;
               if (xoffset > maxXOffset)
               {
                  xoffset = maxXOffset;
               }
               int sum = 0;
               int min = 0xFF;
               int max = 0;
               for (int yy = 0, offset = yoffset * width + xoffset; yy < BLOCK_SIZE; yy++, offset += width)
               {
                  for (int xx = 0; xx < BLOCK_SIZE; xx++)
                  {
                     int pixel = luminances[offset + xx] & 0xFF;
                     sum += pixel;
                     if (pixel < min)
                     {
                        min = pixel;
                     }
                     if (pixel > max)
                     {
                        max = pixel;
                     }
                  }
                  if (max - min > MIN_DYNAMIC_RANGE)
                  {
                     for (yy++, offset += width; yy < BLOCK_SIZE; yy++, offset += width)
                     {
                        for (int xx = 0; xx < BLOCK_SIZE; xx++)
                        {
                           sum += luminances[offset + xx] & 0xFF;
                        }
                     }
                  }
               }
               int average = sum >> (BLOCK_SIZE_POWER * 2);
               if (max - min <= MIN_DYNAMIC_RANGE)
               {
                  average = min >> 1;
                  if (y > 0 && x > 0)
                  {
                     int averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) +
                         blackPoints[y - 1][x - 1]) >> 2;
                     if (min < averageNeighborBlackPoint)
                     {
                        average = averageNeighborBlackPoint;
                     }
                  }
               }
               blackPoints[y][x] = average;
            }
         }
         return blackPoints;
      }"
"<summary>
Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its
argument to the nearest int, where x.5 rounds up to x+1.
</summary>","public static int round(float d)
      {
         return (int)(d + 0.5f);
      }"
"<summary>
<p>This class contains utility methods for performing mathematical operations over
the Galois Fields. Operations use a given primitive polynomial in calculations.</p>
<p>Throughout this package, elements of the GF are represented as an {@code int}
for convenience and speed (but at the cost of memory).
</p>
</summary>","private void initialize()
      {
         expTable = new int[size];
         logTable = new int[size];
         int x = 1;
         for (int i = 0; i < size; i++)
         {
            expTable[i] = x;
            x <<= 1; 
            if (x >= size)
            {
               x ^= primitive;
               x &= size - 1;
            }
         }
         for (int i = 0; i < size - 1; i++)
         {
            logTable[expTable[i]] = i;
         }"
"<summary>
Builds the monomial.
</summary>","internal GenericGFPoly buildMonomial(int degree, int coefficient)
      {
         checkInit();
         if (degree < 0)
         {
            throw new ArgumentException();
         }
         if (coefficient"
"<summary>
Implements both addition and subtraction -- they are the same in GF(size).
</summary>","static internal int addOrSubtract(int a, int b)
      {
         return a ^ b;
      }"
"<summary>
Exps the specified a.
</summary>","internal int exp(int a)
      {
         checkInit();
         return expTable[a];
      }"
"<summary>
Logs the specified a.
</summary>","internal int log(int a)
      {
         checkInit();
         if (a"
"<summary>
Inverses the specified a.
</summary>","internal int inverse(int a)
      {
         checkInit();
         if (a"
"<summary>
Multiplies the specified a with b.
</summary>","internal int multiply(int a, int b)
      {
         checkInit();
         if (a"
"<summary>
Gets the size.
</summary>","override public String ToString()
      {
         return ""GF(0x"" + primitive.ToString(""X"") + ',' + size + ')';
      }"
"<summary>
Implements Reed-Solomon encoding, as the name implies.
</summary>","private GenericGFPoly buildGenerator(int degree)
      {
         if (degree >= cachedGenerators.Count)
         {
            var lastGenerator = cachedGenerators[cachedGenerators.Count - 1];
            for (int d = cachedGenerators.Count; d <= degree; d++)
            {
               var nextGenerator = lastGenerator.multiply(new GenericGFPoly(field, new int[] { 1, field.exp(d - 1 + field.GeneratorBase) }));
               cachedGenerators.Add(nextGenerator);
               lastGenerator = nextGenerator;
            }
         }
         return cachedGenerators[degree];
      }"
"<summary>
<p>Represents a polynomial whose coefficients are elements of a GF.
Instances of this class are immutable.</p>
<p>Much credit is due to William Rucklidge since portions of this code are an indirect
port of his C++ Reed-Solomon implementation.</p>
</summary>","internal int getCoefficient(int degree)
      {
         return coefficients[coefficients.Length - 1 - degree];
      }"
"<summary>
evaluation of this polynomial at a given point
</summary>","internal int evaluateAt(int a)
      {
         int result = 0;
         if (a"
"<summary> <p>Implements Reed-Solomon decoding, as the name implies.</p>

<p>The algorithm will not be explained here, but the following references were helpful
in creating this implementation:</p>

<ul>
<li>Bruce Maggs.
<a href=""http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps"">
""Decoding Reed-Solomon Codes""</a> (see discussion of Forney's Formula)</li>
<li>J.I. Hall. <a href=""www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf"">
""Chapter 5. Generalized Reed-Solomon Codes""</a>
(see discussion of Euclidean algorithm)</li>
</ul>

<p>Much credit is due to William Rucklidge since portions of this code are an indirect
port of his C++ Reed-Solomon implementation.</p>

</summary>","public bool decode(int[] received, int twoS)
      {
         var poly = new GenericGFPoly(field, received);
         var syndromeCoefficients = new int[twoS];
         var noError = true;
         for (var i = 0; i < twoS; i++)
         {
            var eval = poly.evaluateAt(field.exp(i + field.GeneratorBase));
            syndromeCoefficients[syndromeCoefficients.Length - 1 - i] = eval;
            if (eval != 0)
            {
               noError = false;
            }
         }
         if (noError)
         {
            return true;
         }
         var syndrome = new GenericGFPoly(field, syndromeCoefficients);
         var sigmaOmega = runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
         if (sigmaOmega"
"<summary>
Constants used in INTERNET_PER_CONN_OPTION_OptionUnion struct.
</summary>","public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }"
"<summary>
Get all entries from RAS
</summary>","public static uint GetAllConns(ref string[] allConns)
        {
            int lpNames = 0;
            int entryNameSize = 0;
            int lpSize = 0;
            uint retval = ERROR_SUCCESS;
            RasEntryName[] names = null;
            entryNameSize = Marshal.SizeOf(typeof(RasEntryName));
            retval = RasEnumEntries(null, null, null, ref lpSize, out lpNames);
            if (retval"
"<summary>
Checks or unchecks the IE Options Connection setting of ""Automatically detect Proxy""
</summary>","private static void IEProxyUpdate(Configuration config, int sysProxyMode)
        {
            using (RegistryKey registry = OpenUserRegKey(@""Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections"", true))
            {
                try
                {
                    byte[] defConnection = (byte[])registry.GetValue(""DefaultConnectionSettings"");
                    int counter = 0;
                    if (defConnection != null && defConnection.Length >= 8)
                    {
                        counter = defConnection[4] | (defConnection[5] << 8);
                    }
                    defConnection = GenConnectionSettings(config, sysProxyMode, counter);
                    RegistrySetValue(registry, ""DefaultConnectionSettings"", defConnection);
                    RegistrySetValue(registry, ""SavedLegacySettings"", defConnection);
                }
                catch (IOException e)
                {
                    Logging.LogUsefulException(e);
                }
            }
            using (RegistryKey registry = OpenUserRegKey(@""Software\Microsoft\Windows\CurrentVersion\Internet Settings"", true))
            {
                try
                {
                    RegistrySetValue(registry, ""ProxyOverride"", ""localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;172.32.*;192.168.*;<local>"");
                }
                catch (IOException e)
                {
                    Logging.LogUsefulException(e);
                }
            }
        }"
"<summary>
Required method for Designer support - do not modify
the contents of this method with the code editor.
</summary>","private void InitializeComponent()
        {
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();
            this.LabelRandom = new System.Windows.Forms.Label();
            this.RandomComboBox = new System.Windows.Forms.ComboBox();
            this.CheckAutoBan = new System.Windows.Forms.CheckBox();
            this.checkRandom = new System.Windows.Forms.CheckBox();
            this.checkAutoStartup = new System.Windows.Forms.CheckBox();
            this.checkBalanceInGroup = new System.Windows.Forms.CheckBox();
            this.Socks5ProxyGroup = new System.Windows.Forms.GroupBox();
            this.tableLayoutPanel9 = new System.Windows.Forms.TableLayoutPanel();
            this.LabelS5Password = new System.Windows.Forms.Label();
            this.LabelS5Username = new System.Windows.Forms.Label();
            this.TextS5Pass = new System.Windows.Forms.TextBox();
            this.LabelS5Port = new System.Windows.Forms.Label();
            this.TextS5User = new System.Windows.Forms.TextBox();
            this.LabelS5Server = new System.Windows.Forms.Label();
            this.NumS5Port = new System.Windows.Forms.NumericUpDown();
            this.TextS5Server = new System.Windows.Forms.TextBox();
            this.comboProxyType = new System.Windows.Forms.ComboBox();
            this.CheckSockProxy = new System.Windows.Forms.CheckBox();
            this.checkBoxPacProxy = new System.Windows.Forms.CheckBox();
            this.label1 = new System.Windows.Forms.Label();
            this.TextUserAgent = new System.Windows.Forms.TextBox();
            this.ListenGroup = new System.Windows.Forms.GroupBox();
            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();
            this.TextAuthPass = new System.Windows.Forms.TextBox();
            this.LabelAuthPass = new System.Windows.Forms.Label();
            this.TextAuthUser = new System.Windows.Forms.TextBox();
            this.LabelAuthUser = new System.Windows.Forms.Label();
            this.checkShareOverLan = new System.Windows.Forms.CheckBox();
            this.NumProxyPort = new System.Windows.Forms.NumericUpDown();
            this.ProxyPortLabel = new System.Windows.Forms.Label();
            this.tableLayoutPanel10 = new System.Windows.Forms.TableLayoutPanel();
            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();
            this.MyCancelButton = new System.Windows.Forms.Button();
            this.OKButton = new System.Windows.Forms.Button();
            this.tableLayoutPanel5 = new System.Windows.Forms.TableLayoutPanel();
            this.ReconnectLabel = new System.Windows.Forms.Label();
            this.NumReconnect = new System.Windows.Forms.NumericUpDown();
            this.TTLLabel = new System.Windows.Forms.Label();
            this.NumTTL = new System.Windows.Forms.NumericUpDown();
            this.labelTimeout = new System.Windows.Forms.Label();
            this.NumTimeout = new System.Windows.Forms.NumericUpDown();
            this.DNSText = new System.Windows.Forms.TextBox();
            this.buttonDefault = new System.Windows.Forms.Button();
            this.label2 = new System.Windows.Forms.Label();
            this.tableLayoutPanel1.SuspendLayout();
            this.tableLayoutPanel2.SuspendLayout();
            this.Socks5ProxyGroup.SuspendLayout();
            this.tableLayoutPanel9.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumS5Port)).BeginInit();
            this.ListenGroup.SuspendLayout();
            this.tableLayoutPanel4.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumProxyPort)).BeginInit();
            this.tableLayoutPanel10.SuspendLayout();
            this.tableLayoutPanel3.SuspendLayout();
            this.tableLayoutPanel5.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumReconnect)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumTTL)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumTimeout)).BeginInit();
            this.SuspendLayout();
            this.tableLayoutPanel1.AutoSize = true;
            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel1.ColumnCount = 2;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel2, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.Socks5ProxyGroup, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.ListenGroup, 0, 2);
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel10, 1, 2);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(15, 16);
            this.tableLayoutPanel1.Name = ""tableLayoutPanel1"";
            this.tableLayoutPanel1.RowCount = 3;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.Size = new System.Drawing.Size(581, 452);
            this.tableLayoutPanel1.TabIndex = 0;
            this.tableLayoutPanel2.AutoSize = true;
            this.tableLayoutPanel2.ColumnCount = 2;
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel2.Controls.Add(this.LabelRandom, 0, 2);
            this.tableLayoutPanel2.Controls.Add(this.RandomComboBox, 1, 2);
            this.tableLayoutPanel2.Controls.Add(this.CheckAutoBan, 1, 4);
            this.tableLayoutPanel2.Controls.Add(this.checkRandom, 1, 1);
            this.tableLayoutPanel2.Controls.Add(this.checkAutoStartup, 1, 0);
            this.tableLayoutPanel2.Controls.Add(this.checkBalanceInGroup, 1, 3);
            this.tableLayoutPanel2.Location = new System.Drawing.Point(372, 3);
            this.tableLayoutPanel2.Name = ""tableLayoutPanel2"";
            this.tableLayoutPanel2.RowCount = 5;
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.Size = new System.Drawing.Size(206, 118);
            this.tableLayoutPanel2.TabIndex = 2;
            this.LabelRandom.AutoSize = true;
            this.LabelRandom.Dock = System.Windows.Forms.DockStyle.Fill;
            this.LabelRandom.Location = new System.Drawing.Point(3, 44);
            this.LabelRandom.Name = ""LabelRandom"";
            this.LabelRandom.Size = new System.Drawing.Size(47, 30);
            this.LabelRandom.TabIndex = 12;
            this.LabelRandom.Text = ""Balance"";
            this.LabelRandom.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.RandomComboBox.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.RandomComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.RandomComboBox.FormattingEnabled = true;
            this.RandomComboBox.Items.AddRange(new object[] {
            ""Order"",
            ""Random"",
            ""LowLatency"",
            ""LowException"",
            ""SelectedFirst"",
            ""Timer""});
            this.RandomComboBox.Location = new System.Drawing.Point(56, 47);
            this.RandomComboBox.Margin = new System.Windows.Forms.Padding(3, 3, 3, 7);
            this.RandomComboBox.Name = ""RandomComboBox"";
            this.RandomComboBox.Size = new System.Drawing.Size(147, 20);
            this.RandomComboBox.TabIndex = 14;
            this.CheckAutoBan.AutoSize = true;
            this.CheckAutoBan.Enabled = false;
            this.CheckAutoBan.Location = new System.Drawing.Point(56, 99);
            this.CheckAutoBan.Name = ""CheckAutoBan"";
            this.CheckAutoBan.Size = new System.Drawing.Size(66, 16);
            this.CheckAutoBan.TabIndex = 15;
            this.CheckAutoBan.Text = ""AutoBan"";
            this.CheckAutoBan.UseVisualStyleBackColor = true;
            this.checkRandom.AutoSize = true;
            this.checkRandom.Location = new System.Drawing.Point(56, 25);
            this.checkRandom.Name = ""checkRandom"";
            this.checkRandom.Size = new System.Drawing.Size(96, 16);
            this.checkRandom.TabIndex = 13;
            this.checkRandom.Text = ""Load balance"";
            this.checkRandom.UseVisualStyleBackColor = true;
            this.checkAutoStartup.AutoSize = true;
            this.checkAutoStartup.Location = new System.Drawing.Point(56, 3);
            this.checkAutoStartup.Name = ""checkAutoStartup"";
            this.checkAutoStartup.Size = new System.Drawing.Size(102, 16);
            this.checkAutoStartup.TabIndex = 12;
            this.checkAutoStartup.Text = ""Start on Boot"";
            this.checkAutoStartup.UseVisualStyleBackColor = true;
            this.checkBalanceInGroup.AutoSize = true;
            this.checkBalanceInGroup.Location = new System.Drawing.Point(56, 77);
            this.checkBalanceInGroup.Name = ""checkBalanceInGroup"";
            this.checkBalanceInGroup.Size = new System.Drawing.Size(120, 16);
            this.checkBalanceInGroup.TabIndex = 15;
            this.checkBalanceInGroup.Text = ""Balance in group"";
            this.checkBalanceInGroup.UseVisualStyleBackColor = true;
            this.Socks5ProxyGroup.AutoSize = true;
            this.Socks5ProxyGroup.Controls.Add(this.tableLayoutPanel9);
            this.Socks5ProxyGroup.Location = new System.Drawing.Point(14, 0);
            this.Socks5ProxyGroup.Margin = new System.Windows.Forms.Padding(14, 0, 0, 0);
            this.Socks5ProxyGroup.Name = ""Socks5ProxyGroup"";
            this.tableLayoutPanel1.SetRowSpan(this.Socks5ProxyGroup, 2);
            this.Socks5ProxyGroup.Size = new System.Drawing.Size(355, 255);
            this.Socks5ProxyGroup.TabIndex = 0;
            this.Socks5ProxyGroup.TabStop = false;
            this.Socks5ProxyGroup.Text = ""Remote proxy"";
            this.tableLayoutPanel9.AutoSize = true;
            this.tableLayoutPanel9.ColumnCount = 2;
            this.tableLayoutPanel9.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel9.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel9.Controls.Add(this.LabelS5Password, 0, 5);
            this.tableLayoutPanel9.Controls.Add(this.LabelS5Username, 0, 4);
            this.tableLayoutPanel9.Controls.Add(this.TextS5Pass, 1, 5);
            this.tableLayoutPanel9.Controls.Add(this.LabelS5Port, 0, 3);
            this.tableLayoutPanel9.Controls.Add(this.TextS5User, 1, 4);
            this.tableLayoutPanel9.Controls.Add(this.LabelS5Server, 0, 2);
            this.tableLayoutPanel9.Controls.Add(this.NumS5Port, 1, 3);
            this.tableLayoutPanel9.Controls.Add(this.TextS5Server, 1, 2);
            this.tableLayoutPanel9.Controls.Add(this.comboProxyType, 1, 1);
            this.tableLayoutPanel9.Controls.Add(this.CheckSockProxy, 0, 0);
            this.tableLayoutPanel9.Controls.Add(this.checkBoxPacProxy, 1, 0);
            this.tableLayoutPanel9.Controls.Add(this.label1, 0, 6);
            this.tableLayoutPanel9.Controls.Add(this.TextUserAgent, 1, 6);
            this.tableLayoutPanel9.Location = new System.Drawing.Point(11, 32);
            this.tableLayoutPanel9.Name = ""tableLayoutPanel9"";
            this.tableLayoutPanel9.RowCount = 7;
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.Size = new System.Drawing.Size(338, 203);
            this.tableLayoutPanel9.TabIndex = 0;
            this.LabelS5Password.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelS5Password.AutoSize = true;
            this.LabelS5Password.Location = new System.Drawing.Point(22, 136);
            this.LabelS5Password.Name = ""LabelS5Password"";
            this.LabelS5Password.Size = new System.Drawing.Size(53, 12);
            this.LabelS5Password.TabIndex = 5;
            this.LabelS5Password.Text = ""Password"";
            this.LabelS5Username.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelS5Username.AutoSize = true;
            this.LabelS5Username.Location = new System.Drawing.Point(22, 109);
            this.LabelS5Username.Name = ""LabelS5Username"";
            this.LabelS5Username.Size = new System.Drawing.Size(53, 12);
            this.LabelS5Username.TabIndex = 4;
            this.LabelS5Username.Text = ""Username"";
            this.TextS5Pass.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextS5Pass.Location = new System.Drawing.Point(81, 132);
            this.TextS5Pass.Name = ""TextS5Pass"";
            this.TextS5Pass.Size = new System.Drawing.Size(236, 21);
            this.TextS5Pass.TabIndex = 6;
            this.LabelS5Port.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelS5Port.AutoSize = true;
            this.LabelS5Port.Location = new System.Drawing.Point(46, 82);
            this.LabelS5Port.Name = ""LabelS5Port"";
            this.LabelS5Port.Size = new System.Drawing.Size(29, 12);
            this.LabelS5Port.TabIndex = 1;
            this.LabelS5Port.Text = ""Port"";
            this.TextS5User.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextS5User.Location = new System.Drawing.Point(81, 105);
            this.TextS5User.Name = ""TextS5User"";
            this.TextS5User.Size = new System.Drawing.Size(236, 21);
            this.TextS5User.TabIndex = 5;
            this.LabelS5Server.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelS5Server.AutoSize = true;
            this.LabelS5Server.Location = new System.Drawing.Point(16, 55);
            this.LabelS5Server.Name = ""LabelS5Server"";
            this.LabelS5Server.Size = new System.Drawing.Size(59, 12);
            this.LabelS5Server.TabIndex = 0;
            this.LabelS5Server.Text = ""Server IP"";
            this.NumS5Port.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.NumS5Port.Location = new System.Drawing.Point(81, 78);
            this.NumS5Port.Maximum = new decimal(new int[] {
            65535,
            0,
            0,
            0});
            this.NumS5Port.Name = ""NumS5Port"";
            this.NumS5Port.Size = new System.Drawing.Size(236, 21);
            this.NumS5Port.TabIndex = 4;
            this.TextS5Server.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextS5Server.Location = new System.Drawing.Point(81, 51);
            this.TextS5Server.Name = ""TextS5Server"";
            this.TextS5Server.Size = new System.Drawing.Size(236, 21);
            this.TextS5Server.TabIndex = 3;
            this.comboProxyType.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.comboProxyType.FormattingEnabled = true;
            this.comboProxyType.Items.AddRange(new object[] {
            ""Socks5(support UDP)"",
            ""Http tunnel"",
            ""TCP Port tunnel""});
            this.comboProxyType.Location = new System.Drawing.Point(81, 25);
            this.comboProxyType.Name = ""comboProxyType"";
            this.comboProxyType.Size = new System.Drawing.Size(236, 20);
            this.comboProxyType.TabIndex = 2;
            this.CheckSockProxy.AutoSize = true;
            this.CheckSockProxy.Location = new System.Drawing.Point(3, 3);
            this.CheckSockProxy.Name = ""CheckSockProxy"";
            this.CheckSockProxy.Size = new System.Drawing.Size(72, 16);
            this.CheckSockProxy.TabIndex = 0;
            this.CheckSockProxy.Text = ""Proxy On"";
            this.CheckSockProxy.UseVisualStyleBackColor = true;
            this.checkBoxPacProxy.AutoSize = true;
            this.checkBoxPacProxy.Location = new System.Drawing.Point(81, 3);
            this.checkBoxPacProxy.Name = ""checkBoxPacProxy"";
            this.checkBoxPacProxy.Size = new System.Drawing.Size(204, 16);
            this.checkBoxPacProxy.TabIndex = 1;
            this.checkBoxPacProxy.Text = ""PAC \""direct\"" return this proxy"";
            this.checkBoxPacProxy.UseVisualStyleBackColor = true;
            this.label1.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(16, 173);
            this.label1.Name = ""label1"";
            this.label1.Size = new System.Drawing.Size(59, 12);
            this.label1.TabIndex = 5;
            this.label1.Text = ""UserAgent"";
            this.TextUserAgent.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextUserAgent.Location = new System.Drawing.Point(81, 159);
            this.TextUserAgent.Name = ""TextUserAgent"";
            this.TextUserAgent.Size = new System.Drawing.Size(236, 21);
            this.TextUserAgent.TabIndex = 7;
            this.ListenGroup.AutoSize = true;
            this.ListenGroup.Controls.Add(this.tableLayoutPanel4);
            this.ListenGroup.Location = new System.Drawing.Point(14, 255);
            this.ListenGroup.Margin = new System.Windows.Forms.Padding(14, 0, 0, 0);
            this.ListenGroup.Name = ""ListenGroup"";
            this.ListenGroup.Size = new System.Drawing.Size(339, 176);
            this.ListenGroup.TabIndex = 1;
            this.ListenGroup.TabStop = false;
            this.ListenGroup.Text = ""Local proxy"";
            this.tableLayoutPanel4.AutoSize = true;
            this.tableLayoutPanel4.ColumnCount = 2;
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel4.Controls.Add(this.TextAuthPass, 1, 3);
            this.tableLayoutPanel4.Controls.Add(this.LabelAuthPass, 0, 3);
            this.tableLayoutPanel4.Controls.Add(this.TextAuthUser, 1, 2);
            this.tableLayoutPanel4.Controls.Add(this.LabelAuthUser, 0, 2);
            this.tableLayoutPanel4.Controls.Add(this.checkShareOverLan, 1, 0);
            this.tableLayoutPanel4.Controls.Add(this.NumProxyPort, 1, 1);
            this.tableLayoutPanel4.Controls.Add(this.ProxyPortLabel, 0, 1);
            this.tableLayoutPanel4.Location = new System.Drawing.Point(5, 32);
            this.tableLayoutPanel4.Name = ""tableLayoutPanel4"";
            this.tableLayoutPanel4.RowCount = 4;
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel4.Size = new System.Drawing.Size(328, 124);
            this.tableLayoutPanel4.TabIndex = 0;
            this.TextAuthPass.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextAuthPass.Location = new System.Drawing.Point(62, 79);
            this.TextAuthPass.Name = ""TextAuthPass"";
            this.TextAuthPass.Size = new System.Drawing.Size(236, 21);
            this.TextAuthPass.TabIndex = 11;
            this.LabelAuthPass.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelAuthPass.AutoSize = true;
            this.LabelAuthPass.Location = new System.Drawing.Point(3, 94);
            this.LabelAuthPass.Name = ""LabelAuthPass"";
            this.LabelAuthPass.Size = new System.Drawing.Size(53, 12);
            this.LabelAuthPass.TabIndex = 8;
            this.LabelAuthPass.Text = ""Password"";
            this.TextAuthUser.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextAuthUser.Location = new System.Drawing.Point(62, 52);
            this.TextAuthUser.Name = ""TextAuthUser"";
            this.TextAuthUser.Size = new System.Drawing.Size(236, 21);
            this.TextAuthUser.TabIndex = 10;
            this.LabelAuthUser.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelAuthUser.AutoSize = true;
            this.LabelAuthUser.Location = new System.Drawing.Point(3, 56);
            this.LabelAuthUser.Name = ""LabelAuthUser"";
            this.LabelAuthUser.Size = new System.Drawing.Size(53, 12);
            this.LabelAuthUser.TabIndex = 5;
            this.LabelAuthUser.Text = ""Username"";
            this.checkShareOverLan.AutoSize = true;
            this.checkShareOverLan.Location = new System.Drawing.Point(62, 3);
            this.checkShareOverLan.Name = ""checkShareOverLan"";
            this.checkShareOverLan.Size = new System.Drawing.Size(156, 16);
            this.checkShareOverLan.TabIndex = 8;
            this.checkShareOverLan.Text = ""Allow Clients from LAN"";
            this.checkShareOverLan.UseVisualStyleBackColor = true;
            this.NumProxyPort.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.NumProxyPort.Location = new System.Drawing.Point(62, 25);
            this.NumProxyPort.Maximum = new decimal(new int[] {
            65535,
            0,
            0,
            0});
            this.NumProxyPort.Name = ""NumProxyPort"";
            this.NumProxyPort.Size = new System.Drawing.Size(236, 21);
            this.NumProxyPort.TabIndex = 9;
            this.ProxyPortLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.ProxyPortLabel.AutoSize = true;
            this.ProxyPortLabel.Location = new System.Drawing.Point(27, 29);
            this.ProxyPortLabel.Name = ""ProxyPortLabel"";
            this.ProxyPortLabel.Size = new System.Drawing.Size(29, 12);
            this.ProxyPortLabel.TabIndex = 3;
            this.ProxyPortLabel.Text = ""Port"";
            this.tableLayoutPanel10.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.tableLayoutPanel10.AutoSize = true;
            this.tableLayoutPanel10.ColumnCount = 1;
            this.tableLayoutPanel10.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel10.Controls.Add(this.tableLayoutPanel3, 0, 2);
            this.tableLayoutPanel10.Controls.Add(this.tableLayoutPanel5, 0, 1);
            this.tableLayoutPanel10.Location = new System.Drawing.Point(382, 258);
            this.tableLayoutPanel10.Name = ""tableLayoutPanel10"";
            this.tableLayoutPanel10.RowCount = 3;
            this.tableLayoutPanel10.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel10.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel10.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel10.Size = new System.Drawing.Size(186, 191);
            this.tableLayoutPanel10.TabIndex = 3;
            this.tableLayoutPanel3.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
            this.tableLayoutPanel3.AutoSize = true;
            this.tableLayoutPanel3.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel3.ColumnCount = 2;
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Absolute, 23F));
            this.tableLayoutPanel3.Controls.Add(this.MyCancelButton, 1, 0);
            this.tableLayoutPanel3.Controls.Add(this.OKButton, 0, 0);
            this.tableLayoutPanel3.Location = new System.Drawing.Point(3, 146);
            this.tableLayoutPanel3.Margin = new System.Windows.Forms.Padding(3, 3, 0, 3);
            this.tableLayoutPanel3.Name = ""tableLayoutPanel3"";
            this.tableLayoutPanel3.RowCount = 1;
            this.tableLayoutPanel3.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel3.Size = new System.Drawing.Size(183, 42);
            this.tableLayoutPanel3.TabIndex = 14;
            this.MyCancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.MyCancelButton.Dock = System.Windows.Forms.DockStyle.Right;
            this.MyCancelButton.Location = new System.Drawing.Point(96, 3);
            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(3, 3, 0, 0);
            this.MyCancelButton.Name = ""MyCancelButton"";
            this.MyCancelButton.Size = new System.Drawing.Size(87, 39);
            this.MyCancelButton.TabIndex = 22;
            this.MyCancelButton.Text = ""Cancel"";
            this.MyCancelButton.UseVisualStyleBackColor = true;
            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);
            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.OKButton.Dock = System.Windows.Forms.DockStyle.Right;
            this.OKButton.Location = new System.Drawing.Point(3, 3);
            this.OKButton.Margin = new System.Windows.Forms.Padding(3, 3, 3, 0);
            this.OKButton.Name = ""OKButton"";
            this.OKButton.Size = new System.Drawing.Size(87, 39);
            this.OKButton.TabIndex = 21;
            this.OKButton.Text = ""OK"";
            this.OKButton.UseVisualStyleBackColor = true;
            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);
            this.tableLayoutPanel5.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
            this.tableLayoutPanel5.AutoSize = true;
            this.tableLayoutPanel5.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel5.ColumnCount = 2;
            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel5.Controls.Add(this.ReconnectLabel, 0, 3);
            this.tableLayoutPanel5.Controls.Add(this.NumReconnect, 1, 3);
            this.tableLayoutPanel5.Controls.Add(this.TTLLabel, 0, 5);
            this.tableLayoutPanel5.Controls.Add(this.NumTTL, 1, 5);
            this.tableLayoutPanel5.Controls.Add(this.labelTimeout, 0, 4);
            this.tableLayoutPanel5.Controls.Add(this.NumTimeout, 1, 4);
            this.tableLayoutPanel5.Controls.Add(this.DNSText, 1, 1);
            this.tableLayoutPanel5.Controls.Add(this.buttonDefault, 1, 0);
            this.tableLayoutPanel5.Controls.Add(this.label2, 0, 1);
            this.tableLayoutPanel5.Location = new System.Drawing.Point(0, 0);
            this.tableLayoutPanel5.Margin = new System.Windows.Forms.Padding(0);
            this.tableLayoutPanel5.Name = ""tableLayoutPanel5"";
            this.tableLayoutPanel5.Padding = new System.Windows.Forms.Padding(3);
            this.tableLayoutPanel5.RowCount = 6;
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.Size = new System.Drawing.Size(186, 143);
            this.tableLayoutPanel5.TabIndex = 3;
            this.ReconnectLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.ReconnectLabel.AutoSize = true;
            this.ReconnectLabel.Location = new System.Drawing.Point(6, 66);
            this.ReconnectLabel.Name = ""ReconnectLabel"";
            this.ReconnectLabel.Size = new System.Drawing.Size(59, 12);
            this.ReconnectLabel.TabIndex = 3;
            this.ReconnectLabel.Text = ""Reconnect"";
            this.NumReconnect.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.NumReconnect.Location = new System.Drawing.Point(71, 62);
            this.NumReconnect.Maximum = new decimal(new int[] {
            20,
            0,
            0,
            0});
            this.NumReconnect.Name = ""NumReconnect"";
            this.NumReconnect.Size = new System.Drawing.Size(109, 21);
            this.NumReconnect.TabIndex = 18;
            this.TTLLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.TTLLabel.AutoSize = true;
            this.TTLLabel.Location = new System.Drawing.Point(42, 120);
            this.TTLLabel.Name = ""TTLLabel"";
            this.TTLLabel.Size = new System.Drawing.Size(23, 12);
            this.TTLLabel.TabIndex = 3;
            this.TTLLabel.Text = ""TTL"";
            this.NumTTL.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.NumTTL.Location = new System.Drawing.Point(71, 116);
            this.NumTTL.Maximum = new decimal(new int[] {
            600,
            0,
            0,
            0});
            this.NumTTL.Name = ""NumTTL"";
            this.NumTTL.Size = new System.Drawing.Size(109, 21);
            this.NumTTL.TabIndex = 20;
            this.labelTimeout.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelTimeout.AutoSize = true;
            this.labelTimeout.Location = new System.Drawing.Point(12, 93);
            this.labelTimeout.Name = ""labelTimeout"";
            this.labelTimeout.Size = new System.Drawing.Size(53, 12);
            this.labelTimeout.TabIndex = 3;
            this.labelTimeout.Text = "" Timeout"";
            this.NumTimeout.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.NumTimeout.Location = new System.Drawing.Point(71, 89);
            this.NumTimeout.Maximum = new decimal(new int[] {
            60,
            0,
            0,
            0});
            this.NumTimeout.Name = ""NumTimeout"";
            this.NumTimeout.Size = new System.Drawing.Size(109, 21);
            this.NumTimeout.TabIndex = 19;
            this.DNSText.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.DNSText.Location = new System.Drawing.Point(71, 35);
            this.DNSText.MaxLength = 0;
            this.DNSText.Name = ""DNSText"";
            this.DNSText.Size = new System.Drawing.Size(109, 21);
            this.DNSText.TabIndex = 17;
            this.DNSText.WordWrap = false;
            this.buttonDefault.Location = new System.Drawing.Point(71, 6);
            this.buttonDefault.Name = ""buttonDefault"";
            this.buttonDefault.Size = new System.Drawing.Size(109, 23);
            this.buttonDefault.TabIndex = 16;
            this.buttonDefault.Text = ""Set Default"";
            this.buttonDefault.UseVisualStyleBackColor = true;
            this.buttonDefault.Click += new System.EventHandler(this.buttonDefault_Click);
            this.label2.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(42, 39);
            this.label2.Name = ""label2"";
            this.label2.Size = new System.Drawing.Size(23, 12);
            this.label2.TabIndex = 3;
            this.label2.Text = ""DNS"";
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None;
            this.AutoSize = true;
            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.ClientSize = new System.Drawing.Size(728, 513);
            this.Controls.Add(this.tableLayoutPanel1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = ""SettingsForm"";
            this.Padding = new System.Windows.Forms.Padding(12, 13, 12, 13);
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""SettingsForm"";
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.SettingsForm_FormClosed);
            this.tableLayoutPanel1.ResumeLayout(false);
            this.tableLayoutPanel1.PerformLayout();
            this.tableLayoutPanel2.ResumeLayout(false);
            this.tableLayoutPanel2.PerformLayout();
            this.Socks5ProxyGroup.ResumeLayout(false);
            this.Socks5ProxyGroup.PerformLayout();
            this.tableLayoutPanel9.ResumeLayout(false);
            this.tableLayoutPanel9.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumS5Port)).EndInit();
            this.ListenGroup.ResumeLayout(false);
            this.ListenGroup.PerformLayout();
            this.tableLayoutPanel4.ResumeLayout(false);
            this.tableLayoutPanel4.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumProxyPort)).EndInit();
            this.tableLayoutPanel10.ResumeLayout(false);
            this.tableLayoutPanel10.PerformLayout();
            this.tableLayoutPanel3.ResumeLayout(false);
            this.tableLayoutPanel5.ResumeLayout(false);
            this.tableLayoutPanel5.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumReconnect)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumTTL)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumTimeout)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();
        }"
"<summary>
Required method for Designer support - do not modify
the contents of this method with the code editor.
</summary>","private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle2 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle3 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle4 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle5 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle6 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle7 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle8 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle9 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle10 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle11 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle12 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle13 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle14 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle15 = new System.Windows.Forms.DataGridViewCellStyle();
            this.ServerDataGrid = new Shadowsocks.View.ServerLogForm.DoubleBufferListView();
            this.timer = new System.Windows.Forms.Timer(this.components);
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.ID = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Group = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Server = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Enable = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.TotalConnect = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Connecting = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.AvgLatency = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.AvgDownSpeed = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.MaxDownSpeed = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.AvgUpSpeed = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.MaxUpSpeed = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Download = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Upload = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.DownloadRaw = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.ErrorPercent = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.ConnectError = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.ConnectTimeout = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.ConnectEmpty = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Continuous = new System.Windows.Forms.DataGridViewTextBoxColumn();
            ((System.ComponentModel.ISupportInitialize)(this.ServerDataGrid)).BeginInit();
            this.tableLayoutPanel1.SuspendLayout();
            this.SuspendLayout();
            this.ServerDataGrid.AllowUserToAddRows = false;
            this.ServerDataGrid.AllowUserToDeleteRows = false;
            this.ServerDataGrid.AllowUserToResizeRows = false;
            this.ServerDataGrid.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.ServerDataGrid.ColumnHeadersHeight = 46;
            this.ServerDataGrid.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.ID,
            this.Group,
            this.Server,
            this.Enable,
            this.TotalConnect,
            this.Connecting,
            this.AvgLatency,
            this.AvgDownSpeed,
            this.MaxDownSpeed,
            this.AvgUpSpeed,
            this.MaxUpSpeed,
            this.Download,
            this.Upload,
            this.DownloadRaw,
            this.ErrorPercent,
            this.ConnectError,
            this.ConnectTimeout,
            this.ConnectEmpty,
            this.Continuous});
            this.ServerDataGrid.Dock = System.Windows.Forms.DockStyle.Fill;
            this.ServerDataGrid.Location = new System.Drawing.Point(0, 0);
            this.ServerDataGrid.Margin = new System.Windows.Forms.Padding(0);
            this.ServerDataGrid.MinimumSize = new System.Drawing.Size(1, 1);
            this.ServerDataGrid.MultiSelect = false;
            this.ServerDataGrid.Name = ""ServerDataGrid"";
            this.ServerDataGrid.ReadOnly = true;
            this.ServerDataGrid.RowHeadersVisible = false;
            this.ServerDataGrid.RowTemplate.Height = 23;
            this.ServerDataGrid.Size = new System.Drawing.Size(132, 34);
            this.ServerDataGrid.TabIndex = 0;
            this.ServerDataGrid.CellClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.ServerDataGrid_CellClick);
            this.ServerDataGrid.CellDoubleClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.ServerDataGrid_CellDoubleClick);
            this.ServerDataGrid.ColumnWidthChanged += new System.Windows.Forms.DataGridViewColumnEventHandler(this.ServerDataGrid_ColumnWidthChanged);
            this.ServerDataGrid.SortCompare += new System.Windows.Forms.DataGridViewSortCompareEventHandler(this.ServerDataGrid_SortCompare);
            this.ServerDataGrid.MouseUp += new System.Windows.Forms.MouseEventHandler(this.ServerDataGrid_MouseUp);
            this.timer.Enabled = true;
            this.timer.Interval = 250;
            this.timer.Tick += new System.EventHandler(this.timer_Tick);
            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel1.ColumnCount = 1;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Controls.Add(this.ServerDataGrid, 0, 0);
            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tableLayoutPanel1.GrowStyle = System.Windows.Forms.TableLayoutPanelGrowStyle.FixedSize;
            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);
            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);
            this.tableLayoutPanel1.Name = ""tableLayoutPanel1"";
            this.tableLayoutPanel1.RowCount = 1;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.Size = new System.Drawing.Size(132, 22);
            this.tableLayoutPanel1.TabIndex = 1;
            dataGridViewCellStyle1.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.ID.DefaultCellStyle = dataGridViewCellStyle1;
            this.ID.HeaderText = ""ID"";
            this.ID.MinimumWidth = 2;
            this.ID.Name = ""ID"";
            this.ID.ReadOnly = true;
            this.ID.Width = 36;
            this.Group.HeaderText = ""Group"";
            this.Group.Name = ""Group"";
            this.Group.ReadOnly = true;
            this.Group.Width = 60;
            dataGridViewCellStyle2.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            this.Server.DefaultCellStyle = dataGridViewCellStyle2;
            this.Server.HeaderText = ""Server"";
            this.Server.MinimumWidth = 2;
            this.Server.Name = ""Server"";
            this.Server.ReadOnly = true;
            this.Server.Width = 88;
            this.Enable.HeaderText = ""Enable"";
            this.Enable.MinimumWidth = 8;
            this.Enable.Name = ""Enable"";
            this.Enable.ReadOnly = true;
            this.Enable.Resizable = System.Windows.Forms.DataGridViewTriState.True;
            this.Enable.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.Enable.Width = 24;
            this.TotalConnect.HeaderText = ""Total Connect"";
            this.TotalConnect.MinimumWidth = 2;
            this.TotalConnect.Name = ""TotalConnect"";
            this.TotalConnect.ReadOnly = true;
            this.TotalConnect.Visible = false;
            this.TotalConnect.Width = 48;
            dataGridViewCellStyle3.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.Connecting.DefaultCellStyle = dataGridViewCellStyle3;
            this.Connecting.HeaderText = ""Connecting"";
            this.Connecting.MinimumWidth = 16;
            this.Connecting.Name = ""Connecting"";
            this.Connecting.ReadOnly = true;
            this.Connecting.Width = 28;
            dataGridViewCellStyle4.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.AvgLatency.DefaultCellStyle = dataGridViewCellStyle4;
            this.AvgLatency.HeaderText = ""Latency"";
            this.AvgLatency.MinimumWidth = 36;
            this.AvgLatency.Name = ""AvgLatency"";
            this.AvgLatency.ReadOnly = true;
            this.AvgLatency.Width = 48;
            dataGridViewCellStyle5.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.AvgDownSpeed.DefaultCellStyle = dataGridViewCellStyle5;
            this.AvgDownSpeed.HeaderText = ""Avg DSpeed"";
            this.AvgDownSpeed.MinimumWidth = 60;
            this.AvgDownSpeed.Name = ""AvgDownSpeed"";
            this.AvgDownSpeed.ReadOnly = true;
            this.AvgDownSpeed.Width = 60;
            dataGridViewCellStyle6.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.MaxDownSpeed.DefaultCellStyle = dataGridViewCellStyle6;
            this.MaxDownSpeed.HeaderText = ""Max DSpeed"";
            this.MaxDownSpeed.MinimumWidth = 2;
            this.MaxDownSpeed.Name = ""MaxDownSpeed"";
            this.MaxDownSpeed.ReadOnly = true;
            this.MaxDownSpeed.Width = 60;
            dataGridViewCellStyle7.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.AvgUpSpeed.DefaultCellStyle = dataGridViewCellStyle7;
            this.AvgUpSpeed.HeaderText = ""Avg UpSpeed"";
            this.AvgUpSpeed.MinimumWidth = 60;
            this.AvgUpSpeed.Name = ""AvgUpSpeed"";
            this.AvgUpSpeed.ReadOnly = true;
            this.AvgUpSpeed.Width = 60;
            dataGridViewCellStyle8.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.MaxUpSpeed.DefaultCellStyle = dataGridViewCellStyle8;
            this.MaxUpSpeed.HeaderText = ""Max UpSpeed"";
            this.MaxUpSpeed.MinimumWidth = 2;
            this.MaxUpSpeed.Name = ""MaxUpSpeed"";
            this.MaxUpSpeed.ReadOnly = true;
            this.MaxUpSpeed.Width = 60;
            dataGridViewCellStyle9.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.Download.DefaultCellStyle = dataGridViewCellStyle9;
            this.Download.HeaderText = ""Dload"";
            this.Download.MinimumWidth = 2;
            this.Download.Name = ""Download"";
            this.Download.ReadOnly = true;
            this.Download.Width = 60;
            dataGridViewCellStyle10.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.Upload.DefaultCellStyle = dataGridViewCellStyle10;
            this.Upload.HeaderText = ""Upload"";
            this.Upload.MinimumWidth = 2;
            this.Upload.Name = ""Upload"";
            this.Upload.ReadOnly = true;
            this.Upload.Width = 60;
            dataGridViewCellStyle11.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.DownloadRaw.DefaultCellStyle = dataGridViewCellStyle11;
            this.DownloadRaw.HeaderText = ""DloadRaw"";
            this.DownloadRaw.MinimumWidth = 2;
            this.DownloadRaw.Name = ""DownloadRaw"";
            this.DownloadRaw.ReadOnly = true;
            this.DownloadRaw.Width = 60;
            this.ErrorPercent.HeaderText = ""Error Percent"";
            this.ErrorPercent.MinimumWidth = 2;
            this.ErrorPercent.Name = ""ErrorPercent"";
            this.ErrorPercent.ReadOnly = true;
            this.ErrorPercent.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.ErrorPercent.Visible = false;
            this.ErrorPercent.Width = 48;
            dataGridViewCellStyle12.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.ConnectError.DefaultCellStyle = dataGridViewCellStyle12;
            this.ConnectError.HeaderText = ""Error"";
            this.ConnectError.MinimumWidth = 2;
            this.ConnectError.Name = ""ConnectError"";
            this.ConnectError.ReadOnly = true;
            this.ConnectError.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.ConnectError.Width = 28;
            dataGridViewCellStyle13.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.ConnectTimeout.DefaultCellStyle = dataGridViewCellStyle13;
            this.ConnectTimeout.HeaderText = ""Timeout"";
            this.ConnectTimeout.MinimumWidth = 2;
            this.ConnectTimeout.Name = ""ConnectTimeout"";
            this.ConnectTimeout.ReadOnly = true;
            this.ConnectTimeout.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.ConnectTimeout.Width = 28;
            dataGridViewCellStyle14.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.ConnectEmpty.DefaultCellStyle = dataGridViewCellStyle14;
            this.ConnectEmpty.HeaderText = ""Empty Response"";
            this.ConnectEmpty.MinimumWidth = 2;
            this.ConnectEmpty.Name = ""ConnectEmpty"";
            this.ConnectEmpty.ReadOnly = true;
            this.ConnectEmpty.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.ConnectEmpty.Width = 28;
            dataGridViewCellStyle15.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.Continuous.DefaultCellStyle = dataGridViewCellStyle15;
            this.Continuous.HeaderText = ""Continuous"";
            this.Continuous.Name = ""Continuous"";
            this.Continuous.ReadOnly = true;
            this.Continuous.Visible = false;
            this.Continuous.Width = 28;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(132, 22);
            this.Controls.Add(this.tableLayoutPanel1);
            this.Margin = new System.Windows.Forms.Padding(2);
            this.Name = ""ServerLogForm"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""ServerLog"";
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ServerLogForm_FormClosed);
            this.ResizeEnd += new System.EventHandler(this.ServerLogForm_ResizeEnd);
            this.Move += new System.EventHandler(this.ServerLogForm_Move);
            ((System.ComponentModel.ISupportInitialize)(this.ServerDataGrid)).EndInit();
            this.tableLayoutPanel1.ResumeLayout(false);
            this.ResumeLayout(false);
        }"
"<summary>
Required method for Designer support - do not modify
the contents of this method with the code editor.
</summary>","private void InitializeComponent()
        {
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.checkBoxAutoUpdate = new System.Windows.Forms.CheckBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.textBoxURL = new System.Windows.Forms.TextBox();
            this.textBoxGroup = new System.Windows.Forms.TextBox();
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();
            this.buttonOK = new System.Windows.Forms.Button();
            this.buttonCancel = new System.Windows.Forms.Button();
            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();
            this.listServerSubscribe = new System.Windows.Forms.ListBox();
            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();
            this.buttonAdd = new System.Windows.Forms.Button();
            this.buttonDel = new System.Windows.Forms.Button();
            this.tableLayoutPanel1.SuspendLayout();
            this.tableLayoutPanel2.SuspendLayout();
            this.tableLayoutPanel3.SuspendLayout();
            this.tableLayoutPanel4.SuspendLayout();
            this.SuspendLayout();
            this.tableLayoutPanel1.AutoSize = true;
            this.tableLayoutPanel1.ColumnCount = 2;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);
            this.tableLayoutPanel1.Controls.Add(this.textBoxURL, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.textBoxGroup, 1, 1);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(352, 3);
            this.tableLayoutPanel1.Name = ""tableLayoutPanel1"";
            this.tableLayoutPanel1.RowCount = 3;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 20F));
            this.tableLayoutPanel1.Size = new System.Drawing.Size(263, 74);
            this.tableLayoutPanel1.TabIndex = 0;
            this.checkBoxAutoUpdate.AutoSize = true;
            this.checkBoxAutoUpdate.Location = new System.Drawing.Point(3, 35);
            this.checkBoxAutoUpdate.Name = ""checkBoxAutoUpdate"";
            this.checkBoxAutoUpdate.Size = new System.Drawing.Size(90, 16);
            this.checkBoxAutoUpdate.TabIndex = 3;
            this.checkBoxAutoUpdate.Text = ""Auto update"";
            this.checkBoxAutoUpdate.UseVisualStyleBackColor = true;
            this.label1.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(45, 7);
            this.label1.Name = ""label1"";
            this.label1.Size = new System.Drawing.Size(23, 12);
            this.label1.TabIndex = 0;
            this.label1.Text = ""URL"";
            this.label2.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(3, 34);
            this.label2.Name = ""label2"";
            this.label2.Size = new System.Drawing.Size(65, 12);
            this.label2.TabIndex = 0;
            this.label2.Text = ""Group name"";
            this.textBoxURL.Location = new System.Drawing.Point(74, 3);
            this.textBoxURL.Name = ""textBoxURL"";
            this.textBoxURL.Size = new System.Drawing.Size(186, 21);
            this.textBoxURL.TabIndex = 1;
            this.textBoxURL.TextChanged += new System.EventHandler(this.textBoxURL_TextChanged);
            this.textBoxGroup.Location = new System.Drawing.Point(74, 30);
            this.textBoxGroup.Name = ""textBoxGroup"";
            this.textBoxGroup.ReadOnly = true;
            this.textBoxGroup.Size = new System.Drawing.Size(186, 21);
            this.textBoxGroup.TabIndex = 1;
            this.tableLayoutPanel2.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
            this.tableLayoutPanel2.ColumnCount = 2;
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel2.Controls.Add(this.buttonOK, 0, 0);
            this.tableLayoutPanel2.Controls.Add(this.buttonCancel, 1, 0);
            this.tableLayoutPanel2.Location = new System.Drawing.Point(352, 264);
            this.tableLayoutPanel2.Name = ""tableLayoutPanel2"";
            this.tableLayoutPanel2.RowCount = 1;
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel2.Size = new System.Drawing.Size(291, 60);
            this.tableLayoutPanel2.TabIndex = 2;
            this.buttonOK.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.buttonOK.Location = new System.Drawing.Point(21, 10);
            this.buttonOK.Name = ""buttonOK"";
            this.buttonOK.Size = new System.Drawing.Size(102, 39);
            this.buttonOK.TabIndex = 0;
            this.buttonOK.Text = ""OK"";
            this.buttonOK.UseVisualStyleBackColor = true;
            this.buttonOK.Click += new System.EventHandler(this.buttonOK_Click);
            this.buttonCancel.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.buttonCancel.Location = new System.Drawing.Point(167, 10);
            this.buttonCancel.Name = ""buttonCancel"";
            this.buttonCancel.Size = new System.Drawing.Size(102, 39);
            this.buttonCancel.TabIndex = 0;
            this.buttonCancel.Text = ""Cancel"";
            this.buttonCancel.UseVisualStyleBackColor = true;
            this.buttonCancel.Click += new System.EventHandler(this.buttonCancel_Click);
            this.tableLayoutPanel3.ColumnCount = 2;
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 54.17957F));
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 45.82043F));
            this.tableLayoutPanel3.Controls.Add(this.tableLayoutPanel1, 1, 0);
            this.tableLayoutPanel3.Controls.Add(this.tableLayoutPanel2, 1, 1);
            this.tableLayoutPanel3.Controls.Add(this.listServerSubscribe, 0, 0);
            this.tableLayoutPanel3.Controls.Add(this.tableLayoutPanel4, 0, 1);
            this.tableLayoutPanel3.Location = new System.Drawing.Point(12, 12);
            this.tableLayoutPanel3.Name = ""tableLayoutPanel3"";
            this.tableLayoutPanel3.RowCount = 2;
            this.tableLayoutPanel3.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 78.59327F));
            this.tableLayoutPanel3.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 21.40673F));
            this.tableLayoutPanel3.Size = new System.Drawing.Size(646, 327);
            this.tableLayoutPanel3.TabIndex = 1;
            this.listServerSubscribe.FormattingEnabled = true;
            this.listServerSubscribe.ItemHeight = 12;
            this.listServerSubscribe.Location = new System.Drawing.Point(3, 3);
            this.listServerSubscribe.Name = ""listServerSubscribe"";
            this.listServerSubscribe.Size = new System.Drawing.Size(343, 244);
            this.listServerSubscribe.TabIndex = 4;
            this.listServerSubscribe.SelectedIndexChanged += new System.EventHandler(this.listServerSubscribe_SelectedIndexChanged);
            this.tableLayoutPanel4.ColumnCount = 2;
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.Controls.Add(this.checkBoxAutoUpdate, 0, 1);
            this.tableLayoutPanel4.Controls.Add(this.buttonAdd, 0, 0);
            this.tableLayoutPanel4.Controls.Add(this.buttonDel, 1, 0);
            this.tableLayoutPanel4.Location = new System.Drawing.Point(3, 259);
            this.tableLayoutPanel4.Name = ""tableLayoutPanel4"";
            this.tableLayoutPanel4.RowCount = 2;
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.Size = new System.Drawing.Size(343, 65);
            this.tableLayoutPanel4.TabIndex = 5;
            this.buttonAdd.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.buttonAdd.Location = new System.Drawing.Point(93, 4);
            this.buttonAdd.Name = ""buttonAdd"";
            this.buttonAdd.Size = new System.Drawing.Size(75, 23);
            this.buttonAdd.TabIndex = 0;
            this.buttonAdd.Text = ""Add"";
            this.buttonAdd.UseVisualStyleBackColor = true;
            this.buttonAdd.Click += new System.EventHandler(this.buttonAdd_Click);
            this.buttonDel.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.buttonDel.Location = new System.Drawing.Point(174, 4);
            this.buttonDel.Name = ""buttonDel"";
            this.buttonDel.Size = new System.Drawing.Size(75, 23);
            this.buttonDel.TabIndex = 1;
            this.buttonDel.Text = ""Delete"";
            this.buttonDel.UseVisualStyleBackColor = true;
            this.buttonDel.Click += new System.EventHandler(this.buttonDel_Click);
            this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
            this.AutoSize = true;
            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.ClientSize = new System.Drawing.Size(681, 364);
            this.Controls.Add(this.tableLayoutPanel3);
            this.Name = ""SubscribeForm"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""Subscribe Settings"";
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.SubscribeForm_FormClosed);
            this.tableLayoutPanel1.ResumeLayout(false);
            this.tableLayoutPanel1.PerformLayout();
            this.tableLayoutPanel2.ResumeLayout(false);
            this.tableLayoutPanel3.ResumeLayout(false);
            this.tableLayoutPanel3.PerformLayout();
            this.tableLayoutPanel4.ResumeLayout(false);
            this.tableLayoutPanel4.PerformLayout();
            this.ResumeLayout(false);
        }"
"<summary>
Required method for Designer support - do not modify
the contents of this method with the code editor.
</summary>","private void InitializeComponent()
        {
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.listPorts = new System.Windows.Forms.ListBox();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();
            this.labelType = new System.Windows.Forms.Label();
            this.labelID = new System.Windows.Forms.Label();
            this.labelAddr = new System.Windows.Forms.Label();
            this.labelPort = new System.Windows.Forms.Label();
            this.checkEnable = new System.Windows.Forms.CheckBox();
            this.textAddr = new System.Windows.Forms.TextBox();
            this.NumTargetPort = new System.Windows.Forms.NumericUpDown();
            this.comboBoxType = new System.Windows.Forms.ComboBox();
            this.comboServers = new System.Windows.Forms.ComboBox();
            this.labelLocal = new System.Windows.Forms.Label();
            this.NumLocalPort = new System.Windows.Forms.NumericUpDown();
            this.label1 = new System.Windows.Forms.Label();
            this.textRemarks = new System.Windows.Forms.TextBox();
            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();
            this.OKButton = new System.Windows.Forms.Button();
            this.MyCancelButton = new System.Windows.Forms.Button();
            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();
            this.Add = new System.Windows.Forms.Button();
            this.Del = new System.Windows.Forms.Button();
            this.tableLayoutPanel1.SuspendLayout();
            this.groupBox1.SuspendLayout();
            this.tableLayoutPanel2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumTargetPort)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumLocalPort)).BeginInit();
            this.tableLayoutPanel3.SuspendLayout();
            this.tableLayoutPanel4.SuspendLayout();
            this.SuspendLayout();
            this.tableLayoutPanel1.ColumnCount = 2;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Controls.Add(this.listPorts, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.groupBox1, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel3, 1, 1);
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel4, 0, 1);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(13, 13);
            this.tableLayoutPanel1.Name = ""tableLayoutPanel1"";
            this.tableLayoutPanel1.RowCount = 2;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.Size = new System.Drawing.Size(684, 325);
            this.tableLayoutPanel1.TabIndex = 0;
            this.listPorts.FormattingEnabled = true;
            this.listPorts.ItemHeight = 12;
            this.listPorts.Location = new System.Drawing.Point(3, 3);
            this.listPorts.Name = ""listPorts"";
            this.listPorts.Size = new System.Drawing.Size(144, 244);
            this.listPorts.TabIndex = 0;
            this.listPorts.SelectedIndexChanged += new System.EventHandler(this.listPorts_SelectedIndexChanged);
            this.groupBox1.Controls.Add(this.tableLayoutPanel2);
            this.groupBox1.Location = new System.Drawing.Point(153, 3);
            this.groupBox1.Name = ""groupBox1"";
            this.groupBox1.Size = new System.Drawing.Size(531, 255);
            this.groupBox1.TabIndex = 2;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = ""Map Setting"";
            this.tableLayoutPanel2.ColumnCount = 3;
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel2.Controls.Add(this.labelType, 0, 1);
            this.tableLayoutPanel2.Controls.Add(this.labelID, 0, 2);
            this.tableLayoutPanel2.Controls.Add(this.labelAddr, 0, 4);
            this.tableLayoutPanel2.Controls.Add(this.labelPort, 0, 5);
            this.tableLayoutPanel2.Controls.Add(this.checkEnable, 1, 0);
            this.tableLayoutPanel2.Controls.Add(this.textAddr, 1, 4);
            this.tableLayoutPanel2.Controls.Add(this.NumTargetPort, 1, 5);
            this.tableLayoutPanel2.Controls.Add(this.comboBoxType, 1, 1);
            this.tableLayoutPanel2.Controls.Add(this.comboServers, 1, 2);
            this.tableLayoutPanel2.Controls.Add(this.labelLocal, 0, 3);
            this.tableLayoutPanel2.Controls.Add(this.NumLocalPort, 1, 3);
            this.tableLayoutPanel2.Controls.Add(this.label1, 0, 6);
            this.tableLayoutPanel2.Controls.Add(this.textRemarks, 1, 6);
            this.tableLayoutPanel2.Location = new System.Drawing.Point(7, 21);
            this.tableLayoutPanel2.Name = ""tableLayoutPanel2"";
            this.tableLayoutPanel2.RowCount = 8;
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.Size = new System.Drawing.Size(515, 223);
            this.tableLayoutPanel2.TabIndex = 0;
            this.labelType.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelType.AutoSize = true;
            this.labelType.Location = new System.Drawing.Point(45, 29);
            this.labelType.Name = ""labelType"";
            this.labelType.Size = new System.Drawing.Size(29, 12);
            this.labelType.TabIndex = 0;
            this.labelType.Text = ""Type"";
            this.labelID.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelID.AutoSize = true;
            this.labelID.Location = new System.Drawing.Point(15, 55);
            this.labelID.Name = ""labelID"";
            this.labelID.Size = new System.Drawing.Size(59, 12);
            this.labelID.TabIndex = 0;
            this.labelID.Text = ""Server ID"";
            this.labelAddr.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelAddr.AutoSize = true;
            this.labelAddr.Location = new System.Drawing.Point(3, 108);
            this.labelAddr.Name = ""labelAddr"";
            this.labelAddr.Size = new System.Drawing.Size(71, 12);
            this.labelAddr.TabIndex = 0;
            this.labelAddr.Text = ""Target Addr"";
            this.labelPort.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelPort.AutoSize = true;
            this.labelPort.Location = new System.Drawing.Point(3, 135);
            this.labelPort.Name = ""labelPort"";
            this.labelPort.Size = new System.Drawing.Size(71, 12);
            this.labelPort.TabIndex = 0;
            this.labelPort.Text = ""Target Port"";
            this.checkEnable.AutoSize = true;
            this.checkEnable.Location = new System.Drawing.Point(80, 3);
            this.checkEnable.Name = ""checkEnable"";
            this.checkEnable.Size = new System.Drawing.Size(60, 16);
            this.checkEnable.TabIndex = 3;
            this.checkEnable.Text = ""Enable"";
            this.checkEnable.UseVisualStyleBackColor = true;
            this.textAddr.Location = new System.Drawing.Point(80, 104);
            this.textAddr.Name = ""textAddr"";
            this.textAddr.Size = new System.Drawing.Size(403, 21);
            this.textAddr.TabIndex = 7;
            this.NumTargetPort.Location = new System.Drawing.Point(80, 131);
            this.NumTargetPort.Maximum = new decimal(new int[] {
            65535,
            0,
            0,
            0});
            this.NumTargetPort.Name = ""NumTargetPort"";
            this.NumTargetPort.Size = new System.Drawing.Size(403, 21);
            this.NumTargetPort.TabIndex = 8;
            this.comboBoxType.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.comboBoxType.FormattingEnabled = true;
            this.comboBoxType.Items.AddRange(new object[] {
            ""Port Forward"",
            ""Force Proxy"",
            ""Proxy With Rule""});
            this.comboBoxType.Location = new System.Drawing.Point(80, 25);
            this.comboBoxType.Name = ""comboBoxType"";
            this.comboBoxType.Size = new System.Drawing.Size(403, 20);
            this.comboBoxType.TabIndex = 4;
            this.comboBoxType.SelectedIndexChanged += new System.EventHandler(this.comboBoxType_SelectedIndexChanged);
            this.comboServers.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.comboServers.FormattingEnabled = true;
            this.comboServers.Location = new System.Drawing.Point(80, 51);
            this.comboServers.Name = ""comboServers"";
            this.comboServers.Size = new System.Drawing.Size(403, 20);
            this.comboServers.TabIndex = 5;
            this.labelLocal.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelLocal.AutoSize = true;
            this.labelLocal.Location = new System.Drawing.Point(9, 81);
            this.labelLocal.Name = ""labelLocal"";
            this.labelLocal.Size = new System.Drawing.Size(65, 12);
            this.labelLocal.TabIndex = 0;
            this.labelLocal.Text = ""Local Port"";
            this.NumLocalPort.Location = new System.Drawing.Point(80, 77);
            this.NumLocalPort.Maximum = new decimal(new int[] {
            65535,
            0,
            0,
            0});
            this.NumLocalPort.Name = ""NumLocalPort"";
            this.NumLocalPort.Size = new System.Drawing.Size(403, 21);
            this.NumLocalPort.TabIndex = 6;
            this.label1.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(27, 162);
            this.label1.Name = ""label1"";
            this.label1.Size = new System.Drawing.Size(47, 12);
            this.label1.TabIndex = 0;
            this.label1.Text = ""Remarks"";
            this.textRemarks.Location = new System.Drawing.Point(80, 158);
            this.textRemarks.Name = ""textRemarks"";
            this.textRemarks.Size = new System.Drawing.Size(403, 21);
            this.textRemarks.TabIndex = 9;
            this.tableLayoutPanel3.ColumnCount = 2;
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel3.Controls.Add(this.OKButton, 0, 0);
            this.tableLayoutPanel3.Controls.Add(this.MyCancelButton, 1, 0);
            this.tableLayoutPanel3.Location = new System.Drawing.Point(153, 264);
            this.tableLayoutPanel3.Name = ""tableLayoutPanel3"";
            this.tableLayoutPanel3.RowCount = 1;
            this.tableLayoutPanel3.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel3.Size = new System.Drawing.Size(490, 54);
            this.tableLayoutPanel3.TabIndex = 3;
            this.OKButton.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.OKButton.Location = new System.Drawing.Point(46, 3);
            this.OKButton.Name = ""OKButton"";
            this.OKButton.Size = new System.Drawing.Size(152, 35);
            this.OKButton.TabIndex = 10;
            this.OKButton.Text = ""OK"";
            this.OKButton.UseVisualStyleBackColor = true;
            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);
            this.MyCancelButton.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.MyCancelButton.Location = new System.Drawing.Point(291, 3);
            this.MyCancelButton.Name = ""MyCancelButton"";
            this.MyCancelButton.Size = new System.Drawing.Size(152, 35);
            this.MyCancelButton.TabIndex = 11;
            this.MyCancelButton.Text = ""Cancel"";
            this.MyCancelButton.UseVisualStyleBackColor = true;
            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);
            this.tableLayoutPanel4.ColumnCount = 1;
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel4.Controls.Add(this.Add, 0, 0);
            this.tableLayoutPanel4.Controls.Add(this.Del, 0, 1);
            this.tableLayoutPanel4.Location = new System.Drawing.Point(3, 264);
            this.tableLayoutPanel4.Name = ""tableLayoutPanel4"";
            this.tableLayoutPanel4.RowCount = 2;
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.Size = new System.Drawing.Size(144, 54);
            this.tableLayoutPanel4.TabIndex = 1;
            this.Add.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.Add.Location = new System.Drawing.Point(22, 3);
            this.Add.Name = ""Add"";
            this.Add.Size = new System.Drawing.Size(100, 21);
            this.Add.TabIndex = 1;
            this.Add.Text = ""&Add"";
            this.Add.UseVisualStyleBackColor = true;
            this.Add.Click += new System.EventHandler(this.Add_Click);
            this.Del.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.Del.Location = new System.Drawing.Point(22, 30);
            this.Del.Name = ""Del"";
            this.Del.Size = new System.Drawing.Size(100, 21);
            this.Del.TabIndex = 2;
            this.Del.Text = ""&Delete"";
            this.Del.UseVisualStyleBackColor = true;
            this.Del.Click += new System.EventHandler(this.Del_Click);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None;
            this.AutoSize = true;
            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.ClientSize = new System.Drawing.Size(727, 489);
            this.Controls.Add(this.tableLayoutPanel1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            this.Name = ""PortSettingsForm"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""Port Settings"";
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.PortMapForm_FormClosed);
            this.tableLayoutPanel1.ResumeLayout(false);
            this.groupBox1.ResumeLayout(false);
            this.tableLayoutPanel2.ResumeLayout(false);
            this.tableLayoutPanel2.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumTargetPort)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumLocalPort)).EndInit();
            this.tableLayoutPanel3.ResumeLayout(false);
            this.tableLayoutPanel4.ResumeLayout(false);
            this.ResumeLayout(false);
        }"
"<summary>
Required method for Designer support - do not modify
the contents of this method with the code editor.
</summary>","private void InitializeComponent()
        {
            this.textPassword = new System.Windows.Forms.TextBox();
            this.buttonOK = new System.Windows.Forms.Button();
            this.label_info = new System.Windows.Forms.Label();
            this.SuspendLayout();
            this.textPassword.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.textPassword.Location = new System.Drawing.Point(41, 44);
            this.textPassword.Name = ""textPassword"";
            this.textPassword.Size = new System.Drawing.Size(330, 21);
            this.textPassword.TabIndex = 0;
            this.textPassword.UseSystemPasswordChar = true;
            this.buttonOK.Location = new System.Drawing.Point(131, 76);
            this.buttonOK.Name = ""buttonOK"";
            this.buttonOK.Size = new System.Drawing.Size(151, 28);
            this.buttonOK.TabIndex = 1;
            this.buttonOK.Text = ""OK"";
            this.buttonOK.UseVisualStyleBackColor = true;
            this.buttonOK.Click += new System.EventHandler(this.buttonOK_Click);
            this.label_info.AutoSize = true;
            this.label_info.Location = new System.Drawing.Point(24, 26);
            this.label_info.Name = ""label_info"";
            this.label_info.Size = new System.Drawing.Size(350, 15);
            this.label_info.TabIndex = 2;
            this.label_info.Text = ""Parse gui-config.json error, maybe require password to decrypt"";
            this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
            this.ClientSize = new System.Drawing.Size(412, 119);
            this.Controls.Add(this.label_info);
            this.Controls.Add(this.buttonOK);
            this.Controls.Add(this.textPassword);
            this.Font = new System.Drawing.Font(""Arial"", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.KeyPreview = true;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = ""InputPassword"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""InputPassword"";
            this.TopMost = true;
            this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.InputPassword_KeyDown);
            this.ResumeLayout(false);
            this.PerformLayout();
        }"
"<summary>
Required method for Designer support - do not modify
the contents of this method with the code editor.
</summary>","private void InitializeComponent()
        {
            this.buttonOK = new System.Windows.Forms.Button();
            this.textOld = new System.Windows.Forms.TextBox();
            this.textPassword = new System.Windows.Forms.TextBox();
            this.textPassword2 = new System.Windows.Forms.TextBox();
            this.SuspendLayout();
            this.buttonOK.Location = new System.Drawing.Point(107, 132);
            this.buttonOK.Name = ""buttonOK"";
            this.buttonOK.Size = new System.Drawing.Size(75, 23);
            this.buttonOK.TabIndex = 3;
            this.buttonOK.Text = ""OK"";
            this.buttonOK.UseVisualStyleBackColor = true;
            this.buttonOK.Click += new System.EventHandler(this.buttonOK_Click);
            this.textOld.Location = new System.Drawing.Point(28, 13);
            this.textOld.Name = ""textOld"";
            this.textOld.Size = new System.Drawing.Size(233, 21);
            this.textOld.TabIndex = 0;
            this.textOld.UseSystemPasswordChar = true;
            this.textPassword.Location = new System.Drawing.Point(28, 60);
            this.textPassword.Name = ""textPassword"";
            this.textPassword.Size = new System.Drawing.Size(233, 21);
            this.textPassword.TabIndex = 1;
            this.textPassword.UseSystemPasswordChar = true;
            this.textPassword2.Location = new System.Drawing.Point(28, 87);
            this.textPassword2.Name = ""textPassword2"";
            this.textPassword2.Size = new System.Drawing.Size(233, 21);
            this.textPassword2.TabIndex = 2;
            this.textPassword2.UseSystemPasswordChar = true;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(284, 167);
            this.Controls.Add(this.textPassword2);
            this.Controls.Add(this.textPassword);
            this.Controls.Add(this.textOld);
            this.Controls.Add(this.buttonOK);
            this.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.KeyPreview = true;
            this.Name = ""ResetPassword"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""ResetPassword"";
            this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.ResetPassword_KeyDown);
            this.ResumeLayout(false);
            this.PerformLayout();
        }"
"<summary>
Required method for Designer support - do not modify
the contents of this method with the code editor.
</summary>","private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.logMenu = new System.Windows.Forms.MenuStrip();
            this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.clearLogToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.showInExplorerToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.closeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.viewToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.fontToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.wrapTextToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.alwaysOnTopToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.logTextBox = new System.Windows.Forms.TextBox();
            this.refreshTimer = new System.Windows.Forms.Timer(this.components);
            this.logMenu.SuspendLayout();
            this.SuspendLayout();
            this.logMenu.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fileToolStripMenuItem,
            this.viewToolStripMenuItem});
            this.logMenu.Location = new System.Drawing.Point(0, 0);
            this.logMenu.Name = ""logMenu"";
            this.logMenu.Size = new System.Drawing.Size(986, 25);
            this.logMenu.TabIndex = 0;
            this.logMenu.Text = ""menuStrip1"";
            this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.clearLogToolStripMenuItem,
            this.showInExplorerToolStripMenuItem,
            this.toolStripSeparator1,
            this.closeToolStripMenuItem});
            this.fileToolStripMenuItem.Name = ""fileToolStripMenuItem"";
            this.fileToolStripMenuItem.Size = new System.Drawing.Size(39, 21);
            this.fileToolStripMenuItem.Text = ""&File"";
            this.clearLogToolStripMenuItem.Name = ""clearLogToolStripMenuItem"";
            this.clearLogToolStripMenuItem.Size = new System.Drawing.Size(174, 22);
            this.clearLogToolStripMenuItem.Text = ""Clear &log"";
            this.clearLogToolStripMenuItem.Click += new System.EventHandler(this.clearLogToolStripMenuItem_Click);
            this.showInExplorerToolStripMenuItem.Name = ""showInExplorerToolStripMenuItem"";
            this.showInExplorerToolStripMenuItem.Size = new System.Drawing.Size(174, 22);
            this.showInExplorerToolStripMenuItem.Text = ""Show in &Explorer"";
            this.showInExplorerToolStripMenuItem.Click += new System.EventHandler(this.showInExplorerToolStripMenuItem_Click);
            this.toolStripSeparator1.Name = ""toolStripSeparator1"";
            this.toolStripSeparator1.Size = new System.Drawing.Size(171, 6);
            this.closeToolStripMenuItem.Name = ""closeToolStripMenuItem"";
            this.closeToolStripMenuItem.Size = new System.Drawing.Size(174, 22);
            this.closeToolStripMenuItem.Text = ""&Close"";
            this.closeToolStripMenuItem.Click += new System.EventHandler(this.closeToolStripMenuItem_Click);
            this.viewToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fontToolStripMenuItem,
            this.wrapTextToolStripMenuItem,
            this.alwaysOnTopToolStripMenuItem});
            this.viewToolStripMenuItem.Name = ""viewToolStripMenuItem"";
            this.viewToolStripMenuItem.Size = new System.Drawing.Size(47, 21);
            this.viewToolStripMenuItem.Text = ""&View"";
            this.fontToolStripMenuItem.Name = ""fontToolStripMenuItem"";
            this.fontToolStripMenuItem.Size = new System.Drawing.Size(158, 22);
            this.fontToolStripMenuItem.Text = ""&Font"";
            this.fontToolStripMenuItem.Click += new System.EventHandler(this.fontToolStripMenuItem_Click);
            this.wrapTextToolStripMenuItem.Name = ""wrapTextToolStripMenuItem"";
            this.wrapTextToolStripMenuItem.Size = new System.Drawing.Size(158, 22);
            this.wrapTextToolStripMenuItem.Text = ""&Wrap text"";
            this.wrapTextToolStripMenuItem.CheckedChanged += new System.EventHandler(this.wrapTextToolStripMenuItem_CheckedChanged);
            this.wrapTextToolStripMenuItem.Click += new System.EventHandler(this.wrapTextToolStripMenuItem_Click);
            this.alwaysOnTopToolStripMenuItem.Name = ""alwaysOnTopToolStripMenuItem"";
            this.alwaysOnTopToolStripMenuItem.Size = new System.Drawing.Size(158, 22);
            this.alwaysOnTopToolStripMenuItem.Text = ""&Always on top"";
            this.alwaysOnTopToolStripMenuItem.CheckedChanged += new System.EventHandler(this.alwaysOnTopToolStripMenuItem_CheckedChanged);
            this.alwaysOnTopToolStripMenuItem.Click += new System.EventHandler(this.alwaysOnTopToolStripMenuItem_Click);
            this.logTextBox.BackColor = System.Drawing.Color.Black;
            this.logTextBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.logTextBox.Font = new System.Drawing.Font(""Courier New"", 10.5F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.logTextBox.ForeColor = System.Drawing.Color.White;
            this.logTextBox.Location = new System.Drawing.Point(0, 25);
            this.logTextBox.MaxLength = 2147483647;
            this.logTextBox.Multiline = true;
            this.logTextBox.Name = ""logTextBox"";
            this.logTextBox.ReadOnly = true;
            this.logTextBox.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.logTextBox.Size = new System.Drawing.Size(986, 411);
            this.logTextBox.TabIndex = 1;
            this.logTextBox.WordWrap = false;
            this.refreshTimer.Enabled = true;
            this.refreshTimer.Tick += new System.EventHandler(this.refreshTimer_Tick);
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(986, 436);
            this.Controls.Add(this.logTextBox);
            this.Controls.Add(this.logMenu);
            this.Name = ""LogForm"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""Log Viewer"";
            this.Load += new System.EventHandler(this.LogForm_Load);
            this.Shown += new System.EventHandler(this.LogForm_Shown);
            this.logMenu.ResumeLayout(false);
            this.logMenu.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();
        }"
"<summary>
Required method for Designer support - do not modify
the contents of this method with the code editor.
</summary>","private void InitializeComponent()
        {
            this.textBox = new System.Windows.Forms.TextBox();
            this.PictureQRcode = new System.Windows.Forms.PictureBox();
            ((System.ComponentModel.ISupportInitialize)(this.PictureQRcode)).BeginInit();
            this.SuspendLayout();
            this.textBox.Dock = System.Windows.Forms.DockStyle.Top;
            this.textBox.Font = new System.Drawing.Font(""宋体"", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134)));
            this.textBox.Location = new System.Drawing.Point(0, 0);
            this.textBox.Multiline = true;
            this.textBox.Name = ""textBox"";
            this.textBox.Size = new System.Drawing.Size(350, 63);
            this.textBox.TabIndex = 0;
            this.textBox.TextChanged += new System.EventHandler(this.textBox_TextChanged);
            this.textBox.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.textBox_KeyPress);
            this.PictureQRcode.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.PictureQRcode.Location = new System.Drawing.Point(0, 68);
            this.PictureQRcode.Name = ""PictureQRcode"";
            this.PictureQRcode.Size = new System.Drawing.Size(350, 350);
            this.PictureQRcode.TabIndex = 1;
            this.PictureQRcode.TabStop = false;
            this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
            this.ClientSize = new System.Drawing.Size(350, 418);
            this.Controls.Add(this.PictureQRcode);
            this.Controls.Add(this.textBox);
            this.Font = new System.Drawing.Font(""宋体"", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134)));
            this.Name = ""ShowTextForm"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""ShowTextForm"";
            this.TopMost = true;
            this.SizeChanged += new System.EventHandler(this.ShowTextForm_SizeChanged);
            ((System.ComponentModel.ISupportInitialize)(this.PictureQRcode)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();
        }"
"<summary>
Session 操作类
1、GetSession(string name)根据session名获取session对象
2、SetSession(string name, object val)设置session
</summary>","public static object GetSession(string name)
        {
            return HttpContext.Current.Session[name];
        }"
"<summary>
创建一个IPEndPoint对象
</summary>","public static IPEndPoint CreateIPEndPoint(string ip, int port)
        {
            IPAddress ipAddress = StringToIPAddress(ip);
            return new IPEndPoint(ipAddress, port);
        }"
"<summary>
Utility methods related to CLR Types for SQL Server
</summary>","private static extern IntPtr LoadLibrary(string libname);
        public static void LoadNativeAssemblies(string rootApplicationPath)
        {
            var nativeBinaryPath = IntPtr.Size > 4
                ? Path.Combine(rootApplicationPath, @""SqlServerTypes\x64\"")
                : Path.Combine(rootApplicationPath, @""SqlServerTypes\x86\"");
            LoadNativeAssembly(nativeBinaryPath, ""msvcr120.dll"");
            LoadNativeAssembly(nativeBinaryPath, ""SqlServerSpatial140.dll"");
        }"
"<summary>
切换到主库，此方法适用于SQL自动查询服务端版本用
系统自动会使用 select cast(serverproperty('EngineEdition') as int) 来查询
</summary>","public static void UpdateToMaster(DbConnection conn)
        {
        }"
"<summary>
Execute a SqlCommand that returns a resultset against the database specified in the connection string
using the provided parameters.
</summary>","public static SqlDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            try
            {
                SqlConnection conn = new SqlConnection(connectionString);
                    PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                    SqlDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                    cmd.Parameters.Clear();
                    return rdr;
            }
            catch
            {
                throw;
            }
        }"
"<summary>
Execute a SqlCommand that returns the first column of the first record against the database specified in the connection string
using the provided parameters.
</summary>","public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"<summary>
Execute a SqlCommand that returns the first column of the first record against an existing database connection
using the provided parameters.
</summary>","public static object ExecuteScalar(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
add parameter array to the cache
</summary>","public static void CacheParameters(string cacheKey, params SqlParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"<summary>
Retrieve cached parameters
</summary>","public static SqlParameter[] GetCachedParameters(string cacheKey)
        {
            SqlParameter[] cachedParms = (SqlParameter[])parmCache[cacheKey];
            if (cachedParms"
"<summary>
Generates the check code with unique number.
</summary>","public string GenerateCheckCodeNum(int codeCount)
        {
            codeCount = codeCount > 10 ? 10 :codeCount;   
            int[] arrInt = {0,1,2,3,4,5,6,7,8,9};
		    arrInt = arrInt.OrderBy(c => Guid.NewGuid()).ToArray<int>();
            string str = string.Empty;
            for (int i = 0; i < codeCount; i++)
            {
                str += arrInt[i];
            }
            return str;
        }"
"<summary>
Generates the check code with number and char
</summary>","public string GenerateCheckCode(int CodeCount)
        {
            char[] MixedList = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I','J', 'K', 'L', 'M', 'N','O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' }; 
			return GetRandomCode(MixedList, CodeCount);
		}"
"<summary>
Gets the random code.
</summary>","private string GetRandomCode(char[] CharList, int CodeLength)
        {
			string result = string.Empty;
			for (int i = 0; i < CodeLength; i++)
			{
				int rnd = Random.Next(0, CharList.Length);
				result += CharList[rnd];
			}
			return result;
        }"
"<summary>
创建一个IPEndPoint对象
</summary>","public static IPEndPoint CreateIPEndPoint(string ip, int port)
        {
            IPAddress ipAddress = StringToIPAddress(ip);
            return new IPEndPoint(ipAddress, port);
        }"
"<summary>
DataTable转换为Json
</summary>","public static string ToJson(DataTable dt, string jsonName)
        {
            StringBuilder Json = new StringBuilder();
            if (string.IsNullOrEmpty(jsonName)) jsonName = dt.TableName;
            Json.Append(""{\"""" + jsonName + ""\"":["");
            if (dt.Rows.Count > 0)
            {
                for (int i = 0; i < dt.Rows.Count; i++)
                {
                    Json.Append(""{"");
                    for (int j = 0; j < dt.Columns.Count; j++)
                    {
                        Type type = dt.Rows[i][j].GetType();
                        Json.Append(""\"""" + dt.Columns[j].ColumnName.ToString() + ""\"":"" + StringFormat(dt.Rows[i][j].ToString(), type));
                        if (j < dt.Columns.Count - 1)
                        {
                            Json.Append("","");
                        }
                    }
                    Json.Append(""}"");
                    if (i < dt.Rows.Count - 1)
                    {
                        Json.Append("","");
                    }
                }
            }
            Json.Append(""]}"");
            return Json.ToString();
        }"
"<summary>
DataReader转换为Json
</summary>","public static string ToJson(DbDataReader dataReader)
        {
            StringBuilder jsonString = new StringBuilder();
            jsonString.Append(""["");
            while (dataReader.Read())
            {
                jsonString.Append(""{"");
                for (int i = 0; i < dataReader.FieldCount; i++)
                {
                    Type type = dataReader.GetFieldType(i);
                    string strKey = dataReader.GetName(i);
                    string strValue = dataReader[i].ToString();
                    jsonString.Append(""\"""" + strKey + ""\"":"");
                    strValue = StringFormat(strValue, type);
                    if (i < dataReader.FieldCount - 1)
                    {
                        jsonString.Append(strValue + "","");
                    }
                    else
                    {
                        jsonString.Append(strValue);
                    }
                }
                jsonString.Append(""},"");
            }
            dataReader.Close();
            jsonString.Remove(jsonString.Length - 1, 1);
            jsonString.Append(""]"");
            return jsonString.ToString();
        }"
"<summary>
For ASP.Net applications.

Starts a thread to perform a task at BelowNormal priority on a regular interval.

Meant for long-running ASP.Net apps that never recycle instead of a Windows
Service or cron job.

If the task runs longer than the timer interval, the existing thread is left be
and nothing else happens until the next time the interval fires where the worker
thread is not running.

Cannot handle multiple tasks; if you have multiple tasks to manage, build on top
of this class by adding task registration to a single task that this class runs.

The task is defined as an Action&lt;IntervalTaskContext&gt;, where the argument
it takes is a context object that has a single property: Stopping. If the ASP.Net
app needs to shut down for some reason, and the task is currently running, this
flag will flip to true, and the app will be forcibly torn down by the environment
in 30 seconds. This means the task should check Stopping regularly to see if it
should cut its work short. Note that the 30 seconds is for the entire app to tie
up what it's doing, not just this task - so be conservative.

For more on the ASP.Net App teardown process:
http://msdn.microsoft.com/en-us/library/system.web.hosting.iregisteredobject.stop.aspx
http://haacked.com/archive/2011/10/16/the-dangers-of-implementing-recurring-background-tasks-in-asp-net.aspx
</summary>","public static IntervalTask CreateTask(Action taskAction)
		{
			if (Current != null)
				throw new FieldAccessException(""CreateTask requested, but a task already exists."");
			Current = new IntervalTask(taskAction);
			return Current;
		}"
"<summary>
If the background task timer is running, changes its interval.
If the timer isn't running, starts the timer (and so, the background task).
</summary>","public void SetInterval(int interval)
		{
			intervalTimer.SetInterval(interval);
		}"
"<summary>
Stops the timer. If the background task is running when this is called, it's
left be so it can finish it's work, but will not be woken up to start again
until SetTimerInterval() is called with a positive value.

Convenience method. This has the same effect as calling
SetTimerInterval(Timeout.Infinite);
</summary>","public void StopTimer()
		{
			intervalTimer.Stop();
		}"
"<summary>
Call if the app is shutting down. Should only be called by the ASP.Net container.
</summary>","public void Stop(bool immediate)
		{
			lock (syncLock)
			{
				ShuttingDown = true;
				if (!TaskRunning)
					this.Dispose();
			}
		}"
"<summary>
Stops the Timer, and informs the ASP.Net hosting environment that it doesn't need to wait on the IntervalTask to shut down.
</summary>","public void Dispose()
		{
			StopTimer();
			System.Web.Hosting.HostingEnvironment.UnregisterObject(this);
		}"
"<summary>
A wrapper class for System.Threading.Timer

* Eliminates context object to pass in - just use a closure instead.

* Allows you to check on the current Interval the timer is set to.

* Uses just the one callback per timer - if you need a new callback, make a new TimerInfo.

* Simplifies changing schedule of timer.

* Easier to check on when it ran (check LastFired).
</summary>","public void SetInterval(int milliseconds)
		{
			if (timer"
"<summary>
Copyright (C) Maticsoft
数据访问基础类(基于Oracle)
用户可以修改满足自己项目的需要。
</summary>","public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"<summary>
创建 OracleCommand 对象实例(用来返回一个整数值)
</summary>","private static OracleCommand BuildIntCommand(OracleConnection connection,string storedProcName, IDataParameter[] parameters)
		{
			OracleCommand command = BuildQueryCommand(connection,storedProcName, parameters );
			command.Parameters.Add( new OracleParameter ( ""ReturnValue"",
                OracleType.Int32, 4, ParameterDirection.ReturnValue,
				false,0,0,string.Empty,DataRowVersion.Default,null ));
			return command;
		}"
"<summary>
数据访问类，可用于访问不同数据库
Copyright (C) Maticsoft
</summary>","public bool ColumnExists(string tableName, string columnName)
        {
            string sql = ""select count(1) from syscolumns where [id]=object_id('"" + tableName + ""') and [name]='"" + columnName + ""'"";
            object res = GetSingle(sql);
            if (res"
"<summary>
数据访问抽象基础类
Copyright (C) Maticsoft
</summary>","public static bool ColumnExists(string tableName, string columnName)
        {
            string sql = ""select count(1) from syscolumns where [id]=object_id('"" + tableName + ""') and [name]='"" + columnName + ""'"";
            object res = GetSingle(sql);
            if (res"
"<summary>
Copyright (C) Maticsoft
数据访问基础类(基于OleDb)
可以用户可以修改满足自己项目的需要。
</summary>","public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = DbHelperSQL.GetSingle(strsql);
            if (obj"
"<summary>
数据访问抽象基础类
Copyright (C) Maticsoft
</summary>","public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"<summary>
Copyright (C) 2011 Maticsoft
数据访问基础类(基于SQLite)
可以用户可以修改满足自己项目的需要。
</summary>","public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"<summary>
A helper class used to execute queries against an Oracle database
</summary>","public static int ExecuteNonQuery(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            using (OracleConnection connection = new OracleConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                int val = cmd.ExecuteNonQuery();
                connection.Close();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"<summary>
Execute an OracleCommand (that returns no resultset) against an existing database transaction
using the provided parameters.
</summary>","public static int ExecuteNonQuery(OracleTransaction trans, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, trans.Connection, trans, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
Execute an OracleCommand (that returns no resultset) against an existing database connection
using the provided parameters.
</summary>","public static int ExecuteNonQuery(OracleConnection connection, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
Execute a select query that will return a result set
</summary>","public static OracleDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            OracleConnection conn = new OracleConnection(connectionString);
            try
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                OracleDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                cmd.Parameters.Clear();
                return rdr;
            }
            catch
            {
                conn.Close();
                throw;
            }
        }"
"<summary>
Execute an OracleCommand that returns the first column of the first record against the database specified in the connection string
using the provided parameters.
</summary>","public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            using (OracleConnection conn = new OracleConnection(connectionString))
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"<summary>
Execute	a OracleCommand (that returns a 1x1 resultset)	against	the	specified SqlTransaction
using the provided parameters.
</summary>","public static object ExecuteScalar(OracleTransaction transaction, CommandType commandType, string commandText, params OracleParameter[] commandParameters)
        {
            if (transaction"
"<summary>
Execute an OracleCommand that returns the first column of the first record against an existing database connection
using the provided parameters.
</summary>","public static object ExecuteScalar(OracleConnection connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, connectionString, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
Add a set of parameters to the cached
</summary>","public static void CacheParameters(string cacheKey, params OracleParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"<summary>
Fetch parameters from the cache
</summary>","public static OracleParameter[] GetCachedParameters(string cacheKey)
        {
            OracleParameter[] cachedParms = (OracleParameter[])parmCache[cacheKey];
            if (cachedParms"
"<summary>
Converter to use boolean data type with Oracle
</summary>","public static string OraBit(bool value)
        {
            if (value)
                return ""Y"";
            else
                return ""N"";
        }"
"<summary>
Converter to use boolean data type with Oracle
</summary>","public static bool OraBool(string value)
        {
            if (value.Equals(""Y""))
                return true;
            else
                return false;
        }"
"<summary>
The SqlHelper class is intended to encapsulate high performance,
scalable best practices for common uses of SqlClient.
</summary>","public static int ExecuteNonQuery(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection conn = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                int val = cmd.ExecuteNonQuery();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"<summary>
Execute a SqlCommand (that returns no resultset) against an existing database connection
using the provided parameters.
</summary>","public static int ExecuteNonQuery(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
Execute a SqlCommand (that returns no resultset) using an existing SQL Transaction
using the provided parameters.
</summary>","public static int ExecuteNonQuery(SqlTransaction trans, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, trans.Connection, trans, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
Execute a SqlCommand that returns a resultset against the database specified in the connection string
using the provided parameters.
</summary>","public static SqlDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            SqlConnection conn = new SqlConnection(connectionString);
            try
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                SqlDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                cmd.Parameters.Clear();
                return rdr;
            }
            catch
            {
                conn.Close();
                throw;
            }
        }"
"<summary>
Execute a SqlCommand that returns the first column of the first record against the database specified in the connection string
using the provided parameters.
</summary>","public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"<summary>
Execute a SqlCommand that returns the first column of the first record against an existing database connection
using the provided parameters.
</summary>","public static object ExecuteScalar(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
add parameter array to the cache
</summary>","public static void CacheParameters(string cacheKey, params SqlParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"<summary>
Retrieve cached parameters
</summary>","public static SqlParameter[] GetCachedParameters(string cacheKey)
        {
            SqlParameter[] cachedParms = (SqlParameter[])parmCache[cacheKey];
            if (cachedParms"
"<summary>
Prepare a command for execution
</summary>","private static void PrepareCommand(SqlCommand cmd, SqlConnection conn, SqlTransaction trans, CommandType cmdType, string cmdText, SqlParameter[] cmdParms)
        {
            if (conn.State != ConnectionState.Open)
                conn.Open();
            cmd.Connection = conn;
            cmd.CommandText = cmdText;
            if (trans != null)
                cmd.Transaction = trans;
            cmd.CommandType = cmdType;
            if (cmdParms != null)
            {
                foreach (SqlParameter parm in cmdParms)
                    cmd.Parameters.Add(parm);
            }
        }"
"<summary>
验证码 继承 System.Web.UI.Page ，Session[""xk_validate_code""]
</summary>","private void Page_Load(object sender, EventArgs e)
        {
            char[] chars = ""023456789"".ToCharArray();
            System.Random random = new Random();
            string validateCode = string.Empty;
            for (int i = 0; i < 4; i++)
            {
                char rc = chars[random.Next(0, chars.Length)];
                if (validateCode.IndexOf(rc) > -1)
                {
                    i--;
                    continue;
                }
                validateCode += rc;
            }
            Session[""xk_validate_code""] = validateCode;
            CreateImage(validateCode);
        }"
"<summary>
Encrypt 的摘要说明。
</summary>","public static string Encrypt(string original)
        {
            return Encrypt(original, ""kuiyu.net"");
        }"
"<summary>
MySecurity(安全类) 的摘要说明。
</summary>","static public string SEncryptString(string inputStr, string keyStr)
        {
            MySecurity ws = new MySecurity();
            return ws.EncryptString(inputStr, keyStr);
        }"
"<summary>
Summary description for GridViewExport
</summary>","public static void Export(string fileName, GridView gv)
        {
            HttpContext.Current.Response.Clear();
            HttpContext.Current.Response.AddHeader(
                ""content-disposition"", string.Format(""attachment; filename={0}"", fileName));
            HttpContext.Current.Response.ContentType = ""application/ms-excel"";
            using (StringWriter sw = new StringWriter())
            {
                using (HtmlTextWriter htw = new HtmlTextWriter(sw))
                {
                    Table table = new Table();
                    table.GridLines = GridLines.Both;  
                    if (gv.HeaderRow != null)
                    {
                        PrepareControlForExport(gv.HeaderRow);
                        table.Rows.Add(gv.HeaderRow);
                    }
                    foreach (GridViewRow row in gv.Rows)
                    {
                        PrepareControlForExport(row);
                        table.Rows.Add(row);
                    }
                    if (gv.FooterRow != null)
                    {
                        PrepareControlForExport(gv.FooterRow);
                        table.Rows.Add(gv.FooterRow);
                    }
                    table.RenderControl(htw);
                    HttpContext.Current.Response.Write(sw.ToString());
                    HttpContext.Current.Response.End();
                }
            }
        }"
"<summary>
Replace any of the contained controls with literals
</summary>","private static void PrepareControlForExport(Control control)
        {
            for (int i = 0; i < control.Controls.Count; i++)
            {
                Control current = control.Controls[i];
                if (current is LinkButton)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as LinkButton).Text));
                }
                else if (current is ImageButton)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as ImageButton).AlternateText));
                }
                else if (current is HyperLink)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as HyperLink).Text));
                }
                else if (current is DropDownList)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as DropDownList).SelectedItem.Text));
                }
                else if (current is CheckBox)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as CheckBox).Checked ? ""True"" : ""False""));
                }
                if (current.HasControls())
                {
                    PrepareControlForExport(current);
                }
            }
        }"
"<summary>
时间类
1、SecondToMinute(int Second) 把秒转换成分钟
</summary>","public string GetFormatDate(DateTime dt, char Separator)
        {
            if (dt != null && !dt.Equals(DBNull.Value))
            {
                string tem = string.Format(""yyyy{0}MM{1}dd"", Separator, Separator);
                return dt.ToString(tem);
            }
            else
            {
                return GetFormatDate(DateTime.Now, Separator);
            }
        }"
"<summary>
将String转换为DateTime?类型
</summary>","public static string FormatDate(string dateString)
        {
            var dt = ParseToDateValue(dateString);
            if (dt"
"<summary>
字符串操作类
1、GetStrArray(string str, char speater, bool toLower)  把字符串按照分隔符转换成 List
2、GetStrArray(string str) 把字符串转 按照, 分割 换为数据
3、GetArrayStr(List list, string speater) 把 List 按照分隔符组装成 string
4、GetArrayStr(List list)  得到数组列表以逗号分隔的字符串
5、GetArrayValueStr(Dictionary<int, int> list)得到数组列表以逗号分隔的字符串
6、DelLastComma(string str)删除最后结尾的一个逗号
7、DelLastChar(string str, string strchar)删除最后结尾的指定字符后的字符
8、ToSBC(string input)转全角的函数(SBC case)
9、ToDBC(string input)转半角的函数(SBC case)
10、GetSubStringList(string o_str, char sepeater)把字符串按照指定分隔符装成 List 去除重复
11、GetCleanStyle(string StrList, string SplitString)将字符串样式转换为纯字符串
12、GetNewStyle(string StrList, string NewStyle, string SplitString, out string Error)将字符串转换为新样式
13、SplitMulti(string str, string splitstr)分割字符串
14、SqlSafeString(string String, bool IsDel)
</summary>","public static List<string> GetStrArray(string str, char speater, bool toLower)
        {
            List<string> list = new List<string>();
            string[] ss = str.Split(speater);
            foreach (string s in ss)
            {
                if (!string.IsNullOrEmpty(s) && s != speater.ToString())
                {
                    string strVal = s;
                    if (toLower)
                    {
                        strVal = s.ToLower();
                    }
                    list.Add(strVal);
                }
            }
            return list;
        }"
"<summary>
Create the CAPTCHA specified Length, Sleep and List.
</summary>","private static string Create(int Length, bool Sleep, char[] List)
		{
			if (Sleep) Thread.Sleep(3);
			char[] Pattern = List;
			string result = string.Empty;
			int n = Pattern.Length;
			for (int i = 0; i < Length; i++)
			{
				int rnd = Random.Next(0, n);
				result += Pattern[rnd];
			}
			return result;
		}"
"<summary>
DataTable转换为Json
</summary>","public static string ToJson(DataTable dt, string jsonName)
        {
            StringBuilder Json = new StringBuilder();
            if (string.IsNullOrEmpty(jsonName)) jsonName = dt.TableName;
            Json.Append(""{\"""" + jsonName + ""\"":["");
            if (dt.Rows.Count > 0)
            {
                for (int i = 0; i < dt.Rows.Count; i++)
                {
                    Json.Append(""{"");
                    for (int j = 0; j < dt.Columns.Count; j++)
                    {
                        Type type = dt.Rows[i][j].GetType();
                        Json.Append(""\"""" + dt.Columns[j].ColumnName.ToString() + ""\"":"" + StringFormat(dt.Rows[i][j].ToString(), type));
                        if (j < dt.Columns.Count - 1)
                        {
                            Json.Append("","");
                        }
                    }
                    Json.Append(""}"");
                    if (i < dt.Rows.Count - 1)
                    {
                        Json.Append("","");
                    }
                }
            }
            Json.Append(""]}"");
            return Json.ToString();
        }"
"<summary>
Remove AppConfig
</summary>","public static void RemoveAppConfig(string key)
        {
            ConfigurationManager.AppSettings.Remove(key);
        }"
"<summary>
Utility methods related to CLR Types for SQL Server
</summary>","private static extern IntPtr LoadLibrary(string libname);
        public static void LoadNativeAssemblies(string rootApplicationPath)
        {
            var nativeBinaryPath = IntPtr.Size > 4
                ? Path.Combine(rootApplicationPath, @""SqlServerTypes\x64\"")
                : Path.Combine(rootApplicationPath, @""SqlServerTypes\x86\"");
            LoadNativeAssembly(nativeBinaryPath, ""msvcr120.dll"");
            LoadNativeAssembly(nativeBinaryPath, ""SqlServerSpatial140.dll"");
        }"
"<summary>
This class is responsible for parsing a string array of lines
containing a MIME message.
</summary>","private int ParseHeaders()
        {
            string lastHeader = string.Empty;
            string line = string.Empty;
            while (_lines.Count > 0 && !string.IsNullOrEmpty(_lines.Peek()))
            {
                line = _lines.Dequeue();
                if (line.StartsWith("" "") || line.StartsWith(Convert.ToString('\t')))
                {
                    _entity.Headers[lastHeader] = string.Concat(_entity.Headers[lastHeader], line);
                    continue;
                }
                int separatorIndex = line.IndexOf(':');
                if (separatorIndex < 0)
                {
                    System.Diagnostics.Debug.WriteLine(""Invalid header:{0}"", line);
                    continue;
                }  
                string headerName = line.Substring(0, separatorIndex);
                string headerValue = line.Substring(separatorIndex + 1).Trim(HeaderWhitespaceChars);
                _entity.Headers.Add(headerName.ToLower(), headerValue);
                lastHeader = headerName;
            }
            if (_lines.Count > 0)
            {
                _lines.Dequeue();
            } 
            return _entity.Headers.Count;
        }"
"<summary>
Processes mime specific headers.
</summary>","private void ProcessHeaders()
        {
            foreach (string key in _entity.Headers.AllKeys)
            {
                switch (key)
                {
                    case ""content-description"":
                        _entity.ContentDescription = _entity.Headers[key];
                        break;
                    case ""content-disposition"":
                        _entity.ContentDisposition = new ContentDisposition(_entity.Headers[key]);
                        break;
                    case ""content-id"":
                        _entity.ContentId = _entity.Headers[key];
                        break;
                    case ""content-transfer-encoding"":
                        _entity.TransferEncoding = _entity.Headers[key];
                        _entity.ContentTransferEncoding = MimeReader.GetTransferEncoding(_entity.Headers[key]);
                        break;
                    case ""content-type"":
                        _entity.SetContentType(MimeReader.GetContentType(_entity.Headers[key]));
                        break;
                    case ""mime-version"":
                        _entity.MimeVersion = _entity.Headers[key];
                        break;
                }
            }
        }"
"<summary>
Creates the MIME entity.
</summary>","public MimeEntity CreateMimeEntity()
        {
            try
            {
                ParseHeaders();
                ProcessHeaders();
                ParseBody();
                SetDecodedContentStream();
                return _entity;
            }
            catch
            {
                return null;
            }
        }"
"<summary>
Sets the decoded content stream by decoding the EncodedMessage
and writing it to the entity content stream.
</summary>","private void SetDecodedContentStream()
        {
            switch (_entity.ContentTransferEncoding)
            {
                case System.Net.Mime.TransferEncoding.Base64:
                    _entity.Content = new MemoryStream(Convert.FromBase64String(_entity.EncodedMessage.ToString()), false);
                    break;
                case System.Net.Mime.TransferEncoding.QuotedPrintable:
                    _entity.Content = new MemoryStream(GetBytes(QuotedPrintableEncoding.Decode(_entity.EncodedMessage.ToString())), false);
                    break;
                case System.Net.Mime.TransferEncoding.SevenBit:
                default:
                    _entity.Content = new MemoryStream(GetBytes(_entity.EncodedMessage.ToString()), false);
                    break;
            }
        }"
"<summary>
Gets a byte[] of content for the provided string.
</summary>","private byte[] GetBytes(string content)
        {
            using (MemoryStream stream = new MemoryStream())
            {
                using (StreamWriter writer = new StreamWriter(stream))
                {
                    writer.Write(content);
                }
                return stream.ToArray();
            }
        }"
"<summary>
Parses the body.
</summary>","private void ParseBody()
        {
            if (_entity.HasBoundary)
            {
                while (_lines.Count > 0
                    && !string.Equals(_lines.Peek(), _entity.EndBoundary))
                {
                    if (_entity.Parent != null
                        && string.Equals(_entity.Parent.StartBoundary, _lines.Peek()))
                    {
                        return;
                    }
                    if (string.Equals(_lines.Peek(), _entity.StartBoundary))
                    {
                        AddChildEntity(_entity, _lines);
                    } 
                    else if (string.Equals(_entity.ContentType.MediaType, MediaTypes.MessageRfc822, StringComparison.InvariantCultureIgnoreCase)
                        && string.Equals(_entity.ContentDisposition.DispositionType, DispositionTypeNames.Attachment, StringComparison.InvariantCultureIgnoreCase))
                    {
                        AddChildEntity(_entity, _lines);
                        break;
                    }
                    else
                    {
                        _entity.EncodedMessage.Append(string.Concat(_lines.Dequeue(), Pop3Commands.Crlf));
                    } 
                }
            } 
            else
            {
                while (_lines.Count > 0)
                {
                    _entity.EncodedMessage.Append(string.Concat(_lines.Dequeue(), Pop3Commands.Crlf));
                }
            } 
        }"
"<summary>
Adds the child entity.
</summary>","private void AddChildEntity(MimeEntity entity, Queue<string> lines)
        {"
"<summary>
Gets the type of the content.
</summary>","public static ContentType GetContentType(string contentType)
        {
            if (string.IsNullOrEmpty(contentType))
            {
                contentType = ""text/plain; charset=us-ascii"";
            }
            return new ContentType(contentType);
        }"
"<summary>
Gets the type of the media.
</summary>","public static string GetMediaType(string mediaType)
        {
            if (string.IsNullOrEmpty(mediaType))
            {
                return ""text/plain"";
            }
            return mediaType.Trim();
        }"
"<summary>
Gets the type of the media main.
</summary>","public static string GetMediaMainType(string mediaType)
        {
            int separatorIndex = mediaType.IndexOf('/');
            if (separatorIndex < 0)
            {
                return mediaType;
            }
            else
            {
                return mediaType.Substring(0, separatorIndex);
            }
        }"
"<summary>
Gets the type of the media sub.
</summary>","public static string GetMediaSubType(string mediaType)
        {
            int separatorIndex = mediaType.IndexOf('/');
            if (separatorIndex < 0)
            {
                if (mediaType.Equals(""text""))
                {
                    return ""plain"";
                }
                return string.Empty;
            }
            else
            {
                if (mediaType.Length > separatorIndex)
                {
                    return mediaType.Substring(separatorIndex + 1);
                }
                else
                {
                    string mainType = GetMediaMainType(mediaType);
                    if (mainType.Equals(""text""))
                    {
                        return ""plain"";
                    }
                    return string.Empty;
                }
            }
        }"
"<summary>
Gets the transfer encoding.
</summary>","public static TransferEncoding GetTransferEncoding(string transferEncoding)
        {
            switch (transferEncoding.Trim().ToLowerInvariant())
            {
                case ""7bit"":
                case ""8bit"":
                    return System.Net.Mime.TransferEncoding.SevenBit;
                case ""quoted-printable"":
                    return System.Net.Mime.TransferEncoding.QuotedPrintable;
                case ""base64"":
                    return System.Net.Mime.TransferEncoding.Base64;
                case ""binary"":
                default:
                    return System.Net.Mime.TransferEncoding.Unknown;
            }
        }"
"<summary>
This class is based on the QuotedPrintable class written by Bill Gearhart
found at http://www.aspemporium.com/classes.aspx?cid=6
</summary>","public static string Decode(string contents)
        {
            if (contents"
<summary>Queues a user work item to the thread pool.</summary>,"public static void QueueUserWorkItem(WaitCallback callback)
        {
            QueueUserWorkItem(callback, null);
        }"
<summary>Queues a user work item to the thread pool.</summary>,"public static void QueueUserWorkItem(WaitCallback callback, object state)
        {
            WaitingCallback waiting = new WaitingCallback(callback, state);
            lock (_poolLock) { _waitingCallbacks.Enqueue(waiting); }
            _workerThreadNeeded.AddOne();
        }"
<summary>Empties the work queue of any queued work items.  Resets all threads in the pool.</summary>,"public static void Reset()
        {
            lock (_poolLock)
            {
                try
                {
                    foreach (object obj in _waitingCallbacks)
                    {
                        WaitingCallback callback = (WaitingCallback)obj;
                        if (callback.State is IDisposable) ((IDisposable)callback.State).Dispose();
                    }
                }
                catch { }
                try
                {
                    foreach (Thread thread in _workerThreads)
                    {
                        if (thread != null) thread.Abort(""reset"");
                    }
                }
                catch { }
                Initialize();
            }
        }"
<summary>Gets the number of threads at the disposal of the thread pool.</summary>,"private static void ProcessQueuedItems()
        {
            while (true)
            {
                _workerThreadNeeded.WaitOne();
                WaitingCallback callback = null;
                lock (_poolLock)
                {
                    if (_waitingCallbacks.Count > 0)
                    {
                        try { callback = (WaitingCallback)_waitingCallbacks.Dequeue(); }
                        catch { } 
                    }
                }
                if (callback != null)
                {
                    try
                    {
                        Interlocked.Increment(ref _inUseThreads);
                        callback.Callback(callback.State);
                    }
                    catch (Exception)
                    {
                    }
                    finally
                    {
                        Interlocked.Decrement(ref _inUseThreads);
                    }
                }
            }
        }"
<summary>P the semaphore (take out 1 unit from it).</summary>,"public void P()
        {
            lock (_semLock)
            {
                while (_count <= 0) Monitor.Wait(_semLock, Timeout.Infinite);
                _count--;
            }
        }"
<summary>V the semaphore (add 1 unit to it).</summary>,"public void V()
        {
            lock (_semLock)
            {
                _count++;
                Monitor.Pulse(_semLock);
            }
        }"
<summary>Resets the semaphore to the specified count.  Should be used cautiously.</summary>,"public void Reset(int count)
        {
            lock (_semLock) { _count = count; }
        }"
"<summary>
DataTable导出到Excel的MemoryStream
</summary>","public static MemoryStream Export(DataTable dtSource, string strHeaderText)
        {
            HSSFWorkbook workbook = new HSSFWorkbook();
            ISheet sheet = workbook.CreateSheet();
            ICellStyle dateStyle = workbook.CreateCellStyle();
            IDataFormat format = workbook.CreateDataFormat();
            dateStyle.DataFormat = format.GetFormat(""yyyy-MM-dd"");
            #region 取得每列的列宽（最大宽度）
            int[] arrColWidth = new int[dtSource.Columns.Count];
            foreach (DataColumn item in dtSource.Columns)
            {
                arrColWidth[item.Ordinal] = Encoding.GetEncoding(936).GetBytes(item.ColumnName.ToString()).Length;
            }
            for (int i = 0; i < dtSource.Rows.Count; i++)
            {
                for (int j = 0; j < dtSource.Columns.Count; j++)
                {
                    int intTemp = Encoding.GetEncoding(936).GetBytes(dtSource.Rows[i][j].ToString()).Length;
                    if (intTemp > arrColWidth[j])
                    {
                        arrColWidth[j] = intTemp;
                    }
                }
            }
            #endregion
            int rowIndex = 0;
            foreach (DataRow row in dtSource.Rows)
            {
                #region 新建表，填充表头，填充列头，样式
                if (rowIndex"
"<summary>
读取QueryString值
</summary>","public static string GetQueryString(string queryStringName)
        {
            if ((HttpContext.Current.Request.QueryString[queryStringName] != null) &&
                (HttpContext.Current.Request.QueryString[queryStringName] != ""undefined""))
            {
                return HttpContext.Current.Request.QueryString[queryStringName].Trim();
            }
            else
            {
                return """";
            }
        }"
"<summary>
i.e. /CN=Users,DC=creditsights, DC=cyberelves, DC=Com
</summary>","private static DirectoryEntry GetDirectoryObject(string domainReference)
        {
            DirectoryEntry entry = new DirectoryEntry(ADPath + domainReference, ADUser, ADPassword,
                AuthenticationTypes.Secure);
            return entry;
        }"
"<summary>
获得以UserName,Password创建的DirectoryEntry
</summary>","private static DirectoryEntry GetDirectoryObject(string domainReference,
            string userName, string password)
        {
            DirectoryEntry entry = new DirectoryEntry(ADPath + domainReference,
                userName, password, AuthenticationTypes.Secure);
            return entry;
        }"
"<summary>
重命名Account
</summary>","public static bool RenameAcc(string oldAcc, string newAcc)
        {
            try
            {
                if (IsAccExists(oldAcc))
                {
                    if (IsAccExists(newAcc))
                        return false;
                    DirectoryEntry userEntry = GetDirectoryEntryByAccount(oldAcc);
                    userEntry.Properties[""sAMAccountName""][0] = newAcc;
                    userEntry.CommitChanges();
                    userEntry.Dispose();
                    return true;
                }
                else
                    return false;
            }
            catch (Exception)
            {
                return false;
            }
        }"
"<summary>
获取域的后缀DN名,如域为cinf.com,则返回""DC=cinf,DC=Com""
</summary>","public static string GetDomainDN()
        {
            return LDAPDomain;
        }"
"<summary>
讲枚举绑定在DropDownList上
</summary>","public static void BindDropDownList_Replace(DropDownList list, Type TypeEnum)
       {
           List<ListItem> TypeList = new List<ListItem>();
           foreach (object type in Enum.GetValues(TypeEnum))
           {
               string str=type.ToString();
               if (str.Contains('N') || str.Contains('D') || str.Contains('G')||str.Contains('M')||str.Contains('Q'))
               {
                   str=str.Replace(""N"", ""$"");
                   str=str.Replace(""D"", "","");
                   str=str.Replace(""G"", "" - "");
                   str = str.Replace(""M"", ""."");
                   str = str.Replace(""Q"", """");
               }
               TypeList.Add(new ListItem(str, ((int)type).ToString()));
           }
           list.DataSource = TypeList;
           list.DataTextField = ""text"";
           list.DataValueField = ""value"";
           list.DataBind();
       }"
"<summary>
This command represents the Pop3 RSET command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Rset);
        }"
"<summary>
This class represents both the multiline and single line Pop3 LIST command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            string requestMessage = Pop3Commands.List;
            if (!IsMultiline)
            {
                requestMessage += _messageId.ToString();
            } 
            return GetRequestMessage(requestMessage, Pop3Commands.Crlf);
        }"
"<summary>
Creates the response.
</summary>","protected override ListResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            List<Pop3ListItem> items;
            if (IsMultiline)
            {
                items = new List<Pop3ListItem>();
                string[] values;
                string[] lines = GetResponseLines(StripPop3HostMessage(buffer, response.HostMessage));
                foreach (string line in lines)
                {
                    values = line.Split(' ');
                    if (values.Length < 2)
                    {
                        throw new Pop3Exception(string.Concat(""Invalid line in multiline response:  "", line));
                    }
                    items.Add(new Pop3ListItem(Convert.ToInt32(values[0]),
                        Convert.ToInt64(values[1])));
                }
            } 
            else
            {
                items = new List<Pop3ListItem>(1);
                string[] values = response.HostMessage.Split(' ');
                if (values.Length < 3)
                {
                    throw new Pop3Exception(string.Concat(""Invalid response message: "", response.HostMessage));
                }
                items.Add(new Pop3ListItem(Convert.ToInt32(values[1]), Convert.ToInt64(values[2])));
            } 
            return new ListResponse(response, items);
        }"
"<summary>
This command represents a Pop3 USER command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.User, _username, Pop3Commands.Crlf);
        }"
"<summary>
This class represents the Pop3 QUIT command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Quit);
        }"
"<summary>
This class represents the Pop3 PASS command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Pass, _password, Pop3Commands.Crlf);
        }"
"<summary>
This class represents the Pop3 STAT command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Stat);
        }"
"<summary>
Creates the response.
</summary>","protected override StatResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            string[] values = response.HostMessage.Split(' ');
            if (values.Length < 3)
            {
                throw new Pop3Exception(string.Concat(""Invalid response message: "", response.HostMessage));
            }
            int messageCount = Convert.ToInt32(values[1]);
            long octets = Convert.ToInt64(values[2]);
            return new StatResponse(response, messageCount, octets);
        }"
"<summary>
This class represents the Pop3 NOOP command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Noop);
        }"
"<summary>
This class represents the Pop3 RETR command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Retr, _message.ToString(), Pop3Commands.Crlf);
        }"
"<summary>
Creates the response.
</summary>","protected override RetrResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            string[] messageLines = GetResponseLines(StripPop3HostMessage(buffer, response.HostMessage));
            return new RetrResponse(response, messageLines);
        }"
"<summary>
This class represents a Pop3 response message and
is intended to be used as a base class for all other
Pop3Response types.
</summary>","public static Pop3Response CreateResponse(byte[] responseContents)
        {
            string hostMessage;
            MemoryStream stream = new MemoryStream(responseContents);
            using (StreamReader reader = new StreamReader(stream))
            {
                hostMessage = reader.ReadLine();
                if (hostMessage"
"<summary>
Performs the connect to a Pop3 server and returns a Pop3
response indicating the attempt to connect results and the
network stream to use for all subsequent Pop3 Commands.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return null;
        }"
"<summary>
Executes this instance.
</summary>","internal override ConnectResponse Execute(Pop3State currentState)
        {
            EnsurePop3State(currentState);
            try
            {
                _client.Connect(_hostname, _port);
                SetClientStream();
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(string.Format(""Unable to connect to {0}:{1}."", _hostname, _port), e);
            }
            return base.Execute(currentState);
        }"
"<summary>
Sets the client stream.
</summary>","private void SetClientStream()
        {
            if (_useSsl)
            {
                try
                {
                    NetworkStream = new SslStream(_client.GetStream(), true); 
                    ((SslStream)NetworkStream).AuthenticateAsClient(_hostname);
                }
                catch (ArgumentException e)
                {
                    throw new Pop3Exception(""Unable to create Ssl Stream for hostname: "" + _hostname, e);
                }
                catch (AuthenticationException e)
                {
                    throw new Pop3Exception(""Unable to authenticate ssl stream for hostname: "" + _hostname, e);
                }
                catch (InvalidOperationException e)
                {
                    throw new Pop3Exception(""There was a problem  attempting to authenticate this SSL stream for hostname: "" + _hostname, e);
                }
            } 
            else
            {
                NetworkStream = _client.GetStream();
            }
        }"
"<summary>
Creates the response.
</summary>","protected override ConnectResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            return new ConnectResponse(response, NetworkStream);
        }"
"<summary>
Initializes a new instance of the <see cref=""TopCommand""/> class.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Top, _messageNumber.ToString(), "" "", _lineCount.ToString(), Pop3Commands.Crlf);
        }"
"<summary>
Creates the response.
</summary>","protected override RetrResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            if (response"
"<summary>
This class represents a generic Pop3 command and
encapsulates the major operations when executing a
Pop3 command against a Pop3 Server.
</summary>","protected void OnTrace(string message)
        {
            if (Trace != null)
            {
                Trace(message);
            }
        }"
"<summary>
Sets a value indicating whether this instance is multiline.
</summary>","protected abstract byte[] CreateRequestMessage();
        private void Send(byte[] message)
        {
            try
            {
                _networkStream.Write(message, 0, message.Length);
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(""Unable to send the request message: "" + Encoding.ASCII.GetString(message), e);
            }
        }"
"<summary>
Executes this instance.
</summary>","internal virtual T Execute(Pop3State currentState)
        {
            EnsurePop3State(currentState);
            byte[] message = CreateRequestMessage();
            if (message != null)
            {
                Send(message);
            }
            T response = CreateResponse(GetResponse());
            if (response"
"<summary>
Ensures the state of the POP3.
</summary>","protected void EnsurePop3State(Pop3State currentState)
        {
            if (!((currentState & ValidExecuteState)"
"<summary>
Creates the response.
</summary>","protected virtual T CreateResponse(byte[] buffer)
        {
            return Pop3Response.CreateResponse(buffer) as T;
        }"
"<summary>
Gets the response.
</summary>","private byte[] GetResponse()
        {
            AsyncCallback callback;
            if (_isMultiline)
            {
                callback = new AsyncCallback(GetMultiLineResponseCallback);
            }
            else
            {
                callback = new AsyncCallback(GetSingleLineResponseCallback);
            }
            try
            {
                Receive(callback);
                _manualResetEvent.WaitOne();
                return _responseContents.ToArray();
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(""Unable to get response."", e);
            }
        }"
"<summary>
Receives the specified callback.
</summary>","private IAsyncResult Receive(AsyncCallback callback)
        {
            return _networkStream.BeginRead(_buffer, 0, _buffer.Length, callback, null);
        }"
"<summary>
Writes the received bytes to buffer.
</summary>","private string WriteReceivedBytesToBuffer(int bytesReceived)
        {
            _responseContents.Write(_buffer, 0, bytesReceived);
            byte[] contents = _responseContents.ToArray();
            return Encoding.ASCII.GetString(contents, (contents.Length > 5 ? contents.Length - 5 : 0), 5);
        }"
"<summary>
Gets the single line response callback.
</summary>","private void GetSingleLineResponseCallback(IAsyncResult ar)
        {
            int bytesReceived = _networkStream.EndRead(ar);
            string message = WriteReceivedBytesToBuffer(bytesReceived);
            if (message.EndsWith(Pop3Commands.Crlf))
            {
                _manualResetEvent.Set();
            }
            else
            {
                Receive(new AsyncCallback(GetSingleLineResponseCallback));
            }
        }"
"<summary>
Gets the multi line response callback.
</summary>","private void GetMultiLineResponseCallback(IAsyncResult ar)
        {
            int bytesReceived = _networkStream.EndRead(ar);
            string message = WriteReceivedBytesToBuffer(bytesReceived);
            if (message.EndsWith(MultilineMessageTerminator)
                || bytesReceived"
"<summary>
Gets the request message.
</summary>","protected byte[] GetRequestMessage(params string[] args)
        {
            string message = string.Join(string.Empty, args);
            OnTrace(message);
            return Encoding.ASCII.GetBytes(message);
        }"
"<summary>
Strips the POP3 host message.
</summary>","protected MemoryStream StripPop3HostMessage(byte[] bytes, string header)
        {
            int position = header.Length + 2;
            MemoryStream stream = new MemoryStream(bytes, position, bytes.Length - position);
            return stream;
        }"
"<summary>
Gets the response lines.
</summary>","protected string[] GetResponseLines(MemoryStream stream)
        {
            List<string> lines = new List<string>();
            using (StreamReader reader = new StreamReader(stream))
            {
                try
                {
                    string line;
                    do
                    {
                        line = reader.ReadLine();
                        if (line.StartsWith(MessageTerminator))
                        {
                            if (line"
"<summary>
This class represents the Pop3 DELE command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(string.Concat(Pop3Commands.Dele, _messageId.ToString(), Pop3Commands.Crlf));
        }"
"<summary>
The Pop3Client class provides a wrapper for the Pop3 commands
that can be executed against a Pop3Server.  This class will
execute and return results for the various commands that are
executed.
</summary>","private void OnTrace(string message)
        {
            if (Trace != null)
            {
                Trace(message);
            }
        }"
"<summary>
Gets the hostname.
</summary>","private void EnsureConnection()
        {
            if (!_client.Connected)
            {
                throw new Pop3Exception(""Pop3 client is not connected."");
            }
        }"
"<summary>
Resets the state.
</summary>","private void SetState(Pop3State state)
        {
            _currentState = state;
        }"
"<summary>
Ensures the response.
</summary>","private void EnsureResponse(Pop3Response response, string error)
        {
            if (response"
"<summary>
Ensures the response.
</summary>","private void EnsureResponse(Pop3Response response)
        {
            EnsureResponse(response, string.Empty);
        }"
"<summary>
Traces the command.
</summary>","private void Connect()
        {
            if (_client"
"<summary>
Sets the client stream.  If UseSsl <c>true</c> then wrap
the client's <c>NetworkStream</c> in an <c>SslStream</c>, if UseSsl <c>false</c>
then set the client stream to the <c>NetworkStream</c>
</summary>","private void SetClientStream(Stream networkStream)
        {
            if (_clientStream != null)
            {
                _clientStream.Dispose();
            }
            _clientStream = networkStream;
        }"
"<summary>
Authenticates this instance.
</summary>","public void Authenticate()
        {
            Connect();
            using (UserCommand userCommand = new UserCommand(_clientStream, _username))
            {
                ExecuteCommand<Pop3Response, UserCommand>(userCommand);
            }
            using (PassCommand passCommand = new PassCommand(_clientStream, _password))
            {
                ExecuteCommand<Pop3Response, PassCommand>(passCommand);
            }
            _currentState = Pop3State.Transaction;
        }"
"<summary>
Executes the POP3 DELE command.
</summary>","public void Dele(Pop3ListItem item)
        {
            if (item"
"<summary>
Executes the POP3 NOOP command.
</summary>","public void Noop()
        {
            using (NoopCommand command = new NoopCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, NoopCommand>(command);
            }
        }"
"<summary>
Executes the POP3 RSET command.
</summary>","public void Rset()
        {
            using (RsetCommand command = new RsetCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, RsetCommand>(command);
            }
        }"
"<summary>
Executes the POP3 STAT command.
</summary>","public Stat Stat()
        {
            StatResponse response;
            using (StatCommand command = new StatCommand(_clientStream))
            {
                response = ExecuteCommand<StatResponse, StatCommand>(command);
            }
            return new Stat(response.MessageCount, response.Octets);
        }"
"<summary>
Executes the POP3 List command.
</summary>","public List<Pop3ListItem> List()
        {
            ListResponse response;
            using (ListCommand command = new ListCommand(_clientStream))
            {
                response = ExecuteCommand<ListResponse, ListCommand>(command);
            }
            return response.Items;
        }"
"<summary>
Lists the specified message.
</summary>","public Pop3ListItem List(int messageId)
        {
            ListResponse response;
            using (ListCommand command = new ListCommand(_clientStream, messageId))
            {
                response = ExecuteCommand<ListResponse, ListCommand>(command);
            }
            return new Pop3ListItem(response.MessageNumber, response.Octets);
        }"
"<summary>
Retrs the specified message.
</summary>","public MimeEntity RetrMimeEntity(Pop3ListItem item)
        {
            if (item"
"<summary>
Retrs the mail message ex.
</summary>","public MailMessageEx RetrMailMessageEx(Pop3ListItem item)
        {
            MailMessageEx message = RetrMimeEntity(item).ToMailMessageEx();
            if (message != null)
            {
                message.MessageNumber = item.MessageId;
            }
            return message;
        }"
"<summary>
Executes the Pop3 QUIT command.
</summary>","public void Quit()
        {
            using (QuitCommand command = new QuitCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, QuitCommand>(command);
                if (CurrentState.Equals(Pop3State.Transaction))
                {
                    SetState(Pop3State.Update);
                } 
                Disconnect();
                SetState(Pop3State.Unknown);
            }
        }"
"<summary>
Provides a common way to execute all commands.  This method
validates the connection, traces the command and finally
validates the response message for a -ERR response.
</summary>","private void Disconnect()
        {
            if (_clientStream != null)
            {
                _clientStream.Close();
            }  
            if (_client != null)
            {
                _client.Close();
                _client = null;
            }
        }"
"<summary>
INI文件读写类。
Copyright (C) Maticsoft
</summary>","private static extern long WritePrivateProfileString(string section,string key,string val,string filePath);
        [DllImport(""kernel32"")]
        private static extern int GetPrivateProfileString(string section,string key,string def, StringBuilder retVal,int size,string filePath);
        [DllImport(""kernel32"")]
        private static extern int GetPrivateProfileString(string section, string key, string defVal, Byte[] retVal, int size, string filePath);
        public void IniWriteValue(string Section,string Key,string Value)
        {
            WritePrivateProfileString(Section,Key,Value,this.path);
        }"
"<summary>
切换到主库，此方法适用于SQL自动查询服务端版本用
系统自动会使用 select cast(serverproperty('EngineEdition') as int) 来查询
</summary>","public static void UpdateToMaster(DbConnection conn)
        {
        }"
"<summary>
Session 操作类
1、GetSession(string name)根据session名获取session对象
2、SetSession(string name, object val)设置session
</summary>","public static object GetSession(string name)
        {
            return HttpContext.Current.Session[name];
        }"
"<summary>
创建一个IPEndPoint对象
</summary>","public static IPEndPoint CreateIPEndPoint(string ip, int port)
        {
            IPAddress ipAddress = StringToIPAddress(ip);
            return new IPEndPoint(ipAddress, port);
        }"
"<summary>
INI文件读写类。
Copyright (C) Maticsoft
</summary>","private static extern long WritePrivateProfileString(string section,string key,string val,string filePath);
        [DllImport(""kernel32"")]
        private static extern int GetPrivateProfileString(string section,string key,string def, StringBuilder retVal,int size,string filePath);
        [DllImport(""kernel32"")]
        private static extern int GetPrivateProfileString(string section, string key, string defVal, Byte[] retVal, int size, string filePath);
        public void IniWriteValue(string Section,string Key,string Value)
        {
            WritePrivateProfileString(Section,Key,Value,this.path);
        }"
"<summary>
Utility methods related to CLR Types for SQL Server
</summary>","private static extern IntPtr LoadLibrary(string libname);
        public static void LoadNativeAssemblies(string rootApplicationPath)
        {
            var nativeBinaryPath = IntPtr.Size > 4
                ? Path.Combine(rootApplicationPath, @""SqlServerTypes\x64\"")
                : Path.Combine(rootApplicationPath, @""SqlServerTypes\x86\"");
            LoadNativeAssembly(nativeBinaryPath, ""msvcr120.dll"");
            LoadNativeAssembly(nativeBinaryPath, ""SqlServerSpatial140.dll"");
        }"
"<summary>
Execute a SqlCommand that returns a resultset against the database specified in the connection string
using the provided parameters.
</summary>","public static SqlDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            try
            {
                SqlConnection conn = new SqlConnection(connectionString);
                    PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                    SqlDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                    cmd.Parameters.Clear();
                    return rdr;
            }
            catch
            {
                throw;
            }
        }"
"<summary>
Execute a SqlCommand that returns the first column of the first record against the database specified in the connection string
using the provided parameters.
</summary>","public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"<summary>
Execute a SqlCommand that returns the first column of the first record against an existing database connection
using the provided parameters.
</summary>","public static object ExecuteScalar(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
add parameter array to the cache
</summary>","public static void CacheParameters(string cacheKey, params SqlParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"<summary>
Retrieve cached parameters
</summary>","public static SqlParameter[] GetCachedParameters(string cacheKey)
        {
            SqlParameter[] cachedParms = (SqlParameter[])parmCache[cacheKey];
            if (cachedParms"
"<summary>
创建一个IPEndPoint对象
</summary>","public static IPEndPoint CreateIPEndPoint(string ip, int port)
        {
            IPAddress ipAddress = StringToIPAddress(ip);
            return new IPEndPoint(ipAddress, port);
        }"
"<summary>
Copyright (C) Maticsoft
数据访问基础类(基于Oracle)
用户可以修改满足自己项目的需要。
</summary>","public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"<summary>
创建 OracleCommand 对象实例(用来返回一个整数值)
</summary>","private static OracleCommand BuildIntCommand(OracleConnection connection,string storedProcName, IDataParameter[] parameters)
		{
			OracleCommand command = BuildQueryCommand(connection,storedProcName, parameters );
			command.Parameters.Add( new OracleParameter ( ""ReturnValue"",
                OracleType.Int32, 4, ParameterDirection.ReturnValue,
				false,0,0,string.Empty,DataRowVersion.Default,null ));
			return command;
		}"
"<summary>
数据访问类，可用于访问不同数据库
Copyright (C) Maticsoft
</summary>","public bool ColumnExists(string tableName, string columnName)
        {
            string sql = ""select count(1) from syscolumns where [id]=object_id('"" + tableName + ""') and [name]='"" + columnName + ""'"";
            object res = GetSingle(sql);
            if (res"
"<summary>
数据访问抽象基础类
Copyright (C) Maticsoft
</summary>","public static bool ColumnExists(string tableName, string columnName)
        {
            string sql = ""select count(1) from syscolumns where [id]=object_id('"" + tableName + ""') and [name]='"" + columnName + ""'"";
            object res = GetSingle(sql);
            if (res"
"<summary>
Copyright (C) Maticsoft
数据访问基础类(基于OleDb)
可以用户可以修改满足自己项目的需要。
</summary>","public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = DbHelperSQL.GetSingle(strsql);
            if (obj"
"<summary>
数据访问抽象基础类
Copyright (C) Maticsoft
</summary>","public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"<summary>
Copyright (C) 2011 Maticsoft
数据访问基础类(基于SQLite)
可以用户可以修改满足自己项目的需要。
</summary>","public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"<summary>
A helper class used to execute queries against an Oracle database
</summary>","public static int ExecuteNonQuery(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            using (OracleConnection connection = new OracleConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                int val = cmd.ExecuteNonQuery();
                connection.Close();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"<summary>
Execute an OracleCommand (that returns no resultset) against an existing database transaction
using the provided parameters.
</summary>","public static int ExecuteNonQuery(OracleTransaction trans, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, trans.Connection, trans, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
Execute an OracleCommand (that returns no resultset) against an existing database connection
using the provided parameters.
</summary>","public static int ExecuteNonQuery(OracleConnection connection, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
Execute a select query that will return a result set
</summary>","public static OracleDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            OracleConnection conn = new OracleConnection(connectionString);
            try
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                OracleDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                cmd.Parameters.Clear();
                return rdr;
            }
            catch
            {
                conn.Close();
                throw;
            }
        }"
"<summary>
Execute an OracleCommand that returns the first column of the first record against the database specified in the connection string
using the provided parameters.
</summary>","public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            using (OracleConnection conn = new OracleConnection(connectionString))
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"<summary>
Execute	a OracleCommand (that returns a 1x1 resultset)	against	the	specified SqlTransaction
using the provided parameters.
</summary>","public static object ExecuteScalar(OracleTransaction transaction, CommandType commandType, string commandText, params OracleParameter[] commandParameters)
        {
            if (transaction"
"<summary>
Execute an OracleCommand that returns the first column of the first record against an existing database connection
using the provided parameters.
</summary>","public static object ExecuteScalar(OracleConnection connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, connectionString, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
Add a set of parameters to the cached
</summary>","public static void CacheParameters(string cacheKey, params OracleParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"<summary>
Fetch parameters from the cache
</summary>","public static OracleParameter[] GetCachedParameters(string cacheKey)
        {
            OracleParameter[] cachedParms = (OracleParameter[])parmCache[cacheKey];
            if (cachedParms"
"<summary>
Converter to use boolean data type with Oracle
</summary>","public static string OraBit(bool value)
        {
            if (value)
                return ""Y"";
            else
                return ""N"";
        }"
"<summary>
Converter to use boolean data type with Oracle
</summary>","public static bool OraBool(string value)
        {
            if (value.Equals(""Y""))
                return true;
            else
                return false;
        }"
"<summary>
The SqlHelper class is intended to encapsulate high performance,
scalable best practices for common uses of SqlClient.
</summary>","public static int ExecuteNonQuery(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection conn = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                int val = cmd.ExecuteNonQuery();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"<summary>
Execute a SqlCommand (that returns no resultset) against an existing database connection
using the provided parameters.
</summary>","public static int ExecuteNonQuery(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
Execute a SqlCommand (that returns no resultset) using an existing SQL Transaction
using the provided parameters.
</summary>","public static int ExecuteNonQuery(SqlTransaction trans, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, trans.Connection, trans, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
Execute a SqlCommand that returns a resultset against the database specified in the connection string
using the provided parameters.
</summary>","public static SqlDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            SqlConnection conn = new SqlConnection(connectionString);
            try
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                SqlDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                cmd.Parameters.Clear();
                return rdr;
            }
            catch
            {
                conn.Close();
                throw;
            }
        }"
"<summary>
Execute a SqlCommand that returns the first column of the first record against the database specified in the connection string
using the provided parameters.
</summary>","public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"<summary>
Execute a SqlCommand that returns the first column of the first record against an existing database connection
using the provided parameters.
</summary>","public static object ExecuteScalar(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"<summary>
add parameter array to the cache
</summary>","public static void CacheParameters(string cacheKey, params SqlParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"<summary>
Retrieve cached parameters
</summary>","public static SqlParameter[] GetCachedParameters(string cacheKey)
        {
            SqlParameter[] cachedParms = (SqlParameter[])parmCache[cacheKey];
            if (cachedParms"
"<summary>
Prepare a command for execution
</summary>","private static void PrepareCommand(SqlCommand cmd, SqlConnection conn, SqlTransaction trans, CommandType cmdType, string cmdText, SqlParameter[] cmdParms)
        {
            if (conn.State != ConnectionState.Open)
                conn.Open();
            cmd.Connection = conn;
            cmd.CommandText = cmdText;
            if (trans != null)
                cmd.Transaction = trans;
            cmd.CommandType = cmdType;
            if (cmdParms != null)
            {
                foreach (SqlParameter parm in cmdParms)
                    cmd.Parameters.Add(parm);
            }
        }"
"<summary>
DataTable转换为Json
</summary>","public static string ToJson(DataTable dt, string jsonName)
        {
            StringBuilder Json = new StringBuilder();
            if (string.IsNullOrEmpty(jsonName)) jsonName = dt.TableName;
            Json.Append(""{\"""" + jsonName + ""\"":["");
            if (dt.Rows.Count > 0)
            {
                for (int i = 0; i < dt.Rows.Count; i++)
                {
                    Json.Append(""{"");
                    for (int j = 0; j < dt.Columns.Count; j++)
                    {
                        Type type = dt.Rows[i][j].GetType();
                        Json.Append(""\"""" + dt.Columns[j].ColumnName.ToString() + ""\"":"" + StringFormat(dt.Rows[i][j].ToString(), type));
                        if (j < dt.Columns.Count - 1)
                        {
                            Json.Append("","");
                        }
                    }
                    Json.Append(""}"");
                    if (i < dt.Rows.Count - 1)
                    {
                        Json.Append("","");
                    }
                }
            }
            Json.Append(""]}"");
            return Json.ToString();
        }"
"<summary>
Datatable转换为Json 2
</summary>","public static List<Dictionary<string, object>> DataTableToDictionary(DataTable dt)
        {
            List<Dictionary<string, object>> list = new List<Dictionary<string, object>>();
            foreach (DataRow dr in dt.Rows)
            {
                Dictionary<string, object> result = new Dictionary<string, object>();
                foreach (DataColumn dc in dt.Columns)
                {
                    result.Add(dc.ColumnName, dr[dc].ToString());
                }
                list.Add(result);
            }
            return list;
        }"
"<summary>
字符串操作类
1、GetStrArray(string str, char speater, bool toLower)  把字符串按照分隔符转换成 List
2、GetStrArray(string str) 把字符串转 按照, 分割 换为数据
3、GetArrayStr(List list, string speater) 把 List 按照分隔符组装成 string
4、GetArrayStr(List list)  得到数组列表以逗号分隔的字符串
5、GetArrayValueStr(Dictionary<int, int> list)得到数组列表以逗号分隔的字符串
6、DelLastComma(string str)删除最后结尾的一个逗号
7、DelLastChar(string str, string strchar)删除最后结尾的指定字符后的字符
8、ToSBC(string input)转全角的函数(SBC case)
9、ToDBC(string input)转半角的函数(SBC case)
10、GetSubStringList(string o_str, char sepeater)把字符串按照指定分隔符装成 List 去除重复
11、GetCleanStyle(string StrList, string SplitString)将字符串样式转换为纯字符串
12、GetNewStyle(string StrList, string NewStyle, string SplitString, out string Error)将字符串转换为新样式
13、SplitMulti(string str, string splitstr)分割字符串
14、SqlSafeString(string String, bool IsDel)
</summary>","public static List<string> GetStrArray(string str, char speater, bool toLower)
        {
            List<string> list = new List<string>();
            string[] ss = str.Split(speater);
            foreach (string s in ss)
            {
                if (!string.IsNullOrEmpty(s) && s != speater.ToString())
                {
                    string strVal = s;
                    if (toLower)
                    {
                        strVal = s.ToLower();
                    }
                    list.Add(strVal);
                }
            }
            return list;
        }"
"<summary>
Create the CAPTCHA specified Length, Sleep and List.
</summary>","private static string Create(int Length, bool Sleep, char[] List)
		{
			if (Sleep) Thread.Sleep(3);
			char[] Pattern = List;
			string result = string.Empty;
			int n = Pattern.Length;
			for (int i = 0; i < Length; i++)
			{
				int rnd = Random.Next(0, n);
				result += Pattern[rnd];
			}
			return result;
		}"
"<summary>
讲枚举绑定在DropDownList上
</summary>","public static void BindDropDownList_Replace(DropDownList list, Type TypeEnum)
       {
           List<ListItem> TypeList = new List<ListItem>();
           foreach (object type in Enum.GetValues(TypeEnum))
           {
               string str=type.ToString();
               if (str.Contains('N') || str.Contains('D') || str.Contains('G')||str.Contains('M')||str.Contains('Q'))
               {
                   str=str.Replace(""N"", ""$"");
                   str=str.Replace(""D"", "","");
                   str=str.Replace(""G"", "" - "");
                   str = str.Replace(""M"", ""."");
                   str = str.Replace(""Q"", """");
               }
               TypeList.Add(new ListItem(str, ((int)type).ToString()));
           }
           list.DataSource = TypeList;
           list.DataTextField = ""text"";
           list.DataValueField = ""value"";
           list.DataBind();
       }"
"<summary>
This command represents the Pop3 RSET command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Rset);
        }"
"<summary>
This class represents both the multiline and single line Pop3 LIST command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            string requestMessage = Pop3Commands.List;
            if (!IsMultiline)
            {
                requestMessage += _messageId.ToString();
            } 
            return GetRequestMessage(requestMessage, Pop3Commands.Crlf);
        }"
"<summary>
Creates the response.
</summary>","protected override ListResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            List<Pop3ListItem> items;
            if (IsMultiline)
            {
                items = new List<Pop3ListItem>();
                string[] values;
                string[] lines = GetResponseLines(StripPop3HostMessage(buffer, response.HostMessage));
                foreach (string line in lines)
                {
                    values = line.Split(' ');
                    if (values.Length < 2)
                    {
                        throw new Pop3Exception(string.Concat(""Invalid line in multiline response:  "", line));
                    }
                    items.Add(new Pop3ListItem(Convert.ToInt32(values[0]),
                        Convert.ToInt64(values[1])));
                }
            } 
            else
            {
                items = new List<Pop3ListItem>(1);
                string[] values = response.HostMessage.Split(' ');
                if (values.Length < 3)
                {
                    throw new Pop3Exception(string.Concat(""Invalid response message: "", response.HostMessage));
                }
                items.Add(new Pop3ListItem(Convert.ToInt32(values[1]), Convert.ToInt64(values[2])));
            } 
            return new ListResponse(response, items);
        }"
"<summary>
This command represents a Pop3 USER command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.User, _username, Pop3Commands.Crlf);
        }"
"<summary>
This class represents the Pop3 QUIT command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Quit);
        }"
"<summary>
This class represents the Pop3 PASS command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Pass, _password, Pop3Commands.Crlf);
        }"
"<summary>
This class represents the Pop3 STAT command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Stat);
        }"
"<summary>
Creates the response.
</summary>","protected override StatResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            string[] values = response.HostMessage.Split(' ');
            if (values.Length < 3)
            {
                throw new Pop3Exception(string.Concat(""Invalid response message: "", response.HostMessage));
            }
            int messageCount = Convert.ToInt32(values[1]);
            long octets = Convert.ToInt64(values[2]);
            return new StatResponse(response, messageCount, octets);
        }"
"<summary>
This class represents the Pop3 NOOP command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Noop);
        }"
"<summary>
This class represents the Pop3 RETR command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Retr, _message.ToString(), Pop3Commands.Crlf);
        }"
"<summary>
Creates the response.
</summary>","protected override RetrResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            string[] messageLines = GetResponseLines(StripPop3HostMessage(buffer, response.HostMessage));
            return new RetrResponse(response, messageLines);
        }"
"<summary>
This class represents a Pop3 response message and
is intended to be used as a base class for all other
Pop3Response types.
</summary>","public static Pop3Response CreateResponse(byte[] responseContents)
        {
            string hostMessage;
            MemoryStream stream = new MemoryStream(responseContents);
            using (StreamReader reader = new StreamReader(stream))
            {
                hostMessage = reader.ReadLine();
                if (hostMessage"
"<summary>
Performs the connect to a Pop3 server and returns a Pop3
response indicating the attempt to connect results and the
network stream to use for all subsequent Pop3 Commands.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return null;
        }"
"<summary>
Executes this instance.
</summary>","internal override ConnectResponse Execute(Pop3State currentState)
        {
            EnsurePop3State(currentState);
            try
            {
                _client.Connect(_hostname, _port);
                SetClientStream();
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(string.Format(""Unable to connect to {0}:{1}."", _hostname, _port), e);
            }
            return base.Execute(currentState);
        }"
"<summary>
Sets the client stream.
</summary>","private void SetClientStream()
        {
            if (_useSsl)
            {
                try
                {
                    NetworkStream = new SslStream(_client.GetStream(), true); 
                    ((SslStream)NetworkStream).AuthenticateAsClient(_hostname);
                }
                catch (ArgumentException e)
                {
                    throw new Pop3Exception(""Unable to create Ssl Stream for hostname: "" + _hostname, e);
                }
                catch (AuthenticationException e)
                {
                    throw new Pop3Exception(""Unable to authenticate ssl stream for hostname: "" + _hostname, e);
                }
                catch (InvalidOperationException e)
                {
                    throw new Pop3Exception(""There was a problem  attempting to authenticate this SSL stream for hostname: "" + _hostname, e);
                }
            } 
            else
            {
                NetworkStream = _client.GetStream();
            }
        }"
"<summary>
Creates the response.
</summary>","protected override ConnectResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            return new ConnectResponse(response, NetworkStream);
        }"
"<summary>
Initializes a new instance of the <see cref=""TopCommand""/> class.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Top, _messageNumber.ToString(), "" "", _lineCount.ToString(), Pop3Commands.Crlf);
        }"
"<summary>
Creates the response.
</summary>","protected override RetrResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            if (response"
"<summary>
This class represents a generic Pop3 command and
encapsulates the major operations when executing a
Pop3 command against a Pop3 Server.
</summary>","protected void OnTrace(string message)
        {
            if (Trace != null)
            {
                Trace(message);
            }
        }"
"<summary>
Sets a value indicating whether this instance is multiline.
</summary>","protected abstract byte[] CreateRequestMessage();
        private void Send(byte[] message)
        {
            try
            {
                _networkStream.Write(message, 0, message.Length);
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(""Unable to send the request message: "" + Encoding.ASCII.GetString(message), e);
            }
        }"
"<summary>
Executes this instance.
</summary>","internal virtual T Execute(Pop3State currentState)
        {
            EnsurePop3State(currentState);
            byte[] message = CreateRequestMessage();
            if (message != null)
            {
                Send(message);
            }
            T response = CreateResponse(GetResponse());
            if (response"
"<summary>
Ensures the state of the POP3.
</summary>","protected void EnsurePop3State(Pop3State currentState)
        {
            if (!((currentState & ValidExecuteState)"
"<summary>
Creates the response.
</summary>","protected virtual T CreateResponse(byte[] buffer)
        {
            return Pop3Response.CreateResponse(buffer) as T;
        }"
"<summary>
Gets the response.
</summary>","private byte[] GetResponse()
        {
            AsyncCallback callback;
            if (_isMultiline)
            {
                callback = new AsyncCallback(GetMultiLineResponseCallback);
            }
            else
            {
                callback = new AsyncCallback(GetSingleLineResponseCallback);
            }
            try
            {
                Receive(callback);
                _manualResetEvent.WaitOne();
                return _responseContents.ToArray();
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(""Unable to get response."", e);
            }
        }"
"<summary>
Receives the specified callback.
</summary>","private IAsyncResult Receive(AsyncCallback callback)
        {
            return _networkStream.BeginRead(_buffer, 0, _buffer.Length, callback, null);
        }"
"<summary>
Writes the received bytes to buffer.
</summary>","private string WriteReceivedBytesToBuffer(int bytesReceived)
        {
            _responseContents.Write(_buffer, 0, bytesReceived);
            byte[] contents = _responseContents.ToArray();
            return Encoding.ASCII.GetString(contents, (contents.Length > 5 ? contents.Length - 5 : 0), 5);
        }"
"<summary>
Gets the single line response callback.
</summary>","private void GetSingleLineResponseCallback(IAsyncResult ar)
        {
            int bytesReceived = _networkStream.EndRead(ar);
            string message = WriteReceivedBytesToBuffer(bytesReceived);
            if (message.EndsWith(Pop3Commands.Crlf))
            {
                _manualResetEvent.Set();
            }
            else
            {
                Receive(new AsyncCallback(GetSingleLineResponseCallback));
            }
        }"
"<summary>
Gets the multi line response callback.
</summary>","private void GetMultiLineResponseCallback(IAsyncResult ar)
        {
            int bytesReceived = _networkStream.EndRead(ar);
            string message = WriteReceivedBytesToBuffer(bytesReceived);
            if (message.EndsWith(MultilineMessageTerminator)
                || bytesReceived"
"<summary>
Gets the request message.
</summary>","protected byte[] GetRequestMessage(params string[] args)
        {
            string message = string.Join(string.Empty, args);
            OnTrace(message);
            return Encoding.ASCII.GetBytes(message);
        }"
"<summary>
Strips the POP3 host message.
</summary>","protected MemoryStream StripPop3HostMessage(byte[] bytes, string header)
        {
            int position = header.Length + 2;
            MemoryStream stream = new MemoryStream(bytes, position, bytes.Length - position);
            return stream;
        }"
"<summary>
Gets the response lines.
</summary>","protected string[] GetResponseLines(MemoryStream stream)
        {
            List<string> lines = new List<string>();
            using (StreamReader reader = new StreamReader(stream))
            {
                try
                {
                    string line;
                    do
                    {
                        line = reader.ReadLine();
                        if (line.StartsWith(MessageTerminator))
                        {
                            if (line"
"<summary>
This class represents the Pop3 DELE command.
</summary>","protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(string.Concat(Pop3Commands.Dele, _messageId.ToString(), Pop3Commands.Crlf));
        }"
"<summary>
The Pop3Client class provides a wrapper for the Pop3 commands
that can be executed against a Pop3Server.  This class will
execute and return results for the various commands that are
executed.
</summary>","private void OnTrace(string message)
        {
            if (Trace != null)
            {
                Trace(message);
            }
        }"
"<summary>
Gets the hostname.
</summary>","private void EnsureConnection()
        {
            if (!_client.Connected)
            {
                throw new Pop3Exception(""Pop3 client is not connected."");
            }
        }"
"<summary>
Resets the state.
</summary>","private void SetState(Pop3State state)
        {
            _currentState = state;
        }"
"<summary>
Ensures the response.
</summary>","private void EnsureResponse(Pop3Response response, string error)
        {
            if (response"
"<summary>
Ensures the response.
</summary>","private void EnsureResponse(Pop3Response response)
        {
            EnsureResponse(response, string.Empty);
        }"
"<summary>
Traces the command.
</summary>","private void Connect()
        {
            if (_client"
"<summary>
Sets the client stream.  If UseSsl <c>true</c> then wrap
the client's <c>NetworkStream</c> in an <c>SslStream</c>, if UseSsl <c>false</c>
then set the client stream to the <c>NetworkStream</c>
</summary>","private void SetClientStream(Stream networkStream)
        {
            if (_clientStream != null)
            {
                _clientStream.Dispose();
            }
            _clientStream = networkStream;
        }"
"<summary>
Authenticates this instance.
</summary>","public void Authenticate()
        {
            Connect();
            using (UserCommand userCommand = new UserCommand(_clientStream, _username))
            {
                ExecuteCommand<Pop3Response, UserCommand>(userCommand);
            }
            using (PassCommand passCommand = new PassCommand(_clientStream, _password))
            {
                ExecuteCommand<Pop3Response, PassCommand>(passCommand);
            }
            _currentState = Pop3State.Transaction;
        }"
"<summary>
Executes the POP3 DELE command.
</summary>","public void Dele(Pop3ListItem item)
        {
            if (item"
"<summary>
Executes the POP3 NOOP command.
</summary>","public void Noop()
        {
            using (NoopCommand command = new NoopCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, NoopCommand>(command);
            }
        }"
"<summary>
Executes the POP3 RSET command.
</summary>","public void Rset()
        {
            using (RsetCommand command = new RsetCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, RsetCommand>(command);
            }
        }"
"<summary>
Executes the POP3 STAT command.
</summary>","public Stat Stat()
        {
            StatResponse response;
            using (StatCommand command = new StatCommand(_clientStream))
            {
                response = ExecuteCommand<StatResponse, StatCommand>(command);
            }
            return new Stat(response.MessageCount, response.Octets);
        }"
"<summary>
Executes the POP3 List command.
</summary>","public List<Pop3ListItem> List()
        {
            ListResponse response;
            using (ListCommand command = new ListCommand(_clientStream))
            {
                response = ExecuteCommand<ListResponse, ListCommand>(command);
            }
            return response.Items;
        }"
"<summary>
Lists the specified message.
</summary>","public Pop3ListItem List(int messageId)
        {
            ListResponse response;
            using (ListCommand command = new ListCommand(_clientStream, messageId))
            {
                response = ExecuteCommand<ListResponse, ListCommand>(command);
            }
            return new Pop3ListItem(response.MessageNumber, response.Octets);
        }"
"<summary>
Retrs the specified message.
</summary>","public MimeEntity RetrMimeEntity(Pop3ListItem item)
        {
            if (item"
"<summary>
Retrs the mail message ex.
</summary>","public MailMessageEx RetrMailMessageEx(Pop3ListItem item)
        {
            MailMessageEx message = RetrMimeEntity(item).ToMailMessageEx();
            if (message != null)
            {
                message.MessageNumber = item.MessageId;
            }
            return message;
        }"
"<summary>
Executes the Pop3 QUIT command.
</summary>","public void Quit()
        {
            using (QuitCommand command = new QuitCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, QuitCommand>(command);
                if (CurrentState.Equals(Pop3State.Transaction))
                {
                    SetState(Pop3State.Update);
                } 
                Disconnect();
                SetState(Pop3State.Unknown);
            }
        }"
"<summary>
Provides a common way to execute all commands.  This method
validates the connection, traces the command and finally
validates the response message for a -ERR response.
</summary>","private void Disconnect()
        {
            if (_clientStream != null)
            {
                _clientStream.Close();
            }  
            if (_client != null)
            {
                _client.Close();
                _client = null;
            }
        }"
<summary>Queues a user work item to the thread pool.</summary>,"public static void QueueUserWorkItem(WaitCallback callback)
        {
            QueueUserWorkItem(callback, null);
        }"
<summary>Queues a user work item to the thread pool.</summary>,"public static void QueueUserWorkItem(WaitCallback callback, object state)
        {
            WaitingCallback waiting = new WaitingCallback(callback, state);
            lock (_poolLock) { _waitingCallbacks.Enqueue(waiting); }
            _workerThreadNeeded.AddOne();
        }"
<summary>Empties the work queue of any queued work items.  Resets all threads in the pool.</summary>,"public static void Reset()
        {
            lock (_poolLock)
            {
                try
                {
                    foreach (object obj in _waitingCallbacks)
                    {
                        WaitingCallback callback = (WaitingCallback)obj;
                        if (callback.State is IDisposable) ((IDisposable)callback.State).Dispose();
                    }
                }
                catch { }
                try
                {
                    foreach (Thread thread in _workerThreads)
                    {
                        if (thread != null) thread.Abort(""reset"");
                    }
                }
                catch { }
                Initialize();
            }
        }"
<summary>Gets the number of threads at the disposal of the thread pool.</summary>,"private static void ProcessQueuedItems()
        {
            while (true)
            {
                _workerThreadNeeded.WaitOne();
                WaitingCallback callback = null;
                lock (_poolLock)
                {
                    if (_waitingCallbacks.Count > 0)
                    {
                        try { callback = (WaitingCallback)_waitingCallbacks.Dequeue(); }
                        catch { } 
                    }
                }
                if (callback != null)
                {
                    try
                    {
                        Interlocked.Increment(ref _inUseThreads);
                        callback.Callback(callback.State);
                    }
                    catch (Exception)
                    {
                    }
                    finally
                    {
                        Interlocked.Decrement(ref _inUseThreads);
                    }
                }
            }
        }"
<summary>P the semaphore (take out 1 unit from it).</summary>,"public void P()
        {
            lock (_semLock)
            {
                while (_count <= 0) Monitor.Wait(_semLock, Timeout.Infinite);
                _count--;
            }
        }"
<summary>V the semaphore (add 1 unit to it).</summary>,"public void V()
        {
            lock (_semLock)
            {
                _count++;
                Monitor.Pulse(_semLock);
            }
        }"
<summary>Resets the semaphore to the specified count.  Should be used cautiously.</summary>,"public void Reset(int count)
        {
            lock (_semLock) { _count = count; }
        }"
"<summary>
Summary description for GridViewExport
</summary>","public static void Export(string fileName, GridView gv)
        {
            HttpContext.Current.Response.Clear();
            HttpContext.Current.Response.AddHeader(
                ""content-disposition"", string.Format(""attachment; filename={0}"", fileName));
            HttpContext.Current.Response.ContentType = ""application/ms-excel"";
            using (StringWriter sw = new StringWriter())
            {
                using (HtmlTextWriter htw = new HtmlTextWriter(sw))
                {
                    Table table = new Table();
                    table.GridLines = GridLines.Both;  
                    if (gv.HeaderRow != null)
                    {
                        PrepareControlForExport(gv.HeaderRow);
                        table.Rows.Add(gv.HeaderRow);
                    }
                    foreach (GridViewRow row in gv.Rows)
                    {
                        PrepareControlForExport(row);
                        table.Rows.Add(row);
                    }
                    if (gv.FooterRow != null)
                    {
                        PrepareControlForExport(gv.FooterRow);
                        table.Rows.Add(gv.FooterRow);
                    }
                    table.RenderControl(htw);
                    HttpContext.Current.Response.Write(sw.ToString());
                    HttpContext.Current.Response.End();
                }
            }
        }"
"<summary>
Replace any of the contained controls with literals
</summary>","private static void PrepareControlForExport(Control control)
        {
            for (int i = 0; i < control.Controls.Count; i++)
            {
                Control current = control.Controls[i];
                if (current is LinkButton)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as LinkButton).Text));
                }
                else if (current is ImageButton)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as ImageButton).AlternateText));
                }
                else if (current is HyperLink)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as HyperLink).Text));
                }
                else if (current is DropDownList)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as DropDownList).SelectedItem.Text));
                }
                else if (current is CheckBox)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as CheckBox).Checked ? ""True"" : ""False""));
                }
                if (current.HasControls())
                {
                    PrepareControlForExport(current);
                }
            }
        }"
"<summary>
验证码 继承 System.Web.UI.Page ，Session[""xk_validate_code""]
</summary>","private void Page_Load(object sender, EventArgs e)
        {
            char[] chars = ""023456789"".ToCharArray();
            System.Random random = new Random();
            string validateCode = string.Empty;
            for (int i = 0; i < 4; i++)
            {
                char rc = chars[random.Next(0, chars.Length)];
                if (validateCode.IndexOf(rc) > -1)
                {
                    i--;
                    continue;
                }
                validateCode += rc;
            }
            Session[""xk_validate_code""] = validateCode;
            CreateImage(validateCode);
        }"
"<summary>
Generates the check code with unique number.
</summary>","public string GenerateCheckCodeNum(int codeCount)
        {
            codeCount = codeCount > 10 ? 10 :codeCount;   
            int[] arrInt = {0,1,2,3,4,5,6,7,8,9};
		    arrInt = arrInt.OrderBy(c => Guid.NewGuid()).ToArray<int>();
            string str = string.Empty;
            for (int i = 0; i < codeCount; i++)
            {
                str += arrInt[i];
            }
            return str;
        }"
"<summary>
Generates the check code with number and char
</summary>","public string GenerateCheckCode(int CodeCount)
        {
            char[] MixedList = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I','J', 'K', 'L', 'M', 'N','O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' }; 
			return GetRandomCode(MixedList, CodeCount);
		}"
"<summary>
Gets the random code.
</summary>","private string GetRandomCode(char[] CharList, int CodeLength)
        {
			string result = string.Empty;
			for (int i = 0; i < CodeLength; i++)
			{
				int rnd = Random.Next(0, CharList.Length);
				result += CharList[rnd];
			}
			return result;
        }"
"<summary>
Utility methods related to CLR Types for SQL Server
</summary>","private static extern IntPtr LoadLibrary(string libname);
        public static void LoadNativeAssemblies(string rootApplicationPath)
        {
            var nativeBinaryPath = IntPtr.Size > 4
                ? Path.Combine(rootApplicationPath, @""SqlServerTypes\x64\"")
                : Path.Combine(rootApplicationPath, @""SqlServerTypes\x86\"");
            LoadNativeAssembly(nativeBinaryPath, ""msvcr120.dll"");
            LoadNativeAssembly(nativeBinaryPath, ""SqlServerSpatial140.dll"");
        }"
"<summary>
This class is responsible for parsing a string array of lines
containing a MIME message.
</summary>","private int ParseHeaders()
        {
            string lastHeader = string.Empty;
            string line = string.Empty;
            while (_lines.Count > 0 && !string.IsNullOrEmpty(_lines.Peek()))
            {
                line = _lines.Dequeue();
                if (line.StartsWith("" "") || line.StartsWith(Convert.ToString('\t')))
                {
                    _entity.Headers[lastHeader] = string.Concat(_entity.Headers[lastHeader], line);
                    continue;
                }
                int separatorIndex = line.IndexOf(':');
                if (separatorIndex < 0)
                {
                    System.Diagnostics.Debug.WriteLine(""Invalid header:{0}"", line);
                    continue;
                }  
                string headerName = line.Substring(0, separatorIndex);
                string headerValue = line.Substring(separatorIndex + 1).Trim(HeaderWhitespaceChars);
                _entity.Headers.Add(headerName.ToLower(), headerValue);
                lastHeader = headerName;
            }
            if (_lines.Count > 0)
            {
                _lines.Dequeue();
            } 
            return _entity.Headers.Count;
        }"
"<summary>
Processes mime specific headers.
</summary>","private void ProcessHeaders()
        {
            foreach (string key in _entity.Headers.AllKeys)
            {
                switch (key)
                {
                    case ""content-description"":
                        _entity.ContentDescription = _entity.Headers[key];
                        break;
                    case ""content-disposition"":
                        _entity.ContentDisposition = new ContentDisposition(_entity.Headers[key]);
                        break;
                    case ""content-id"":
                        _entity.ContentId = _entity.Headers[key];
                        break;
                    case ""content-transfer-encoding"":
                        _entity.TransferEncoding = _entity.Headers[key];
                        _entity.ContentTransferEncoding = MimeReader.GetTransferEncoding(_entity.Headers[key]);
                        break;
                    case ""content-type"":
                        _entity.SetContentType(MimeReader.GetContentType(_entity.Headers[key]));
                        break;
                    case ""mime-version"":
                        _entity.MimeVersion = _entity.Headers[key];
                        break;
                }
            }
        }"
"<summary>
Creates the MIME entity.
</summary>","public MimeEntity CreateMimeEntity()
        {
            try
            {
                ParseHeaders();
                ProcessHeaders();
                ParseBody();
                SetDecodedContentStream();
                return _entity;
            }
            catch
            {
                return null;
            }
        }"
"<summary>
Sets the decoded content stream by decoding the EncodedMessage
and writing it to the entity content stream.
</summary>","private void SetDecodedContentStream()
        {
            switch (_entity.ContentTransferEncoding)
            {
                case System.Net.Mime.TransferEncoding.Base64:
                    _entity.Content = new MemoryStream(Convert.FromBase64String(_entity.EncodedMessage.ToString()), false);
                    break;
                case System.Net.Mime.TransferEncoding.QuotedPrintable:
                    _entity.Content = new MemoryStream(GetBytes(QuotedPrintableEncoding.Decode(_entity.EncodedMessage.ToString())), false);
                    break;
                case System.Net.Mime.TransferEncoding.SevenBit:
                default:
                    _entity.Content = new MemoryStream(GetBytes(_entity.EncodedMessage.ToString()), false);
                    break;
            }
        }"
"<summary>
Gets a byte[] of content for the provided string.
</summary>","private byte[] GetBytes(string content)
        {
            using (MemoryStream stream = new MemoryStream())
            {
                using (StreamWriter writer = new StreamWriter(stream))
                {
                    writer.Write(content);
                }
                return stream.ToArray();
            }
        }"
"<summary>
Parses the body.
</summary>","private void ParseBody()
        {
            if (_entity.HasBoundary)
            {
                while (_lines.Count > 0
                    && !string.Equals(_lines.Peek(), _entity.EndBoundary))
                {
                    if (_entity.Parent != null
                        && string.Equals(_entity.Parent.StartBoundary, _lines.Peek()))
                    {
                        return;
                    }
                    if (string.Equals(_lines.Peek(), _entity.StartBoundary))
                    {
                        AddChildEntity(_entity, _lines);
                    } 
                    else if (string.Equals(_entity.ContentType.MediaType, MediaTypes.MessageRfc822, StringComparison.InvariantCultureIgnoreCase)
                        && string.Equals(_entity.ContentDisposition.DispositionType, DispositionTypeNames.Attachment, StringComparison.InvariantCultureIgnoreCase))
                    {
                        AddChildEntity(_entity, _lines);
                        break;
                    }
                    else
                    {
                        _entity.EncodedMessage.Append(string.Concat(_lines.Dequeue(), Pop3Commands.Crlf));
                    } 
                }
            } 
            else
            {
                while (_lines.Count > 0)
                {
                    _entity.EncodedMessage.Append(string.Concat(_lines.Dequeue(), Pop3Commands.Crlf));
                }
            } 
        }"
"<summary>
Adds the child entity.
</summary>","private void AddChildEntity(MimeEntity entity, Queue<string> lines)
        {"
"<summary>
Gets the type of the content.
</summary>","public static ContentType GetContentType(string contentType)
        {
            if (string.IsNullOrEmpty(contentType))
            {
                contentType = ""text/plain; charset=us-ascii"";
            }
            return new ContentType(contentType);
        }"
"<summary>
Gets the type of the media.
</summary>","public static string GetMediaType(string mediaType)
        {
            if (string.IsNullOrEmpty(mediaType))
            {
                return ""text/plain"";
            }
            return mediaType.Trim();
        }"
"<summary>
Gets the type of the media main.
</summary>","public static string GetMediaMainType(string mediaType)
        {
            int separatorIndex = mediaType.IndexOf('/');
            if (separatorIndex < 0)
            {
                return mediaType;
            }
            else
            {
                return mediaType.Substring(0, separatorIndex);
            }
        }"
"<summary>
Gets the type of the media sub.
</summary>","public static string GetMediaSubType(string mediaType)
        {
            int separatorIndex = mediaType.IndexOf('/');
            if (separatorIndex < 0)
            {
                if (mediaType.Equals(""text""))
                {
                    return ""plain"";
                }
                return string.Empty;
            }
            else
            {
                if (mediaType.Length > separatorIndex)
                {
                    return mediaType.Substring(separatorIndex + 1);
                }
                else
                {
                    string mainType = GetMediaMainType(mediaType);
                    if (mainType.Equals(""text""))
                    {
                        return ""plain"";
                    }
                    return string.Empty;
                }
            }
        }"
"<summary>
Gets the transfer encoding.
</summary>","public static TransferEncoding GetTransferEncoding(string transferEncoding)
        {
            switch (transferEncoding.Trim().ToLowerInvariant())
            {
                case ""7bit"":
                case ""8bit"":
                    return System.Net.Mime.TransferEncoding.SevenBit;
                case ""quoted-printable"":
                    return System.Net.Mime.TransferEncoding.QuotedPrintable;
                case ""base64"":
                    return System.Net.Mime.TransferEncoding.Base64;
                case ""binary"":
                default:
                    return System.Net.Mime.TransferEncoding.Unknown;
            }
        }"
"<summary>
This class is based on the QuotedPrintable class written by Bill Gearhart
found at http://www.aspemporium.com/classes.aspx?cid=6
</summary>","public static string Decode(string contents)
        {
            if (contents"
"<summary>
For ASP.Net applications.

Starts a thread to perform a task at BelowNormal priority on a regular interval.

Meant for long-running ASP.Net apps that never recycle instead of a Windows
Service or cron job.

If the task runs longer than the timer interval, the existing thread is left be
and nothing else happens until the next time the interval fires where the worker
thread is not running.

Cannot handle multiple tasks; if you have multiple tasks to manage, build on top
of this class by adding task registration to a single task that this class runs.

The task is defined as an Action&lt;IntervalTaskContext&gt;, where the argument
it takes is a context object that has a single property: Stopping. If the ASP.Net
app needs to shut down for some reason, and the task is currently running, this
flag will flip to true, and the app will be forcibly torn down by the environment
in 30 seconds. This means the task should check Stopping regularly to see if it
should cut its work short. Note that the 30 seconds is for the entire app to tie
up what it's doing, not just this task - so be conservative.

For more on the ASP.Net App teardown process:
http://msdn.microsoft.com/en-us/library/system.web.hosting.iregisteredobject.stop.aspx
http://haacked.com/archive/2011/10/16/the-dangers-of-implementing-recurring-background-tasks-in-asp-net.aspx
</summary>","public static IntervalTask CreateTask(Action taskAction)
		{
			if (Current != null)
				throw new FieldAccessException(""CreateTask requested, but a task already exists."");
			Current = new IntervalTask(taskAction);
			return Current;
		}"
"<summary>
If the background task timer is running, changes its interval.
If the timer isn't running, starts the timer (and so, the background task).
</summary>","public void SetInterval(int interval)
		{
			intervalTimer.SetInterval(interval);
		}"
"<summary>
Stops the timer. If the background task is running when this is called, it's
left be so it can finish it's work, but will not be woken up to start again
until SetTimerInterval() is called with a positive value.

Convenience method. This has the same effect as calling
SetTimerInterval(Timeout.Infinite);
</summary>","public void StopTimer()
		{
			intervalTimer.Stop();
		}"
"<summary>
Call if the app is shutting down. Should only be called by the ASP.Net container.
</summary>","public void Stop(bool immediate)
		{
			lock (syncLock)
			{
				ShuttingDown = true;
				if (!TaskRunning)
					this.Dispose();
			}
		}"
"<summary>
Stops the Timer, and informs the ASP.Net hosting environment that it doesn't need to wait on the IntervalTask to shut down.
</summary>","public void Dispose()
		{
			StopTimer();
			System.Web.Hosting.HostingEnvironment.UnregisterObject(this);
		}"
"<summary>
A wrapper class for System.Threading.Timer

* Eliminates context object to pass in - just use a closure instead.

* Allows you to check on the current Interval the timer is set to.

* Uses just the one callback per timer - if you need a new callback, make a new TimerInfo.

* Simplifies changing schedule of timer.

* Easier to check on when it ran (check LastFired).
</summary>","public void SetInterval(int milliseconds)
		{
			if (timer"
"<summary>
时间类
1、SecondToMinute(int Second) 把秒转换成分钟
</summary>","public string GetFormatDate(DateTime dt, char Separator)
        {
            if (dt != null && !dt.Equals(DBNull.Value))
            {
                string tem = string.Format(""yyyy{0}MM{1}dd"", Separator, Separator);
                return dt.ToString(tem);
            }
            else
            {
                return GetFormatDate(DateTime.Now, Separator);
            }
        }"
"<summary>
将String转换为DateTime?类型
</summary>","public static string FormatDate(string dateString)
        {
            var dt = ParseToDateValue(dateString);
            if (dt"
"<summary>
DataTable导出到Excel的MemoryStream
</summary>","public static MemoryStream Export(DataTable dtSource, string strHeaderText)
        {
            HSSFWorkbook workbook = new HSSFWorkbook();
            ISheet sheet = workbook.CreateSheet();
            ICellStyle dateStyle = workbook.CreateCellStyle();
            IDataFormat format = workbook.CreateDataFormat();
            dateStyle.DataFormat = format.GetFormat(""yyyy-MM-dd"");
            #region 取得每列的列宽（最大宽度）
            int[] arrColWidth = new int[dtSource.Columns.Count];
            foreach (DataColumn item in dtSource.Columns)
            {
                arrColWidth[item.Ordinal] = Encoding.GetEncoding(936).GetBytes(item.ColumnName.ToString()).Length;
            }
            for (int i = 0; i < dtSource.Rows.Count; i++)
            {
                for (int j = 0; j < dtSource.Columns.Count; j++)
                {
                    int intTemp = Encoding.GetEncoding(936).GetBytes(dtSource.Rows[i][j].ToString()).Length;
                    if (intTemp > arrColWidth[j])
                    {
                        arrColWidth[j] = intTemp;
                    }
                }
            }
            #endregion
            int rowIndex = 0;
            foreach (DataRow row in dtSource.Rows)
            {
                #region 新建表，填充表头，填充列头，样式
                if (rowIndex"
"<summary>
Encrypt 的摘要说明。
</summary>","public static string Encrypt(string original)
        {
            return Encrypt(original, ""kuiyu.net"");
        }"
"<summary>
MySecurity(安全类) 的摘要说明。
</summary>","static public string SEncryptString(string inputStr, string keyStr)
        {
            MySecurity ws = new MySecurity();
            return ws.EncryptString(inputStr, keyStr);
        }"
"<summary>
Remove AppConfig
</summary>","public static void RemoveAppConfig(string key)
        {
            ConfigurationManager.AppSettings.Remove(key);
        }"
"<summary>
读取QueryString值
</summary>","public static string GetQueryString(string queryStringName)
        {
            if ((HttpContext.Current.Request.QueryString[queryStringName] != null) &&
                (HttpContext.Current.Request.QueryString[queryStringName] != ""undefined""))
            {
                return HttpContext.Current.Request.QueryString[queryStringName].Trim();
            }
            else
            {
                return """";
            }
        }"
"<summary>
i.e. /CN=Users,DC=creditsights, DC=cyberelves, DC=Com
</summary>","private static DirectoryEntry GetDirectoryObject(string domainReference)
        {
            DirectoryEntry entry = new DirectoryEntry(ADPath + domainReference, ADUser, ADPassword,
                AuthenticationTypes.Secure);
            return entry;
        }"
"<summary>
获得以UserName,Password创建的DirectoryEntry
</summary>","private static DirectoryEntry GetDirectoryObject(string domainReference,
            string userName, string password)
        {
            DirectoryEntry entry = new DirectoryEntry(ADPath + domainReference,
                userName, password, AuthenticationTypes.Secure);
            return entry;
        }"
"<summary>
重命名Account
</summary>","public static bool RenameAcc(string oldAcc, string newAcc)
        {
            try
            {
                if (IsAccExists(oldAcc))
                {
                    if (IsAccExists(newAcc))
                        return false;
                    DirectoryEntry userEntry = GetDirectoryEntryByAccount(oldAcc);
                    userEntry.Properties[""sAMAccountName""][0] = newAcc;
                    userEntry.CommitChanges();
                    userEntry.Dispose();
                    return true;
                }
                else
                    return false;
            }
            catch (Exception)
            {
                return false;
            }
        }"
"<summary>
Example that shows how you can use custom mappers if you wish the data model and storage schema to differ.
</summary>","public class Step6_Use_CustomMapper(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task UseCustomMapperAsync()
    {
        var recordDefinition = new VectorStoreRecordDefinition
        {
            Properties = new List<VectorStoreRecordProperty>
            {
                new VectorStoreRecordKeyProperty(""Key"", typeof(string)),
                new VectorStoreRecordDataProperty(""Category"", typeof(string)),
                new VectorStoreRecordDataProperty(""Term"", typeof(string)),
                new VectorStoreRecordDataProperty(""Definition"", typeof(string)),
                new VectorStoreRecordVectorProperty(""DefinitionEmbedding"", typeof(ReadOnlyMemory<float>)) { Dimensions = 1536 },
            }
        };
        var collection = new AzureAISearchVectorStoreRecordCollection<ComplexGlossary>(
            new SearchIndexClient(
                new Uri(TestConfiguration.AzureAISearch.Endpoint),
                new AzureKeyCredential(TestConfiguration.AzureAISearch.ApiKey)),
            ""skglossary"",
            new()
            {
                JsonObjectCustomMapper = new CustomMapper(),
                VectorStoreRecordDefinition = recordDefinition
            });
        await collection.CreateCollectionIfNotExistsAsync();
        var definition = ""A set of rules and protocols that allows one software application to interact with another."";
        await collection.UpsertAsync(new ComplexGlossary
        {
            Key = ""1"",
            Metadata = new Metadata
            {
                Category = ""API"",
                Term = ""Application Programming Interface""
            },
            Definition = definition,
            DefinitionEmbedding = await fixture.TextEmbeddingGenerationService.GenerateEmbeddingAsync(definition)
        });
        var searchVector = await fixture.TextEmbeddingGenerationService.GenerateEmbeddingAsync(""How do two software applications interact with another?"");
        var searchResult = await collection.VectorizedSearchAsync(
            searchVector,
            new()
            {
                Top = 1
            });
        var searchResultItem = await searchResult.Results.FirstAsync();
        Console.WriteLine(searchResultItem.Record.Metadata.Term);
        Console.WriteLine(searchResultItem.Record.Definition);
        Console.WriteLine(searchResultItem.Score);
    }
    private sealed class CustomMapper : IVectorStoreRecordMapper<ComplexGlossary, JsonObject>
    {
        public JsonObject MapFromDataToStorageModel(ComplexGlossary dataModel)
        {
            return new JsonObject
            {
                [""Key""] = dataModel.Key,
                [""Category""] = dataModel.Metadata.Category,
                [""Term""] = dataModel.Metadata.Term,
                [""Definition""] = dataModel.Definition,
                [""DefinitionEmbedding""] = JsonSerializer.SerializeToNode(dataModel.DefinitionEmbedding.ToArray())
            };
        }
        public ComplexGlossary MapFromStorageToDataModel(JsonObject storageModel, StorageToDataModelMapperOptions options)
        {
            return new ComplexGlossary
            {
                Key = storageModel[""Key""]!.ToString(),
                Metadata = new Metadata
                {
                    Category = storageModel[""Category""]!.ToString(),
                    Term = storageModel[""Term""]!.ToString()
                },
                Definition = storageModel[""Definition""]!.ToString(),
                DefinitionEmbedding = JsonSerializer.Deserialize<ReadOnlyMemory<float>>(storageModel[""DefinitionEmbedding""])
            };
        }
    }
    private sealed class ComplexGlossary
    {
        public string Key { get; set; }
        public Metadata Metadata { get; set; }
        public string Definition { get; set; }
        public ReadOnlyMemory<float> DefinitionEmbedding { get; set; }
    }
    private sealed class Metadata
    {
        public string Category { get; set; }
        public string Term { get; set; }
    }
}"
"<summary>
Example showing how to generate embeddings and ingest data into an in-memory vector store.
</summary>","public class Step1_Ingest_Data(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task IngestDataIntoInMemoryVectorStoreAsync()
    {
        var vectorStore = new InMemoryVectorStore();
        var collection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        await IngestDataIntoVectorStoreAsync(collection, fixture.TextEmbeddingGenerationService);
        var record = await collection.GetAsync(""4"");
        Console.WriteLine(record!.Definition);
    }
    internal static async Task<IEnumerable<string>> IngestDataIntoVectorStoreAsync(
        IVectorStoreRecordCollection<string, Glossary> collection,
        ITextEmbeddingGenerationService textEmbeddingGenerationService)
    {
        await collection.CreateCollectionIfNotExistsAsync();
        var glossaryEntries = CreateGlossaryEntries().ToList();
        var tasks = glossaryEntries.Select(entry => Task.Run(async () =>
        {
            entry.DefinitionEmbedding = await textEmbeddingGenerationService.GenerateEmbeddingAsync(entry.Definition);
        }));
        await Task.WhenAll(tasks);
        var upsertedKeysTasks = glossaryEntries.Select(x => collection.UpsertAsync(x));
        return await Task.WhenAll(upsertedKeysTasks);
    }
    private static IEnumerable<Glossary> CreateGlossaryEntries()
    {
        yield return new Glossary
        {
            Key = ""1"",
            Category = ""Software"",
            Term = ""API"",
            Definition = ""Application Programming Interface. A set of rules and specifications that allow software components to communicate and exchange data.""
        };
        yield return new Glossary
        {
            Key = ""2"",
            Category = ""Software"",
            Term = ""SDK"",
            Definition = ""Software development kit. A set of libraries and tools that allow software developers to build software more easily.""
        };
        yield return new Glossary
        {
            Key = ""3"",
            Category = ""SK"",
            Term = ""Connectors"",
            Definition = ""Semantic Kernel Connectors allow software developers to integrate with various services providing AI capabilities, including LLM, AudioToText, TextToAudio, Embedding generation, etc.""
        };
        yield return new Glossary
        {
            Key = ""4"",
            Category = ""SK"",
            Term = ""Semantic Kernel"",
            Definition = ""Semantic Kernel is a set of libraries that allow software developers to more easily develop applications that make use of AI experiences.""
        };
        yield return new Glossary
        {
            Key = ""5"",
            Category = ""AI"",
            Term = ""RAG"",
            Definition = ""Retrieval Augmented Generation - a term that refers to the process of retrieving additional data to provide as context to an LLM to use when generating a response (completion) to a user’s question (prompt).""
        };
        yield return new Glossary
        {
            Key = ""6"",
            Category = ""AI"",
            Term = ""LLM"",
            Definition = ""Large language model. A type of artificial ingelligence algorithm that is designed to understand and generate human language.""
        };
    }
}"
"<summary>
Example showing how to do vector searches with an in-memory vector store.
</summary>","public class Step2_Vector_Search(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task SearchAnInMemoryVectorStoreAsync()
    {
        var collection = await GetVectorStoreCollectionWithDataAsync();
        var searchResultItem = await SearchVectorStoreAsync(
            collection,
            ""What is an Application Programming Interface?"",
            fixture.TextEmbeddingGenerationService);
        Console.WriteLine(searchResultItem.Record.Definition);
        Console.WriteLine(searchResultItem.Score);
    }
    internal static async Task<VectorSearchResult<Glossary>> SearchVectorStoreAsync(IVectorStoreRecordCollection<string, Glossary> collection, string searchString, ITextEmbeddingGenerationService textEmbeddingGenerationService)
    {
        var searchVector = await textEmbeddingGenerationService.GenerateEmbeddingAsync(searchString);
        var searchResult = await collection.VectorizedSearchAsync(
            searchVector,
            new()
            {
                Top = 1
            });
        var searchResultItems = await searchResult.Results.ToListAsync();
        return searchResultItems.First();
    }
    [Fact]
    public async Task SearchAnInMemoryVectorStoreWithFilteringAsync()
    {
        var collection = await GetVectorStoreCollectionWithDataAsync();
        var searchString = ""How do I provide additional context to an LLM?"";
        var searchVector = await fixture.TextEmbeddingGenerationService.GenerateEmbeddingAsync(searchString);
        var searchResult = await collection.VectorizedSearchAsync(
            searchVector,
            new()
            {
                Top = 1,
                Filter = new VectorSearchFilter().EqualTo(nameof(Glossary.Category), ""AI"")
            });
        var searchResultItems = await searchResult.Results.ToListAsync();
        Console.WriteLine(searchResultItems.First().Record.Definition);
        Console.WriteLine(searchResultItems.First().Score);
    }
    private async Task<IVectorStoreRecordCollection<string, Glossary>> GetVectorStoreCollectionWithDataAsync()
    {
        var vectorStore = new InMemoryVectorStore();
        var collection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        await Step1_Ingest_Data.IngestDataIntoVectorStoreAsync(collection, fixture.TextEmbeddingGenerationService);
        return collection;
    }
}"
"<summary>
Example that shows that you can use the generic data model to interact with a vector database.
This makes it possible to use the vector store abstractions without having to create your own data model.
</summary>","public class Step5_Use_GenericDataModel(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task SearchAVectorStoreWithGenericDataModelAsync()
    {
        var vectorStore = new RedisVectorStore(ConnectionMultiplexer.Connect(""localhost:6379"").GetDatabase());
        var collection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        var customDataModelCollection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        await Step1_Ingest_Data.IngestDataIntoVectorStoreAsync(customDataModelCollection, fixture.TextEmbeddingGenerationService);
        var recordDefinition = new VectorStoreRecordDefinition
        {
            Properties = new List<VectorStoreRecordProperty>
            {
                new VectorStoreRecordKeyProperty(""Key"", typeof(string)),
                new VectorStoreRecordDataProperty(""Category"", typeof(string)),
                new VectorStoreRecordDataProperty(""Term"", typeof(string)),
                new VectorStoreRecordDataProperty(""Definition"", typeof(string)),
                new VectorStoreRecordVectorProperty(""DefinitionEmbedding"", typeof(ReadOnlyMemory<float>)) { Dimensions = 1536 },
            }
        };
        var genericDataModelCollection = vectorStore.GetCollection<string, VectorStoreGenericDataModel<string>>(""skglossary"", recordDefinition);
        var searchString = ""How do I provide additional context to an LLM?"";
        var searchVector = await fixture.TextEmbeddingGenerationService.GenerateEmbeddingAsync(searchString);
        var searchResult = await genericDataModelCollection.VectorizedSearchAsync(
            searchVector,
            new()
            {
                Top = 1,
            });
        var searchResultItems = await searchResult.Results.ToListAsync();
        foreach (var dataProperty in searchResultItems.First().Record.Data)
        {
            Console.WriteLine($""{dataProperty.Key}: {dataProperty.Value}"");
        }
        Console.WriteLine(searchResultItems.First().Score);
    }
}"
"<summary>
Example that shows that you can switch between different vector stores with the same code.
</summary>","public class Step3_Switch_VectorStore(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task UseAnAzureAISearchVectorStoreAsync()
    {
        var vectorStore = new AzureAISearchVectorStore(new SearchIndexClient(
            new Uri(TestConfiguration.AzureAISearch.Endpoint),
            new AzureKeyCredential(TestConfiguration.AzureAISearch.ApiKey)));
        var collection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        await Step1_Ingest_Data.IngestDataIntoVectorStoreAsync(collection, fixture.TextEmbeddingGenerationService);
        var searchResultItem = await Step2_Vector_Search.SearchVectorStoreAsync(
            collection,
            ""What is an Application Programming Interface?"",
            fixture.TextEmbeddingGenerationService);
        Console.WriteLine(searchResultItem.Record.Definition);
        Console.WriteLine(searchResultItem.Score);
    }
    [Fact]
    public async Task UseARedisVectorStoreAsync()
    {
        var vectorStore = new RedisVectorStore(ConnectionMultiplexer.Connect(""localhost:6379"").GetDatabase());
        var collection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        await Step1_Ingest_Data.IngestDataIntoVectorStoreAsync(collection, fixture.TextEmbeddingGenerationService);
        var searchResultItem = await Step2_Vector_Search.SearchVectorStoreAsync(
            collection,
            ""What is an Application Programming Interface?"",
            fixture.TextEmbeddingGenerationService);
        Console.WriteLine(searchResultItem.Record.Definition);
        Console.WriteLine(searchResultItem.Score);
    }
}"
"<summary>
Example that shows that you can switch between different vector stores with the same code, in this case
with a vector store that doesn't use string keys.
This sample demonstrates one possible approach, however it is also possible to use generics
in the common code to achieve code reuse.
</summary>","public class Step4_NonStringKey_VectorStore(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task UseAQdrantVectorStoreAsync()
    {
        var collection = new QdrantVectorStoreRecordCollection<UlongGlossary>(new QdrantClient(""localhost""), ""skglossary"");
        var stringKeyCollection = new MappingVectorStoreRecordCollection<string, ulong, Glossary, UlongGlossary>(
            collection,
            p => ulong.Parse(p),
            i => i.ToString(),
            p => new UlongGlossary { Key = ulong.Parse(p.Key), Category = p.Category, Term = p.Term, Definition = p.Definition, DefinitionEmbedding = p.DefinitionEmbedding },
            i => new Glossary { Key = i.Key.ToString(""D""), Category = i.Category, Term = i.Term, Definition = i.Definition, DefinitionEmbedding = i.DefinitionEmbedding });
        await Step1_Ingest_Data.IngestDataIntoVectorStoreAsync(stringKeyCollection, fixture.TextEmbeddingGenerationService);
        var searchResultItem = await Step2_Vector_Search.SearchVectorStoreAsync(
            stringKeyCollection,
            ""What is an Application Programming Interface?"",
            fixture.TextEmbeddingGenerationService);
        Console.WriteLine(searchResultItem.Record.Definition);
        Console.WriteLine(searchResultItem.Score);
    }
    private sealed class UlongGlossary
    {
        [VectorStoreRecordKey]
        public ulong Key { get; set; }
        [VectorStoreRecordData(IsFilterable = true)]
        public string Category { get; set; }
        [VectorStoreRecordData]
        public string Term { get; set; }
        [VectorStoreRecordData]
        public string Definition { get; set; }
        [VectorStoreRecordVector(Dimensions: 1536)]
        public ReadOnlyMemory<float> DefinitionEmbedding { get; set; }
    }
    private sealed class MappingVectorStoreRecordCollection<TPublicKey, TInternalKey, TPublicRecord, TInternalRecord> : IVectorStoreRecordCollection<TPublicKey, TPublicRecord>
        where TPublicKey : notnull
        where TInternalKey : notnull
    {
        private readonly IVectorStoreRecordCollection<TInternalKey, TInternalRecord> _collection;
        private readonly Func<TPublicKey, TInternalKey> _publicToInternalKeyMapper;
        private readonly Func<TInternalKey, TPublicKey> _internalToPublicKeyMapper;
        private readonly Func<TPublicRecord, TInternalRecord> _publicToInternalRecordMapper;
        private readonly Func<TInternalRecord, TPublicRecord> _internalToPublicRecordMapper;
        public MappingVectorStoreRecordCollection(
            IVectorStoreRecordCollection<TInternalKey, TInternalRecord> collection,
            Func<TPublicKey, TInternalKey> publicToInternalKeyMapper,
            Func<TInternalKey, TPublicKey> internalToPublicKeyMapper,
            Func<TPublicRecord, TInternalRecord> publicToInternalRecordMapper,
            Func<TInternalRecord, TPublicRecord> internalToPublicRecordMapper)
        {
            this._collection = collection;
            this._publicToInternalKeyMapper = publicToInternalKeyMapper;
            this._internalToPublicKeyMapper = internalToPublicKeyMapper;
            this._publicToInternalRecordMapper = publicToInternalRecordMapper;
            this._internalToPublicRecordMapper = internalToPublicRecordMapper;
        }
        public string CollectionName => this._collection.CollectionName;
        public Task<bool> CollectionExistsAsync(CancellationToken cancellationToken = default)
        {
            return this._collection.CollectionExistsAsync(cancellationToken);
        }
        public Task CreateCollectionAsync(CancellationToken cancellationToken = default)
        {
            return this._collection.CreateCollectionAsync(cancellationToken);
        }
        public Task CreateCollectionIfNotExistsAsync(CancellationToken cancellationToken = default)
        {
            return this._collection.CreateCollectionIfNotExistsAsync(cancellationToken);
        }
        public Task DeleteAsync(TPublicKey key, DeleteRecordOptions? options = null, CancellationToken cancellationToken = default)
        {
            return this._collection.DeleteAsync(this._publicToInternalKeyMapper(key), options, cancellationToken);
        }
        public Task DeleteBatchAsync(IEnumerable<TPublicKey> keys, DeleteRecordOptions? options = null, CancellationToken cancellationToken = default)
        {
            return this._collection.DeleteBatchAsync(keys.Select(this._publicToInternalKeyMapper), options, cancellationToken);
        }
        public Task DeleteCollectionAsync(CancellationToken cancellationToken = default)
        {
            return this._collection.DeleteCollectionAsync(cancellationToken);
        }
        public async Task<TPublicRecord?> GetAsync(TPublicKey key, GetRecordOptions? options = null, CancellationToken cancellationToken = default)
        {
            var internalRecord = await this._collection.GetAsync(this._publicToInternalKeyMapper(key), options, cancellationToken).ConfigureAwait(false);
            if (internalRecord"
"<summary>
Demonstrate usage of <see cref=""KernelFunctionTerminationStrategy""/> and <see cref=""KernelFunctionSelectionStrategy""/>
to manage <see cref=""AgentGroupChat""/> execution.
</summary>","public class Step04_KernelFunctionStrategies(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string ReviewerName = ""ArtDirector"";
    private const string ReviewerInstructions =
        """"""
        You are an art director who has opinions about copywriting born of a love for David Ogilvy.
        The goal is to determine if the given copy is acceptable to print.
        If so, state that it is approved.
        If not, provide insight on how to refine suggested copy without examples.
        """""";
    private const string CopyWriterName = ""CopyWriter"";
    private const string CopyWriterInstructions =
        """"""
        You are a copywriter with ten years of experience and are known for brevity and a dry humor.
        The goal is to refine and decide on the single best copy as an expert in the field.
        Only provide a single proposal per response.
        Never delimit the response with quotation marks.
        You're laser focused on the goal at hand.
        Don't waste time with chit chat.
        Consider suggestions when refining an idea.
        """""";
    [Fact]
    public async Task UseKernelFunctionStrategiesWithAgentGroupChatAsync()
    {
        ChatCompletionAgent agentReviewer =
            new()
            {
                Instructions = ReviewerInstructions,
                Name = ReviewerName,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        ChatCompletionAgent agentWriter =
            new()
            {
                Instructions = CopyWriterInstructions,
                Name = CopyWriterName,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        KernelFunction terminationFunction =
            AgentGroupChat.CreatePromptFunctionForStrategy(
                """"""
                Determine if the copy has been approved.  If so, respond with a single word: yes
                History:
                {{$history}}
                """""",
                safeParameterNames: ""history"");
        KernelFunction selectionFunction =
            AgentGroupChat.CreatePromptFunctionForStrategy(
                $$$""""""
                Determine which participant takes the next turn in a conversation based on the the most recent participant.
                State only the name of the participant to take the next turn.
                No participant should take more than one turn in a row.
                Choose only from these participants:
                - {{{ReviewerName}}}
                - {{{CopyWriterName}}}
                Always follow these rules when selecting the next participant:
                - After {{{CopyWriterName}}}, it is {{{ReviewerName}}}'s turn.
                - After {{{ReviewerName}}}, it is {{{CopyWriterName}}}'s turn.
                History:
                {{$history}}
                """""",
                safeParameterNames: ""history"");
        ChatHistoryTruncationReducer strategyReducer = new(1);
        AgentGroupChat chat =
            new(agentWriter, agentReviewer)
            {
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy =
                            new KernelFunctionTerminationStrategy(terminationFunction, CreateKernelWithChatCompletion())
                            {
                                Agents = [agentReviewer],
                                ResultParser = (result) => result.GetValue<string>()?.Contains(""yes"", StringComparison.OrdinalIgnoreCase) ?? false,
                                HistoryVariableName = ""history"",
                                MaximumIterations = 10,
                                HistoryReducer = strategyReducer,
                            },
                        SelectionStrategy =
                            new KernelFunctionSelectionStrategy(selectionFunction, CreateKernelWithChatCompletion())
                            {
                                InitialAgent = agentWriter,
                                ResultParser = (result) => result.GetValue<string>() ?? CopyWriterName,
                                HistoryVariableName = ""history"",
                                HistoryReducer = strategyReducer,
                            },
                    }
            };
        ChatMessageContent message = new(AuthorRole.User, ""concept: maps made out of egg cartons."");
        chat.AddChatMessage(message);
        this.WriteAgentChatMessage(message);
        await foreach (ChatMessageContent responese in chat.InvokeAsync())
        {
            this.WriteAgentChatMessage(responese);
        }
        Console.WriteLine($""\n[IS COMPLETED: {chat.IsComplete}]"");
    }
}"
"<summary>
Demonstrate creation of <see cref=""ChatCompletionAgent""/> and
eliciting its response to three explicit user messages.
</summary>","public class Step01_Agent(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string ParrotName = ""Parrot"";
    private const string ParrotInstructions = ""Repeat the user message in the voice of a pirate and then end with a parrot sound."";
    [Fact]
    public async Task UseSingleChatCompletionAgentAsync()
    {
        Kernel kernel = this.CreateKernelWithChatCompletion();
        ChatCompletionAgent agent =
            new()
            {
                Name = ParrotName,
                Instructions = ParrotInstructions,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        ChatHistory chat = [];
        await InvokeAgentAsync(""Fortune favors the bold."");
        await InvokeAgentAsync(""I came, I saw, I conquered."");
        await InvokeAgentAsync(""Practice makes perfect."");
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            chat.Add(message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(chat))
            {
                chat.Add(response);
                this.WriteAgentChatMessage(response);
            }
        }
    }
    [Fact]
    public async Task UseTemplateForChatCompletionAgentAsync()
    {
        string generateStoryYaml = EmbeddedResource.Read(""GenerateStory.yaml"");
        PromptTemplateConfig templateConfig = KernelFunctionYaml.ToPromptTemplateConfig(generateStoryYaml);
        ChatCompletionAgent agent =
            new(templateConfig, new KernelPromptTemplateFactory())
            {
                Kernel = this.CreateKernelWithChatCompletion(),
                Arguments = new KernelArguments()
                {
                    { ""topic"", ""Dog"" },
                    { ""length"", ""3"" },
                }
            };
        ChatHistory chat = [];
        await InvokeAgentAsync();
        await InvokeAgentAsync(
            new()
            {
                { ""topic"", ""Cat"" },
                { ""length"", ""3"" },
            });
        async Task InvokeAgentAsync(KernelArguments? arguments = null)
        {
            await foreach (ChatMessageContent content in agent.InvokeAsync(chat, arguments))
            {
                chat.Add(content);
                WriteAgentChatMessage(content);
            }
        }
    }
}"
"<summary>
Demonstrate providing image input to <see cref=""OpenAIAssistantAgent""/> .
</summary>","public class Step09_Assistant_Vision(ITestOutputHelper output) : BaseAgentsTest(output)
{
    protected override bool ForceOpenAI => true;
    [Fact]
    public async Task UseSingleAssistantAgentAsync()
    {
        OpenAIClientProvider provider = this.GetClientProvider();
        OpenAIAssistantAgent agent =
            await OpenAIAssistantAgent.CreateAsync(
                provider,
                definition: new OpenAIAssistantDefinition(this.Model)
                {
                    Metadata = AssistantSampleMetadata,
                },
                kernel: new Kernel());
        await using Stream imageStream = EmbeddedResource.ReadStream(""cat.jpg"")!;
        string fileId = await agent.UploadFileAsync(imageStream, ""cat.jpg"");
        string threadId = await agent.CreateThreadAsync(new OpenAIThreadCreationOptions { Metadata = AssistantSampleMetadata });
        try
        {
            await InvokeAgentAsync(CreateMessageWithImageUrl(""Describe this image."", ""https:
            await InvokeAgentAsync(CreateMessageWithImageUrl(""What are is the main color in this image?"", ""https:
            await InvokeAgentAsync(CreateMessageWithImageReference(""Is there an animal in this image?"", fileId));
        }
        finally
        {
            await agent.DeleteThreadAsync(threadId);
            await agent.DeleteAsync();
            await provider.Client.GetOpenAIFileClient().DeleteFileAsync(fileId);
        }
        async Task InvokeAgentAsync(ChatMessageContent message)
        {
            await agent.AddChatMessageAsync(threadId, message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(threadId))
            {
                this.WriteAgentChatMessage(response);
            }
        }
    }
    private ChatMessageContent CreateMessageWithImageUrl(string input, string url)
        => new(AuthorRole.User, [new TextContent(input), new ImageContent(new Uri(url))]);
    private ChatMessageContent CreateMessageWithImageReference(string input, string fileId)
        => new(AuthorRole.User, [new TextContent(input), new FileReferenceContent(fileId)]);
}"
"<summary>
Demonstrate using code-interpreter on <see cref=""OpenAIAssistantAgent""/> .
</summary>","public class Step10_AssistantTool_CodeInterpreter(ITestOutputHelper output) : BaseAgentsTest(output)
{
    [Fact]
    public async Task UseCodeInterpreterToolWithAssistantAgentAsync()
    {
        OpenAIAssistantAgent agent =
            await OpenAIAssistantAgent.CreateAsync(
                clientProvider: this.GetClientProvider(),
                definition: new(this.Model)
                {
                    EnableCodeInterpreter = true,
                    Metadata = AssistantSampleMetadata,
                },
                kernel: new Kernel());
        string threadId = await agent.CreateThreadAsync(new OpenAIThreadCreationOptions { Metadata = AssistantSampleMetadata });
        try
        {
            await InvokeAgentAsync(""Use code to determine the values in the Fibonacci sequence that that are less then the value of 101?"");
        }
        finally
        {
            await agent.DeleteThreadAsync(threadId);
            await agent.DeleteAsync();
        }
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            await agent.AddChatMessageAsync(threadId, message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(threadId))
            {
                this.WriteAgentChatMessage(response);
            }
        }
    }
}"
"<summary>
Demonstrate using code-interpreter on <see cref=""OpenAIAssistantAgent""/> .
</summary>","public class Step11_AssistantTool_FileSearch(ITestOutputHelper output) : BaseAgentsTest(output)
{
    [Fact]
    public async Task UseFileSearchToolWithAssistantAgentAsync()
    {
        OpenAIClientProvider provider = this.GetClientProvider();
        OpenAIAssistantAgent agent =
            await OpenAIAssistantAgent.CreateAsync(
                clientProvider: this.GetClientProvider(),
                definition: new OpenAIAssistantDefinition(this.Model)
                {
                    EnableFileSearch = true,
                    Metadata = AssistantSampleMetadata,
                },
                kernel: new Kernel());
        OpenAIFileClient fileClient = provider.Client.GetOpenAIFileClient();
        await using Stream stream = EmbeddedResource.ReadStream(""employees.pdf"")!;
        OpenAIFile fileInfo = await fileClient.UploadFileAsync(stream, ""employees.pdf"", FileUploadPurpose.Assistants);
        VectorStoreClient vectorStoreClient = provider.Client.GetVectorStoreClient();
        CreateVectorStoreOperation result =
            await vectorStoreClient.CreateVectorStoreAsync(waitUntilCompleted: false,
                new VectorStoreCreationOptions()
                {
                    FileIds = { fileInfo.Id },
                    Metadata = { { AssistantSampleMetadataKey, bool.TrueString } }
                });
        string threadId =
            await agent.CreateThreadAsync(
                new OpenAIThreadCreationOptions
                {
                    VectorStoreId = result.VectorStoreId,
                    Metadata = AssistantSampleMetadata,
                });
        try
        {
            await InvokeAgentAsync(""Who is the youngest employee?"");
            await InvokeAgentAsync(""Who works in sales?"");
            await InvokeAgentAsync(""I have a customer request, who can help me?"");
        }
        finally
        {
            await agent.DeleteThreadAsync(threadId);
            await agent.DeleteAsync();
            await vectorStoreClient.DeleteVectorStoreAsync(result.VectorStoreId);
            await fileClient.DeleteFileAsync(fileInfo.Id);
        }
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            await agent.AddChatMessageAsync(threadId, message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(threadId))
            {
                this.WriteAgentChatMessage(response);
            }
        }
    }
}"
"<summary>
Demonstrate creation of an agent via dependency injection.
</summary>","public class Step06_DependencyInjection(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string TutorName = ""Tutor"";
    private const string TutorInstructions =
        """"""
        Think step-by-step and rate the user input on creativity and expressiveness from 1-100.
        Respond in JSON format with the following JSON schema:
        {
            ""score"": ""integer (1-100)"",
            ""notes"": ""the reason for your score""
        }
        """""";
    [Fact]
    public async Task UseDependencyInjectionToCreateAgentAsync()
    {
        ServiceCollection serviceContainer = new();
        serviceContainer.AddLogging(c => c.AddConsole().SetMinimumLevel(LogLevel.Information));
        if (this.UseOpenAIConfig)
        {
            serviceContainer.AddOpenAIChatCompletion(
                TestConfiguration.OpenAI.ChatModelId,
                TestConfiguration.OpenAI.ApiKey);
        }
        else
        {
            serviceContainer.AddAzureOpenAIChatCompletion(
                TestConfiguration.AzureOpenAI.ChatDeploymentName,
                TestConfiguration.AzureOpenAI.Endpoint,
                TestConfiguration.AzureOpenAI.ApiKey);
        }
        serviceContainer.AddTransient<Kernel>();
        serviceContainer.AddTransient<AgentClient>();
        serviceContainer.AddKeyedSingleton<ChatCompletionAgent>(
            TutorName,
            (sp, key) =>
                new ChatCompletionAgent()
                {
                    Instructions = TutorInstructions,
                    Name = TutorName,
                    Kernel = sp.GetRequiredService<Kernel>().Clone(),
                });
        await using ServiceProvider serviceProvider = serviceContainer.BuildServiceProvider();
        AgentClient agentClient = serviceProvider.GetRequiredService<AgentClient>();
        await WriteAgentResponse(""The sunset is nice."");
        await WriteAgentResponse(""The sunset is setting over the mountains."");
        await WriteAgentResponse(""The sunset is setting over the mountains and filled the sky with a deep red flame, setting the clouds ablaze."");
        async Task WriteAgentResponse(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agentClient.RunDemoAsync(message))
            {
                this.WriteAgentChatMessage(response);
            }
        }
    }
    private sealed class AgentClient([FromKeyedServices(TutorName)] ChatCompletionAgent agent)
    {
        private readonly AgentGroupChat _chat = new();
        public IAsyncEnumerable<ChatMessageContent> RunDemoAsync(ChatMessageContent input)
        {
            this._chat.AddChatMessage(input);
            return this._chat.InvokeAsync(agent);
        }
    }
    private record struct WritingScore(int score, string notes);
}"
"<summary>
This example demonstrates similarity between using <see cref=""OpenAIAssistantAgent""/>
and <see cref=""ChatCompletionAgent""/> (see: Step 2).
</summary>","public class Step08_Assistant(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string HostName = ""Host"";
    private const string HostInstructions = ""Answer questions about the menu."";
    [Fact]
    public async Task UseSingleAssistantAgentAsync()
    {
        OpenAIAssistantAgent agent =
            await OpenAIAssistantAgent.CreateAsync(
                clientProvider: this.GetClientProvider(),
                definition: new OpenAIAssistantDefinition(this.Model)
                {
                    Instructions = HostInstructions,
                    Name = HostName,
                    Metadata = AssistantSampleMetadata,
                },
                kernel: new Kernel());
        KernelPlugin plugin = KernelPluginFactory.CreateFromType<MenuPlugin>();
        agent.Kernel.Plugins.Add(plugin);
        string threadId = await agent.CreateThreadAsync(new OpenAIThreadCreationOptions { Metadata = AssistantSampleMetadata });
        try
        {
            await InvokeAgentAsync(""Hello"");
            await InvokeAgentAsync(""What is the special soup and its price?"");
            await InvokeAgentAsync(""What is the special drink and its price?"");
            await InvokeAgentAsync(""Thank you"");
        }
        finally
        {
            await agent.DeleteThreadAsync(threadId);
            await agent.DeleteAsync();
        }
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            await agent.AddChatMessageAsync(threadId, message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(threadId))
            {
                this.WriteAgentChatMessage(response);
            }
        }
    }
    [Fact]
    public async Task UseTemplateForAssistantAgentAsync()
    {
        string generateStoryYaml = EmbeddedResource.Read(""GenerateStory.yaml"");
        PromptTemplateConfig templateConfig = KernelFunctionYaml.ToPromptTemplateConfig(generateStoryYaml);
        OpenAIAssistantAgent agent =
            await OpenAIAssistantAgent.CreateFromTemplateAsync(
                clientProvider: this.GetClientProvider(),
                capabilities: new OpenAIAssistantCapabilities(this.Model)
                {
                    Metadata = AssistantSampleMetadata,
                },
                kernel: new Kernel(),
                defaultArguments: new KernelArguments()
                {
                    { ""topic"", ""Dog"" },
                    { ""length"", ""3"" },
                },
                templateConfig);
        string threadId = await agent.CreateThreadAsync(new OpenAIThreadCreationOptions { Metadata = AssistantSampleMetadata });
        try
        {
            await InvokeAgentAsync();
            await InvokeAgentAsync(
                new()
                {
                { ""topic"", ""Cat"" },
                { ""length"", ""3"" },
                });
        }
        finally
        {
            await agent.DeleteThreadAsync(threadId);
            await agent.DeleteAsync();
        }
        async Task InvokeAgentAsync(KernelArguments? arguments = null)
        {
            await foreach (ChatMessageContent response in agent.InvokeAsync(threadId, arguments))
            {
                WriteAgentChatMessage(response);
            }
        }
    }
    private sealed class MenuPlugin
    {
        [KernelFunction, Description(""Provides a list of specials from the menu."")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage(""Design"", ""CA1024:Use properties where appropriate"", Justification = ""Too smart"")]
        public string GetSpecials() =>
            """"""
            Special Soup: Clam Chowder
            Special Salad: Cobb Salad
            Special Drink: Chai Tea
            """""";
        [KernelFunction, Description(""Provides the price of the requested menu item."")]
        public string GetItemPrice(
            [Description(""The name of the menu item."")]
            string menuItem) =>
            ""$9.99"";
    }
}"
"<summary>
Demonstrate creation of <see cref=""ChatCompletionAgent""/> with a <see cref=""KernelPlugin""/>,
and then eliciting its response to explicit user messages.
</summary>","public class Step02_Plugins(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string HostName = ""Host"";
    private const string HostInstructions = ""Answer questions about the menu."";
    [Fact]
    public async Task UseChatCompletionWithPluginAgentAsync()
    {
        ChatCompletionAgent agent =
            new()
            {
                Instructions = HostInstructions,
                Name = HostName,
                Kernel = this.CreateKernelWithChatCompletion(),
                Arguments = new KernelArguments(new OpenAIPromptExecutionSettings() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() }),
            };
        KernelPlugin plugin = KernelPluginFactory.CreateFromType<MenuPlugin>();
        agent.Kernel.Plugins.Add(plugin);
        ChatHistory chat = [];
        await InvokeAgentAsync(""Hello"");
        await InvokeAgentAsync(""What is the special soup?"");
        await InvokeAgentAsync(""What is the special drink?"");
        await InvokeAgentAsync(""Thank you"");
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            chat.Add(message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(chat))
            {
                chat.Add(response);
                this.WriteAgentChatMessage(response);
            }
        }
    }
    private sealed class MenuPlugin
    {
        [KernelFunction, Description(""Provides a list of specials from the menu."")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage(""Design"", ""CA1024:Use properties where appropriate"", Justification = ""Too smart"")]
        public string GetSpecials() =>
            """"""
            Special Soup: Clam Chowder
            Special Salad: Cobb Salad
            Special Drink: Chai Tea
            """""";
        [KernelFunction, Description(""Provides the price of the requested menu item."")]
        public string GetItemPrice(
            [Description(""The name of the menu item."")]
            string menuItem) =>
            ""$9.99"";
    }
}"
"<summary>
Demonstrate parsing JSON response.
</summary>","public class Step05_JsonResult(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const int ScoreCompletionThreshold = 70;
    private const string TutorName = ""Tutor"";
    private const string TutorInstructions =
        """"""
        Think step-by-step and rate the user input on creativity and expressiveness from 1-100.
        Respond in JSON format with the following JSON schema:
        {
            ""score"": ""integer (1-100)"",
            ""notes"": ""the reason for your score""
        }
        """""";
    [Fact]
    public async Task UseKernelFunctionStrategiesWithJsonResultAsync()
    {
        ChatCompletionAgent agent =
            new()
            {
                Instructions = TutorInstructions,
                Name = TutorName,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        AgentGroupChat chat =
            new()
            {
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy = new ThresholdTerminationStrategy()
                    }
            };
        await InvokeAgentAsync(""The sunset is very colorful."");
        await InvokeAgentAsync(""The sunset is setting over the mountains."");
        await InvokeAgentAsync(""The sunset is setting over the mountains and filled the sky with a deep red flame, setting the clouds ablaze."");
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            chat.AddChatMessage(message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in chat.InvokeAsync(agent))
            {
                this.WriteAgentChatMessage(response);
                Console.WriteLine($""[IS COMPLETED: {chat.IsComplete}]"");
            }
        }
    }
    private record struct WritingScore(int score, string notes);
    private sealed class ThresholdTerminationStrategy : TerminationStrategy
    {
        protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken)
        {
            string lastMessageContent = history[history.Count - 1].Content ?? string.Empty;
            WritingScore? result = JsonResultTranslator.Translate<WritingScore>(lastMessageContent);
            return Task.FromResult((result?.score ?? 0) >= ScoreCompletionThreshold);
        }
    }
}"
"<summary>
A repeat of <see cref=""Step03_Chat""/> with logging enabled via assignment
of a <see cref=""LoggerFactory""/> to <see cref=""AgentChat.LoggerFactory""/>.
</summary>","public class Step07_Logging(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string ReviewerName = ""ArtDirector"";
    private const string ReviewerInstructions =
        """"""
        You are an art director who has opinions about copywriting born of a love for David Ogilvy.
        The goal is to determine if the given copy is acceptable to print.
        If so, state that it is approved.
        If not, provide insight on how to refine suggested copy without examples.
        """""";
    private const string CopyWriterName = ""CopyWriter"";
    private const string CopyWriterInstructions =
        """"""
        You are a copywriter with ten years of experience and are known for brevity and a dry humor.
        The goal is to refine and decide on the single best copy as an expert in the field.
        Only provide a single proposal per response.
        You're laser focused on the goal at hand.
        Don't waste time with chit chat.
        Consider suggestions when refining an idea.
        """""";
    [Fact]
    public async Task UseLoggerFactoryWithAgentGroupChatAsync()
    {
        ChatCompletionAgent agentReviewer =
            new()
            {
                Instructions = ReviewerInstructions,
                Name = ReviewerName,
                Kernel = this.CreateKernelWithChatCompletion(),
                LoggerFactory = this.LoggerFactory,
            };
        ChatCompletionAgent agentWriter =
            new()
            {
                Instructions = CopyWriterInstructions,
                Name = CopyWriterName,
                Kernel = this.CreateKernelWithChatCompletion(),
                LoggerFactory = this.LoggerFactory,
            };
        AgentGroupChat chat =
            new(agentWriter, agentReviewer)
            {
                LoggerFactory = this.LoggerFactory,
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy =
                            new ApprovalTerminationStrategy()
                            {
                                Agents = [agentReviewer],
                                MaximumIterations = 10,
                            }
                    }
            };
        ChatMessageContent input = new(AuthorRole.User, ""concept: maps made out of egg cartons."");
        chat.AddChatMessage(input);
        this.WriteAgentChatMessage(input);
        await foreach (ChatMessageContent response in chat.InvokeAsync())
        {
            this.WriteAgentChatMessage(response);
        }
        Console.WriteLine($""\n[IS COMPLETED: {chat.IsComplete}]"");
    }
    private sealed class ApprovalTerminationStrategy : TerminationStrategy
    {
        protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken)
            => Task.FromResult(history[history.Count - 1].Content?.Contains(""approve"", StringComparison.OrdinalIgnoreCase) ?? false);
    }
}"
"<summary>
Demonstrate creation of <see cref=""AgentChat""/> with <see cref=""AgentGroupChatSettings""/>
that inform how chat proceeds with regards to: Agent selection, chat continuation, and maximum
number of agent interactions.
</summary>","public class Step03_Chat(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string ReviewerName = ""ArtDirector"";
    private const string ReviewerInstructions =
        """"""
        You are an art director who has opinions about copywriting born of a love for David Ogilvy.
        The goal is to determine if the given copy is acceptable to print.
        If so, state that it is approved.
        If not, provide insight on how to refine suggested copy without example.
        """""";
    private const string CopyWriterName = ""CopyWriter"";
    private const string CopyWriterInstructions =
        """"""
        You are a copywriter with ten years of experience and are known for brevity and a dry humor.
        The goal is to refine and decide on the single best copy as an expert in the field.
        Only provide a single proposal per response.
        You're laser focused on the goal at hand.
        Don't waste time with chit chat.
        Consider suggestions when refining an idea.
        """""";
    [Fact]
    public async Task UseAgentGroupChatWithTwoAgentsAsync()
    {
        ChatCompletionAgent agentReviewer =
            new()
            {
                Instructions = ReviewerInstructions,
                Name = ReviewerName,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        ChatCompletionAgent agentWriter =
            new()
            {
                Instructions = CopyWriterInstructions,
                Name = CopyWriterName,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        AgentGroupChat chat =
            new(agentWriter, agentReviewer)
            {
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy =
                            new ApprovalTerminationStrategy()
                            {
                                Agents = [agentReviewer],
                                MaximumIterations = 10,
                            }
                    }
            };
        ChatMessageContent input = new(AuthorRole.User, ""concept: maps made out of egg cartons."");
        chat.AddChatMessage(input);
        this.WriteAgentChatMessage(input);
        await foreach (ChatMessageContent response in chat.InvokeAsync())
        {
            this.WriteAgentChatMessage(response);
        }
        Console.WriteLine($""\n[IS COMPLETED: {chat.IsComplete}]"");
    }
    private sealed class ApprovalTerminationStrategy : TerminationStrategy
    {
        protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken)
            => Task.FromResult(history[history.Count - 1].Content?.Contains(""approve"", StringComparison.OrdinalIgnoreCase) ?? false);
    }
}"
"<summary>
Represents a class that demonstrates audio processing functionality.
</summary>","public sealed class OpenAI_TextToAudio(ITestOutputHelper output) : BaseTest(output)
{
    private const string TextToAudioModel = ""tts-1"";
    [Fact(Skip = ""Uncomment the line to write the audio file output before running this test."")]
    public async Task TextToAudioAsync()
    {
        var kernel = Kernel.CreateBuilder()
            .AddOpenAITextToAudio(
                modelId: TextToAudioModel,
                apiKey: TestConfiguration.OpenAI.ApiKey)
            .Build();
        var textToAudioService = kernel.GetRequiredService<ITextToAudioService>();
        string sampleText = ""Hello, my name is John. I am a software engineer. I am working on a project to convert text to audio."";
        OpenAITextToAudioExecutionSettings executionSettings = new()
        {
            Voice = ""alloy"", 
            ResponseFormat = ""mp3"", 
            Speed = 1.0f 
        };
        AudioContent audioContent = await textToAudioService.GetAudioContentAsync(sampleText, executionSettings);
    }
}"
"<summary>
These samples demonstrate how to advertise functions to AI model based on a context.
</summary>","public class ContextDependentAdvertising(ITestOutputHelper output) : BaseTest(output)
{
    [Fact]
    public async Task AdvertiseFunctionsDependingOnContextPerUserInteractionAsync()
    {
        Kernel kernel = CreateKernel();
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        int maxIteration = 10;
        int iteration = 0;
        var gameUtils = kernel.ImportPluginFromType<GameUtils>();
        KernelFunction createMaze = gameUtils[""CreateMaze""];
        KernelFunction addTraps = gameUtils[""AddTrapsToMaze""];
        KernelFunction addTreasures = gameUtils[""AddTreasuresToMaze""];
        KernelFunction playGame = gameUtils[""PlayGame""];
        ChatHistory chatHistory = [];
        chatHistory.AddUserMessage(""I would like to play a maze game with a lot of tricky traps and shiny treasures."");
        while (!chatHistory.Any(item => item.Content?.Contains(""Game started."") ?? false) && iteration < maxIteration)
        {
            List<KernelFunction> functionsToAdvertise = new();
            bool mazeCreated = chatHistory.Any(item => item.Content?.Contains(""Maze created."") ?? false);
            bool trapsAdded = chatHistory.Any(item => item.Content?.Contains(""Traps added to the maze."") ?? false);
            bool treasuresAdded = chatHistory.Any(item => item.Content?.Contains(""Treasures added to the maze."") ?? false);
            if (!mazeCreated)
            {
                functionsToAdvertise.Add(createMaze);
            }
            else if (mazeCreated && (!trapsAdded || !treasuresAdded))
            {
                functionsToAdvertise.Add(addTraps);
                functionsToAdvertise.Add(addTreasures);
            }
            else if (treasuresAdded && trapsAdded)
            {
                functionsToAdvertise.Add(playGame);
            }
            OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Required(functionsToAdvertise) };
            ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(chatHistory, settings, kernel);
            Console.WriteLine(result);
            iteration++;
        }
    }
    private static Kernel CreateKernel()
    {
        IKernelBuilder builder = Kernel.CreateBuilder();
        builder.AddOpenAIChatCompletion(TestConfiguration.OpenAI.ChatModelId, TestConfiguration.OpenAI.ApiKey);
        return builder.Build();
    }
    private sealed class GameUtils
    {
        [KernelFunction]
        public static string CreateMaze() => ""Maze created."";
        [KernelFunction]
        public static string AddTrapsToMaze() => ""Traps added to the maze."";
        [KernelFunction]
        public static string AddTreasuresToMaze() => ""Treasures added to the maze."";
        [KernelFunction]
        public static string PlayGame() => ""Game started."";
    }
}"
"<summary>
These examples demonstrate how to enable and configure various aspects of function calling model in SK using the different function choice behaviors:
<see cref=""FunctionChoiceBehavior.Auto""/>, <see cref=""FunctionChoiceBehavior.Required""/>, and <see cref=""FunctionChoiceBehavior.None""/>.
The behaviors define the following aspect of function calling model:
1. Function advertising - the list of functions to provide to the AI model. All three can advertise all kernel functions or a specified subset of them.
2. Function calling behavior - whether the AI model automatically selects functions to call, is forced to call provided functions, or has to describe which functions it would call without calling them to complete the prompt.
3. Function invocation - whether functions are invoked automatically by SK or manually by a caller and whether they are invoked sequentially or concurrently(not supported in auto-invocation mode yet)

** Function advertising **
All three behaviors have the `functions` parameter of type <see cref=""IEnumerable{KernelFunction}""/>. By default, it is null,
which means all kernel functions are provided or advertised to the AI model. If a list of functions is provided,
only those functions are advertised to the AI model. An empty list means no functions are provided to the AI model,
which is equivalent to disabling function calling.

** Function calling behavior **
The <see cref=""FunctionChoiceBehavior.Auto""/> behavior allows the model to decide whether to call the functions and, if so, which ones to call.
The <see cref=""FunctionChoiceBehavior.Required""/> behavior forces the model to call the provided functions. The behavior advertises functions in the first
request to the AI model only and stops advertising them in subsequent requests to prevent an infinite loop where the model keeps calling functions repeatedly.
The <see cref=""FunctionChoiceBehavior.None""/> behavior tells the AI model to use the provided functions without calling them to generate a response.
This behavior is useful for dry runs when you want to see which functions the model would call without actually invoking them.

** Function invocation **
The <see cref=""FunctionChoiceBehavior.Auto""/> and <see cref=""FunctionChoiceBehavior.Required""/> supports two modes of function invocation: manual and automatic:
* Automatic function invocation mode causes all functions chosen by the AI model to be automatically invoked by SK.
The results of these function invocations are added to the chat history and sent to the model automatically in the following request.
The model then reasons about the chat history and then calls functions again or generates the final response.
This approach is fully automated and requires no manual intervention from the caller. The automatic invocation mode is enabled by default.
* Manual invocation mode returns all function calls requested by the AI model to the SK caller. The caller is fully responsible
for the invocation phase where they may decide which function to call, how to handle exceptions, call them in parallel or sequentially, etc.
The caller then adds the function results/exceptions to the chat history and returns it to the model, which reasons about it
and then calls functions again or generates the final response. This invocation mode provides more control over the function invocation phase to the caller.
To enable manual invocation, the caller needs to set the `autoInvoke` parameter to `false` when specifying either <see cref=""FunctionChoiceBehavior.Auto""/>
or <see cref=""FunctionChoiceBehavior.Required""/> in the <see cref=""PromptExecutionSettings""/>.

** Options **
The following aspects of the function choice behaviors can be changed via the `options` constructor's parameter of type <see cref=""FunctionChoiceBehaviorOptions""/> each behavior accepts:
* The <see cref=""FunctionChoiceBehaviorOptions.AllowConcurrentInvocation""/> option enables concurrent invocation of functions by SK.
By default, this option is set to false, meaning that functions are invoked sequentially. Concurrent invocation is only possible if the AI model can
call or select multiple functions for invocation in a single request; otherwise, there is no distinction between sequential and concurrent invocation.
* The <see cref=""FunctionChoiceBehaviorOptions.AllowParallelCalls""/> option instructs the AI model to call multiple functions in one request if the model supports parallel function calls.
By default, this option is set to null, meaning that the AI model default value will be used.

The following table summarizes the effects of various combinations of the AllowParallelCalls and AllowConcurrentInvocation options:

| AllowParallelCalls  | AllowConcurrentInvocation | # of functions chosen per AI roundtrip  | Concurrent Invocation by SK |
|---------------------|---------------------------|-----------------------------------------|-----------------------------|
| false               | false                     | one                                     | false                       |
| false               | true                      | one                                     | false*                      |
| true                | false                     | multiple                                | false                       |
| true                | true                      | multiple                                | true                        |

`*` There's only one function to invoke.
</summary>","public class FunctionCalling(ITestOutputHelper output) : BaseTest(output)
{
    [Fact]
    public async Task RunPromptWithAutoFunctionChoiceBehaviorAdvertisingAllKernelFunctionsInvokedAutomaticallyAsync()
    {
        Kernel kernel = CreateKernel();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() };
        Console.WriteLine(await kernel.InvokePromptAsync(""Given the current time of day and weather, what is the likely color of the sky in Boston?"", new(settings)));
    }
    [Fact]
    public async Task RunPromptWithRequiredFunctionChoiceBehaviorAdvertisingOneFunctionInvokedAutomaticallyAsync()
    {
        Kernel kernel = CreateKernel();
        KernelFunction getWeatherFunction = kernel.Plugins.GetFunction(""HelperFunctions"", ""GetWeatherForCity"");
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Required(functions: [getWeatherFunction]) };
        Console.WriteLine(await kernel.InvokePromptAsync(""Given that it is now the 9th of September 2024, 11:29 AM, what is the likely color of the sky in Boston?"", new(settings)));
    }
    [Fact]
    public async Task RunPromptWithNoneFunctionChoiceBehaviorAdvertisingAllKernelFunctionsAsync()
    {
        Kernel kernel = CreateKernel();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.None() };
        Console.WriteLine(await kernel.InvokePromptAsync(""Tell me which provided functions I would need to call to get the color of the sky in Boston on a specified date."", new(settings)));
    }
    [Fact]
    public async Task RunPromptTemplateConfigWithAutoFunctionChoiceBehaviorAdvertisingAllKernelFunctionsInvokedAutomaticallyAsync()
    {
        Kernel kernel = CreateKernel();
        string promptTemplateConfig = """"""
            template_format: semantic-kernel
            template: Given the current time of day and weather, what is the likely color of the sky in Boston?
            execution_settings:
              default:
                function_choice_behavior:
                  type: auto
            """""";
        KernelFunction promptFunction = KernelFunctionYaml.FromPromptYaml(promptTemplateConfig);
        Console.WriteLine(await kernel.InvokeAsync(promptFunction));
    }
    [Fact]
    public async Task RunPromptTemplateConfigWithAutoFunctionChoiceBehaviorAdvertisingOneFunctionInvokedAutomaticallyAsync()
    {
        Kernel kernel = CreateKernel();
        string promptTemplateConfig = """"""
            template_format: semantic-kernel
            template: Given that it is now the 9th of September 2024, 11:29 AM, what is the likely color of the sky in Boston?
            execution_settings:
              default:
                function_choice_behavior:
                  type: auto
                  functions:
                    - HelperFunctions.GetWeatherForCity
            """""";
        KernelFunction promptFunction = KernelFunctionYaml.FromPromptYaml(promptTemplateConfig);
        Console.WriteLine(await kernel.InvokeAsync(promptFunction));
    }
    [Fact]
    public async Task RunNonStreamingChatCompletionApiWithAutomaticFunctionInvocationAsync()
    {
        Kernel kernel = CreateKernel();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() };
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(
            ""Given the current time of day and weather, what is the likely color of the sky in Boston?"",
            settings,
            kernel);
        Console.WriteLine(result);
    }
    [Fact]
    public async Task RunStreamingChatCompletionApiWithAutomaticFunctionInvocationAsync()
    {
        Kernel kernel = CreateKernel();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() };
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        var stringBuilder = new StringBuilder();
        await foreach (var update in chatCompletionService.GetStreamingChatMessageContentsAsync(
            ""Given the current time of day and weather, what is the likely color of the sky in Boston?"",
            settings,
            kernel))
        {
            stringBuilder.Append(update.Content);
        }
        Console.WriteLine(stringBuilder.ToString());
    }
    [Fact]
    public async Task RunNonStreamingChatCompletionApiWithManualFunctionInvocationAsync()
    {
        Kernel kernel = CreateKernel();
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = Microsoft.SemanticKernel.FunctionChoiceBehavior.Auto(autoInvoke: false) };
        ChatHistory chatHistory = [];
        chatHistory.AddUserMessage(""Given the current time of day and weather, what is the likely color of the sky in Boston?"");
        while (true)
        {
            ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(chatHistory, settings, kernel);
            if (result.Content is not null)
            {
                Console.Write(result.Content);
            }
            IEnumerable<FunctionCallContent> functionCalls = FunctionCallContent.GetFunctionCalls(result);
            if (!functionCalls.Any())
            {
                break;
            }
            chatHistory.Add(result);
            foreach (FunctionCallContent functionCall in functionCalls)
            {
                try
                {
                    FunctionResultContent resultContent = await functionCall.InvokeAsync(kernel);
                    chatHistory.Add(resultContent.ToChatMessage());
                }
                catch (Exception ex)
                {
                    chatHistory.Add(new FunctionResultContent(functionCall, ex).ToChatMessage());
                }
            }
            Console.WriteLine();
        }
    }
    [Fact]
    public async Task RunStreamingChatCompletionApiWithManualFunctionCallingAsync()
    {
        Kernel kernel = CreateKernel();
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = Microsoft.SemanticKernel.FunctionChoiceBehavior.Auto(autoInvoke: false) };
        ChatHistory chatHistory = [];
        chatHistory.AddUserMessage(""Given the current time of day and weather, what is the likely color of the sky in Boston?"");
        while (true)
        {
            AuthorRole? authorRole = null;
            var fccBuilder = new FunctionCallContentBuilder();
            await foreach (var streamingContent in chatCompletionService.GetStreamingChatMessageContentsAsync(chatHistory, settings, kernel))
            {
                if (streamingContent.Content is not null)
                {
                    Console.Write(streamingContent.Content);
                }
                authorRole ??= streamingContent.Role;
                fccBuilder.Append(streamingContent);
            }
            var functionCalls = fccBuilder.Build();
            if (!functionCalls.Any())
            {
                break;
            }
            var fcContent = new ChatMessageContent(role: authorRole ?? default, content: null);
            chatHistory.Add(fcContent);
            foreach (var functionCall in functionCalls)
            {
                fcContent.Items.Add(functionCall);
                var functionResult = await functionCall.InvokeAsync(kernel);
                chatHistory.Add(functionResult.ToChatMessage());
            }
            Console.WriteLine();
        }
    }
    [Fact]
    public async Task RunNonStreamingPromptWithSimulatedFunctionAsync()
    {
        Kernel kernel = CreateKernel();
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = Microsoft.SemanticKernel.FunctionChoiceBehavior.Auto(autoInvoke: false) };
        ChatHistory chatHistory = [];
        chatHistory.AddUserMessage(""Given the current time of day and weather, what is the likely color of the sky in Boston?"");
        while (true)
        {
            ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(chatHistory, settings, kernel);
            if (result.Content is not null)
            {
                Console.Write(result.Content);
            }
            chatHistory.Add(result); 
            IEnumerable<FunctionCallContent> functionCalls = FunctionCallContent.GetFunctionCalls(result);
            if (!functionCalls.Any())
            {
                break;
            }
            foreach (FunctionCallContent functionCall in functionCalls)
            {
                FunctionResultContent resultContent = await functionCall.InvokeAsync(kernel); 
                chatHistory.Add(resultContent.ToChatMessage());
            }
            FunctionCallContent simulatedFunctionCall = new(""weather-alert"", id: ""call_123"");
            result.Items.Add(simulatedFunctionCall);
            string simulatedFunctionResult = ""A Tornado Watch has been issued, with potential for severe thunderstorms causing unusual sky colors like green, yellow, or dark gray. Stay informed and follow safety instructions from authorities."";
            chatHistory.Add(new FunctionResultContent(simulatedFunctionCall, simulatedFunctionResult).ToChatMessage());
            Console.WriteLine();
        }
    }
    [Fact]
    public async Task DisableFunctionCallingAsync()
    {
        Kernel kernel = CreateKernel();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(functions: []) };
        Console.WriteLine(await kernel.InvokePromptAsync(""Given the current time of day and weather, what is the likely color of the sky in Boston?"", new(settings)));
    }
    [Fact]
    public async Task DisableFunctionCallingInPromptTemplateConfigAsync()
    {
        Kernel kernel = CreateKernel();
        string promptTemplateConfig = """"""
            template_format: semantic-kernel
            template: Given that it is now the 9th of September 2024, 11:29 AM, what is the likely color of the sky in Boston?
            execution_settings:
              default:
                function_choice_behavior:
                  type: auto
                  functions: []
            """""";
        KernelFunction promptFunction = KernelFunctionYaml.FromPromptYaml(promptTemplateConfig);
        Console.WriteLine(await kernel.InvokeAsync(promptFunction));
    }
    [Fact]
    public async Task RunNonStreamingChatCompletionApiWithConcurrentFunctionInvocationOptionAsync()
    {
        Kernel kernel = CreateKernel();
        FunctionChoiceBehaviorOptions options = new() { AllowConcurrentInvocation = true };
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(options: options) };
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(
            ""Good morning! What’s the current time and latest news headlines?"",
            settings,
            kernel);
        Console.WriteLine(result);
    }
    [Fact]
    public async Task RunNonStreamingChatCompletionApiWithParallelFunctionCallOptionAsync()
    {
        Kernel kernel = CreateKernel();
        FunctionChoiceBehaviorOptions options = new() { AllowParallelCalls = true };
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(options: options) };
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(
            ""Good morning! What’s the current time and latest news headlines?"",
            settings,
            kernel);
        Console.WriteLine(result);
    }
    [Fact]
    public async Task RunNonStreamingChatCompletionApiWithParallelFunctionCallAndConcurrentFunctionInvocationOptionsAsync()
    {
        Kernel kernel = CreateKernel();
        FunctionChoiceBehaviorOptions options = new() { AllowParallelCalls = true, AllowConcurrentInvocation = true };
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(options: options) };
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(
            ""Good morning! What’s the current time and latest news headlines?"",
            settings,
            kernel);
        Console.WriteLine(result);
    }
    private static Kernel CreateKernel()
    {
        IKernelBuilder builder = Kernel.CreateBuilder();
        builder.AddOpenAIChatCompletion(TestConfiguration.OpenAI.ChatModelId, TestConfiguration.OpenAI.ApiKey);
        Kernel kernel = builder.Build();
        kernel.ImportPluginFromFunctions(""HelperFunctions"",
        [
            kernel.CreateFunctionFromMethod(() => new List<string> { ""Squirrel Steals Show"", ""Dog Wins Lottery"" }, ""GetLatestNewsTitles"", ""Retrieves latest news titles.""),
            kernel.CreateFunctionFromMethod(() => DateTime.UtcNow.ToString(""R""), ""GetCurrentUtcDateTime"", ""Retrieves the current date time in UTC.""),
            kernel.CreateFunctionFromMethod((string cityName, string currentDateTime) =>
                cityName switch
                {
                    ""Boston"" => ""61 and rainy"",
                    ""London"" => ""55 and cloudy"",
                    ""Miami"" => ""80 and sunny"",
                    ""Paris"" => ""60 and rainy"",
                    ""Tokyo"" => ""50 and sunny"",
                    ""Sydney"" => ""75 and sunny"",
                    ""Tel Aviv"" => ""80 and sunny"",
                    _ => ""31 and snowing"",
                }, ""GetWeatherForCity"", ""Gets the current weather for the specified city""),
        ]);
        return kernel;
    }
}"
"<summary>
The following example shows how to use Semantic Kernel with the HuggingFace <see cref=""HuggingFaceTextGenerationService""/>
to implement function calling with the Nexus Raven model.
</summary>","public class NexusRaven_FunctionCalling(ITestOutputHelper output) : BaseTest(output)
{
    private Uri RavenEndpoint => new(""http:
    [Fact]
    public async Task InvokeTextGenerationAsync()
    {
        Kernel kernel = Kernel.CreateBuilder()
            .AddHuggingFaceTextGeneration(endpoint: RavenEndpoint)
            .Build();
        var textGeneration = kernel.GetRequiredService<ITextGenerationService>();
        var prompt = ""What is deep learning?"";
        var result = await textGeneration.GetTextContentsAsync(prompt);
        Console.WriteLine(result[0].ToString());
    }
    [Fact]
    public async Task InvokeTextGenerationWithFunctionCallingAsync()
    {
        using var handler = new LoggingHandler(new HttpClientHandler(), this.Output);
        using var httpClient = new HttpClient(handler);
        Kernel kernel = Kernel.CreateBuilder()
            .AddHuggingFaceTextGeneration(
                endpoint: RavenEndpoint,
                httpClient: httpClient)
            .Build();
        var plugin = ImportFunctions(kernel);
        var textGeneration = kernel.GetRequiredService<ITextGenerationService>();
        var template =
        """"""""
        {{#each (functions)}}
        Function:
        {{Name}}{{Signature}}
        """"""
        {{Description}}
        """"""
        {{/each}}
        User Query:{{prompt}}<human_end>
        """""""";
        var prompt = ""What is the weather like in Dublin?"";
        var functions = plugin.Select(f => new FunctionDefinition { Name = f.Name, Description = f.Description, Signature = CreateSignature(f) }).ToList();
        var executionSettings = new HuggingFacePromptExecutionSettings { Temperature = 0.001F, MaxNewTokens = 1024, ReturnFullText = false, DoSample = false }; 
        KernelArguments arguments = new(executionSettings) { { ""prompt"", prompt }, { ""functions"", functions } };
        var factory = new HandlebarsPromptTemplateFactory();
        var promptTemplate = factory.Create(new PromptTemplateConfig(template) { TemplateFormat = ""handlebars"" });
        var rendered = await promptTemplate.RenderAsync(kernel, arguments);
        Console.WriteLine("" Prompt:\n"
"<summary>
This sample shows different options for calling functions with multiple parameters.
The scenario is to search for invoices by customer name, purchase order, or vendor number.

The first sample uses multiple functions, one for each search criteria. One issue is that
as the number of functions increases then the reliability of the AI model to select the correct
function may decrease. To help avoid this issue, you can try filtering which functions are advertised
to the AI model e.g. if your application has come context information which indicates a purchase order
is available then you can filter out the customer name and vendor number functions.

The second sample uses a single function that takes an object with all search criteria. In this case some
of the search criteria are optional. Again as the number of parameters increases then the reliability of the
AI model may decrease. One advantage of this approach is that if the AI model can extra multiple search criteria
for the users ask then your plugin can use this information to provide more reliable results.

For both options care should be taken to validate the parameters that the AI model provides. E.g. the customer
name could be wrong or the purchase order could be invalid. It is worth catching these errors and responding the
AI model with a message that explains what has gone wrong to see how it responds. It may be able to retry the search
and get a successful response on the second attempt. Or it may decide to revert pack to the human in the loop to ask
for more information.
</summary>","public class MultipleFunctionsVsParameters(ITestOutputHelper output) : BaseTest(output)
{
    [Fact]
    public async Task InvoiceSearchBySampleAsync()
    {
        IKernelBuilder kernelBuilder = Kernel.CreateBuilder();
        kernelBuilder.Services.AddSingleton<IAutoFunctionInvocationFilter>(
            new AutoFunctionInvocationFilter(this.Output));
        kernelBuilder.AddOpenAIChatCompletion(
            modelId: TestConfiguration.OpenAI.ChatModelId,
            apiKey: TestConfiguration.OpenAI.ApiKey);
        kernelBuilder.Plugins.AddFromType<InvoiceSearchBy>();
        Kernel kernel = kernelBuilder.Build();
        await InvokePromptsAsync(kernel);
    }
    [Fact]
    public async Task InvoiceSearchSampleAsync()
    {
        IKernelBuilder kernelBuilder = Kernel.CreateBuilder();
        kernelBuilder.Services.AddSingleton<IAutoFunctionInvocationFilter>(
            new AutoFunctionInvocationFilter(this.Output));
        kernelBuilder.AddOpenAIChatCompletion(
            modelId: TestConfiguration.OpenAI.ChatModelId,
            apiKey: TestConfiguration.OpenAI.ApiKey);
        kernelBuilder.Plugins.AddFromType<InvoiceSearch>();
        Kernel kernel = kernelBuilder.Build();
        await InvokePromptsAsync(kernel);
    }
    private async Task InvokePromptsAsync(Kernel kernel)
    {
        OpenAIPromptExecutionSettings settings = new() { ToolCallBehavior = ToolCallBehavior.AutoInvokeKernelFunctions };
        Console.WriteLine(""Prompt: Show me the invoices for customer named Contoso Industries."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for customer named Contoso Industries."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Show me the invoices for purchase order PO123."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for purchase order PO123."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Show me the invoices for vendor number VN123."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for vendor number VN123."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Show me the invoices for Contoso Industries."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for Contoso Industries."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Show me the invoices for PO123."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for PO123."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Show me the invoices for VN123."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for VN123."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Zeigen Sie mir die Rechnungen für Contoso Industries."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Zeigen Sie mir die Rechnungen für Contoso Industries."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
    }
    private sealed class AutoFunctionInvocationFilter(ITestOutputHelper output) : IAutoFunctionInvocationFilter
    {
        public async Task OnAutoFunctionInvocationAsync(AutoFunctionInvocationContext context, Func<AutoFunctionInvocationContext, Task> next)
        {
            var functionName = context.Function.Name;
            var arguments = context.Arguments;
            output.WriteLine($""Function: {functionName} {JsonSerializer.Serialize(arguments)}"");
            await next(context);
        }
    }
    private sealed class InvoiceSearchBy
    {
        [KernelFunction]
        [Description(""Search for invoices by customer name."")]
        public IEnumerable<Invoice> SearchByCustomerName([Description(""The customer name."")] string customerName)
        {
            return
                [
                    new Invoice { CustomerName = customerName, PurchaseOrder = ""PO123"", VendorNumber = ""VN123"" },
                    new Invoice { CustomerName = customerName, PurchaseOrder = ""PO124"", VendorNumber = ""VN124"" },
                    new Invoice { CustomerName = customerName, PurchaseOrder = ""PO125"", VendorNumber = ""VN125"" },
                ];
        }
        [KernelFunction]
        [Description(""Search for invoices by purchase order."")]
        public IEnumerable<Invoice> SearchByPurchaseOrder([Description(""The purchase order. Purchase orders begin with a PN prefix."")] string purchaseOrder)
        {
            return
                [
                    new Invoice { CustomerName = ""Customer1"", PurchaseOrder = purchaseOrder, VendorNumber = ""VN123"" },
                    new Invoice { CustomerName = ""Customer2"", PurchaseOrder = purchaseOrder, VendorNumber = ""VN124"" },
                    new Invoice { CustomerName = ""Customer3"", PurchaseOrder = purchaseOrder, VendorNumber = ""VN125"" },
                ];
        }
        [KernelFunction]
        [Description(""Search for invoices by vendor number"")]
        public IEnumerable<Invoice> SearchByVendorNumber([Description(""The vendor number. Vendor numbers begin with a VN prefix."")] string vendorNumber)
        {
            return
                [
                    new Invoice { CustomerName = ""Customer1"", PurchaseOrder = ""PO123"", VendorNumber = vendorNumber },
                    new Invoice { CustomerName = ""Customer2"", PurchaseOrder = ""PO124"", VendorNumber = vendorNumber },
                    new Invoice { CustomerName = ""Customer3"", PurchaseOrder = ""PO125"", VendorNumber = vendorNumber },
                ];
        }
    }
    private sealed class InvoiceSearch
    {
        [KernelFunction]
        [Description(""Search for invoices by customer name or purchase order or vendor number."")]
        public IEnumerable<Invoice> Search([Description(""The invoice search request. It must contain either a customer name or a purchase order or a vendor number"")] InvoiceSearchRequest searchRequest)
        {
            return
                [
                    new Invoice
                    {
                        CustomerName = searchRequest.CustomerName ?? ""Customer1"",
                        PurchaseOrder = searchRequest.PurchaseOrder ?? ""PO123"",
                        VendorNumber = searchRequest.VendorNumber ?? ""VN123""
                    },
                    new Invoice
                    {
                        CustomerName = searchRequest.CustomerName ?? ""Customer2"",
                        PurchaseOrder = searchRequest.PurchaseOrder ?? ""PO124"",
                        VendorNumber = searchRequest.VendorNumber ?? ""VN124""
                    },
                    new Invoice
                    {
                        CustomerName = searchRequest.CustomerName ?? ""Customer3"",
                        PurchaseOrder = searchRequest.PurchaseOrder ?? ""PO125"",
                        VendorNumber = searchRequest.VendorNumber ?? ""VN125""
                    },
                ];
        }
    }
    private sealed class Invoice
    {
        public string CustomerName { get; set; }
        public string PurchaseOrder { get; set; }
        public string VendorNumber { get; set; }
    }
    [Description(""The invoice search request."")]
    private sealed class InvoiceSearchRequest
    {
        [Description(""Optional, customer name."")]
        public string? CustomerName { get; set; }
        [Description(""Optional, purchase order. Purchase orders begin with a PN prefix."")]
        public string? PurchaseOrder { get; set; }
        [Description(""Optional, vendor number. Vendor numbers begin with a VN prefix."")]
        public string? VendorNumber { get; set; }
    }
}"
"<summary>
These examples demonstrate two ways functions called by the Gemini LLM can be invoked using the SK streaming and non-streaming AI API:

1. Automatic Invocation by SK:
Functions called by the LLM are invoked automatically by SK. The results of these function invocations
are automatically added to the chat history and returned to the LLM. The LLM reasons about the chat history
and generates the final response.
This approach is fully automated and requires no manual intervention from the caller.

2. Manual Invocation by a Caller:
Functions called by the LLM are returned to the AI API caller. The caller controls the invocation phase where
they may decide which function to call, when to call them, how to handle exceptions, call them in parallel or sequentially, etc.
The caller then adds the function results or exceptions to the chat history and returns it to the LLM, which reasons about it
and generates the final response.
This approach is manual and provides more control over the function invocation phase to the caller.
</summary>","public sealed class Gemini_FunctionCalling(ITestOutputHelper output) : BaseTest(output)
{
    [RetryFact]
    public async Task GoogleAIAsync()
    {
        Console.WriteLine("""
"<summary>
An example showing how use the VectorStore abstractions to consume data from a Redis data store,
that was created using the MemoryStore abstractions.
</summary>","public class VectorStore_ConsumeFromMemoryStore_Redis(ITestOutputHelper output, VectorStoreRedisContainerFixture redisFixture) : BaseTest(output), IClassFixture<VectorStoreRedisContainerFixture>
{
    private const int VectorSize = 1536;
    private const string MemoryStoreCollectionName = ""memorystorecollection"";
    [Fact]
    public async Task ConsumeExampleAsync()
    {
        await redisFixture.ManualInitializeAsync();
        var textEmbeddingService = new AzureOpenAITextEmbeddingGenerationService(
            TestConfiguration.AzureOpenAIEmbeddings.DeploymentName,
            TestConfiguration.AzureOpenAIEmbeddings.Endpoint,
            new AzureCliCredential());
        var memoryStore = new RedisMemoryStore(""localhost:6379"", VectorSize);
        var vectorStore = new RedisVectorStore(
            ConnectionMultiplexer.Connect(""localhost:6379"").GetDatabase(),
            new() { StorageType = RedisStorageType.HashSet });
        await VectorStore_ConsumeFromMemoryStore_Common.CreateCollectionAndAddSampleDataAsync(
            memoryStore,
            MemoryStoreCollectionName,
            textEmbeddingService);
        var collection = vectorStore.GetCollection<string, VectorStoreRecord>(MemoryStoreCollectionName);
        await collection.CreateCollectionIfNotExistsAsync();
        var record1 = await collection.GetAsync(""11111111-1111-1111-1111-111111111111"");
        var record2 = await collection.GetAsync(""22222222-2222-2222-2222-222222222222"");
        var record3 = await collection.GetAsync(""33333333-3333-3333-3333-333333333333"", new() { IncludeVectors = true });
        Console.WriteLine($""Record 1: Key: {record1!.Key} Timestamp: {DateTimeOffset.FromUnixTimeMilliseconds(record1.Timestamp)} Metadata: {record1.Metadata} Embedding {record1.Embedding}"");
        Console.WriteLine($""Record 2: Key: {record2!.Key} Timestamp: {DateTimeOffset.FromUnixTimeMilliseconds(record2.Timestamp)} Metadata: {record2.Metadata} Embedding {record2.Embedding}"");
        Console.WriteLine($""Record 3: Key: {record3!.Key} Timestamp: {DateTimeOffset.FromUnixTimeMilliseconds(record3.Timestamp)} Metadata: {record3.Metadata} Embedding {record3.Embedding}"");
    }
    private sealed class VectorStoreRecord
    {
        [VectorStoreRecordKey]
        public string Key { get; set; }
        [VectorStoreRecordData(StoragePropertyName = ""metadata"")]
        public string Metadata { get; set; }
        [VectorStoreRecordData(StoragePropertyName = ""timestamp"")]
        public long Timestamp { get; set; }
        [VectorStoreRecordVector(VectorSize, StoragePropertyName = ""embedding"")]
        public ReadOnlyMemory<float> Embedding { get; set; }
    }
}"
"<summary>
A simple example showing how to ingest data into a vector store using <see cref=""QdrantVectorStore""/>.

The example shows the following steps:
1. Create an embedding generator.
2. Create a Qdrant Vector Store.
3. Ingest some data into the vector store.
4. Read the data back from the vector store.

You need a local instance of Docker running, since the associated fixture will try and start a Qdrant container in the local docker instance to run against.
</summary>","public class VectorStore_DataIngestion_Simple(ITestOutputHelper output, VectorStoreQdrantContainerFixture qdrantFixture) : BaseTest(output), IClassFixture<VectorStoreQdrantContainerFixture>
{
    [Fact]
    public async Task ExampleAsync()
    {
        var textEmbeddingGenerationService = new AzureOpenAITextEmbeddingGenerationService(
                TestConfiguration.AzureOpenAIEmbeddings.DeploymentName,
                TestConfiguration.AzureOpenAIEmbeddings.Endpoint,
                new AzureCliCredential());
        await qdrantFixture.ManualInitializeAsync();
        var vectorStore = new QdrantVectorStore(new QdrantClient(""localhost""));
        var collection = vectorStore.GetCollection<ulong, Glossary>(""skglossary"");
        await collection.CreateCollectionIfNotExistsAsync();
        var glossaryEntries = CreateGlossaryEntries().ToList();
        var tasks = glossaryEntries.Select(entry => Task.Run(async () =>
        {
            entry.DefinitionEmbedding = await textEmbeddingGenerationService.GenerateEmbeddingAsync(entry.Definition);
        }));
        await Task.WhenAll(tasks);
        var upsertedKeysTasks = glossaryEntries.Select(x => collection.UpsertAsync(x));
        var upsertedKeys = await Task.WhenAll(upsertedKeysTasks);
        var upsertedRecord = await collection.GetAsync(upsertedKeys.First(), new() { IncludeVectors = true });
        Console.WriteLine($""Upserted keys: {string.Join("", "", upsertedKeys)}"");
        Console.WriteLine($""Upserted record: {JsonSerializer.Serialize(upsertedRecord)}"");
    }
    private sealed class Glossary
    {
        [VectorStoreRecordKey]
        public ulong Key { get; set; }
        [VectorStoreRecordData]
        public string Term { get; set; }
        [VectorStoreRecordData]
        public string Definition { get; set; }
        [VectorStoreRecordVector(1536)]
        public ReadOnlyMemory<float> DefinitionEmbedding { get; set; }
    }
    private static IEnumerable<Glossary> CreateGlossaryEntries()
    {
        yield return new Glossary
        {
            Key = 1,
            Term = ""API"",
            Definition = ""Application Programming Interface. A set of rules and specifications that allow software components to communicate and exchange data.""
        };
        yield return new Glossary
        {
            Key = 2,
            Term = ""Connectors"",
            Definition = ""Connectors allow you to integrate with various services provide AI capabilities, including LLM, AudioToText, TextToAudio, Embedding generation, etc.""
        };
        yield return new Glossary
        {
            Key = 3,
            Term = ""RAG"",
            Definition = ""Retrieval Augmented Generation - a term that refers to the process of retrieving additional data to provide as context to an LLM to use when generating a response (completion) to a user’s question (prompt).""
        };
    }
}"
