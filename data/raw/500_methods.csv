Method
"public override string ToString()
        {
            return SimpleJson.SerializeObject(this) ?? string.Empty;
        }"
"internal static object GetAtIndex(IDictionary<string, object> obj, int index)
        {
            if (obj"
"public void Add(string key, object value)
        {
            _members.Add(key, value);
        }"
"public bool ContainsKey(string key)
        {
            return _members.ContainsKey(key);
        }"
"public bool Remove(string key)
        {
            return _members.Remove(key);
        }"
"public bool TryGetValue(string key, out object value)
        {
            return _members.TryGetValue(key, out value);
        }"
"public void Add(KeyValuePair<string, object> item)
        {
            _members.Add(item.Key, item.Value);
        }"
"public void Clear()
        {
            _members.Clear();
        }"
"public bool Contains(KeyValuePair<string, object> item)
        {
            return _members.ContainsKey(item.Key) && _members[item.Key]"
"public void CopyTo(KeyValuePair<string, object>[] array, int arrayIndex)
        {
            int num = Count;
            foreach (KeyValuePair<string, object> kvp in this)
            {
                array[arrayIndex++] = kvp;
                if (--num <= 0)
                    return;
            }
        }"
"public bool Remove(KeyValuePair<string, object> item)
        {
            return _members.Remove(item.Key);
        }"
"public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
        {
            return _members.GetEnumerator();
        }"
"public override string ToString()
        {
            return SimpleJson.SerializeObject(this);
        }"
"public override bool TryConvert(ConvertBinder binder, out object result)
        {
            if (binder"
"public override bool TryDeleteMember(DeleteMemberBinder binder)
        {
            if (binder"
"public override bool TryGetIndex(GetIndexBinder binder, object[] indexes, out object result)
        {
            if (indexes.Length"
"public override bool TryGetMember(GetMemberBinder binder, out object result)
        {
            object value;
            if (_members.TryGetValue(binder.Name, out value))
            {
                result = value;
                return true;
            }
            result = (object)null;
            return true;
        }"
"public override bool TrySetIndex(SetIndexBinder binder, object[] indexes, object value)
        {
            if (indexes.Length"
"public override bool TrySetMember(SetMemberBinder binder, object value)
        {
            if (binder"
"public override IEnumerable<string> GetDynamicMemberNames()
        {
            foreach (var key in Keys)
                yield return key;
        }"
"public static object DeserializeObject(string json)
        {
            object @object;
            if (TryDeserializeObject(json, out @object))
                return @object;
            throw new System.Runtime.Serialization.SerializationException(""Invalid JSON string"");
        }"
"public static bool TryDeserializeObject(string json, out object @object)
        {
            bool success = true;
            if (json != null)
            {
                char[] charArray = json.ToCharArray();
                int index = 0;
                @object = ParseValue(charArray, ref index, ref success);
            }
            else
                @object = null;
            return success;
        }"
"public static string SerializeObject(object json, IJsonSerializerStrategy jsonSerializerStrategy)
        {
            StringBuilder builder = new StringBuilder(BUILDER_CAPACITY);
            bool success = SerializeValue(jsonSerializerStrategy, json, builder);
            return (success ? builder.ToString() : null);
        }"
"protected static bool IsNumeric(object value)
        {
            if (value is sbyte) return true;
            if (value is byte) return true;
            if (value is short) return true;
            if (value is ushort) return true;
            if (value is int) return true;
            if (value is uint) return true;
            if (value is long) return true;
            if (value is ulong) return true;
            if (value is float) return true;
            if (value is double) return true;
            if (value is decimal) return true;
            return false;
        }"
"public bool Send()
        {
            CheckForServers();
            foreach (IPEndPoint Server in Servers)
            {
                int port = Server.Port;
                try
                {
                    SendQuery2(Server.Address, port);
                    break;
                }
                catch
                {
                    continue;
                }
            }
            return (this.Response != null);
        }"
"private void SendQuery(string ipAddress)
        {
            if (ipAddress"
"private byte[] MakeQuery()
        {
            int QueryID = new Random().Next(55555);
            byte[] Question = new byte[512];
            for (int i = 0; i < 512; i++)
                Question[i] = 0;
            Question[0] = (byte)(QueryID >> 8);
            Question[1] = (byte)(QueryID & byte.MaxValue);
            Question[2] = (byte)1; 
            Question[2] = (byte)((this.RecursionDesired) ? (Question[2] | 1) : (Question[2] & 254));
            Question[3] = (byte)0;
            Question[4] = (byte)0;
            Question[5] = (byte)1;
            string[] tokens = this.Domain.Split(new char[] { '.' });
            string label;
            int Cursor = 12;
            for (int j = 0; j < tokens.Length; j++)
            {
                label = tokens[j];
                Question[Cursor++] = (byte)(label.Length & byte.MaxValue);
                byte[] b = Encoding.ASCII.GetBytes(label);
                for (int k = 0; k < b.Length; k++)
                {
                    Question[Cursor++] = b[k];
                }
            }
            Question[Cursor++] = (byte)0;
            Question[Cursor++] = (byte)0;
            Question[Cursor++] = (byte)QueryType;
            Question[Cursor++] = (byte)0;
            Question[Cursor++] = (byte)QueryClass;
            return Question;
        }"
"private int ExtractName(int ResourceDataCursor, StringBuilder Name)
        {
            int LengthLabel = (data[ResourceDataCursor++] & byte.MaxValue);
            if (LengthLabel"
"private bool CheckForServers()
        {
            if (Servers.Count"
"private ArrayList GetDefaultServers()
        {
            ArrayList LocalServers = new ArrayList();
            try
            {
            }
            catch (Exception Ex)
            {
                Trace.WriteLine(""Could not get DNS servers from network adapter: "" + Ex.Message, ""OpenDNS"");
            }
            finally
            {
            }
            return LocalServers;
        }"
"public override string ToString()
		{
			StringBuilder sb = new StringBuilder();
			sb.Append(""Name="" + Name + ""&Type="" + Type + ""&Class="" + Class + ""&TTL=""+TimeToLive);
			return sb.ToString();
		}"
"public void Sort(SortFields sortField, bool isAscending)
		{
			switch (sortField)
			{
				case SortFields.Name:
					base.Sort(new NameComparer());
					break;
				case SortFields.TTL:
					base.Sort(new TTLComparer());
					break;
			}
			if (!isAscending) base.Reverse();
		}"
"public abstract byte[] getRow(int y, byte[] row);
      public abstract byte[] Matrix { get; }"
"public virtual LuminanceSource crop(int left, int top, int width, int height)
      {
         throw new NotSupportedException(""This luminance source does not support cropping."");
      }"
"public virtual LuminanceSource rotateCounterClockwise()
      {
         throw new NotSupportedException(""This luminance source does not support rotation."");
      }"
"public virtual LuminanceSource rotateCounterClockwise45()
      {
         throw new NotSupportedException(""This luminance source does not support rotation by 45 degrees."");
      }"
"protected internal Binarizer(LuminanceSource source)
      {
         if (source"
"public abstract BitArray getBlackRow(int y, BitArray row);
      public abstract BitMatrix BlackMatrix { get; }"
"public abstract Binarizer createBinarizer(LuminanceSource source);
      public int Width
      {
         get { return source.Width; }
      }"
"public BitArray getBlackRow(int y, BitArray row)
      {
         return binarizer.getBlackRow(y, row);
      }"
"public BinaryBitmap crop(int left, int top, int width, int height)
      {
         var newSource = binarizer.LuminanceSource.crop(left, top, width, height);
         return new BinaryBitmap(binarizer.createBinarizer(newSource));
      }"
"public BinaryBitmap rotateCounterClockwise()
      {
         var newSource = binarizer.LuminanceSource.rotateCounterClockwise();
         return new BinaryBitmap(binarizer.createBinarizer(newSource));
      }"
"public BinaryBitmap rotateCounterClockwise45()
      {
         LuminanceSource newSource = binarizer.LuminanceSource.rotateCounterClockwise45();
         return new BinaryBitmap(binarizer.createBinarizer(newSource));
      }"
"public override string ToString()
      {
         var blackMatrix = BlackMatrix;
         return blackMatrix != null ? blackMatrix.ToString() : String.Empty;
      }"
"public void putMetadata(ResultMetadataType type, Object value)
      {
         if (ResultMetadata"
"public void putAllMetadata(IDictionary<ResultMetadataType, object> metadata)
      {
         if (metadata != null)
         {
            if (ResultMetadata"
"public void addResultPoints(ResultPoint[] newPoints)
      {
         var oldPoints = ResultPoints;
         if (oldPoints"
"public override String ToString()
      {
         if (Text"
"public override bool Equals(Object other)
      {
         var otherPoint = other as ResultPoint;
         if (otherPoint"
"public override int GetHashCode()
      {
         return 31 * ((bytesX[0] << 24) + (bytesX[1] << 16) + (bytesX[2] << 8) + bytesX[3]) +
                      (bytesY[0] << 24) + (bytesY[1] << 16) + (bytesY[2] << 8) + bytesY[3];
      }"
"public override String ToString()
      {
         if (toString"
"public static void orderBestPatterns(ResultPoint[] patterns)
      {
         float zeroOneDistance = distance(patterns[0], patterns[1]);
         float oneTwoDistance = distance(patterns[1], patterns[2]);
         float zeroTwoDistance = distance(patterns[0], patterns[2]);
         ResultPoint pointA, pointB, pointC;
         if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance)
         {
            pointB = patterns[0];
            pointA = patterns[1];
            pointC = patterns[2];
         }
         else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance)
         {
            pointB = patterns[1];
            pointA = patterns[0];
            pointC = patterns[2];
         }
         else
         {
            pointB = patterns[2];
            pointA = patterns[0];
            pointC = patterns[1];
         }
         if (crossProductZ(pointA, pointB, pointC) < 0.0f)
         {
            ResultPoint temp = pointA;
            pointA = pointC;
            pointC = temp;
         }
         patterns[0] = pointA;
         patterns[1] = pointB;
         patterns[2] = pointC;
      }"
"private static float crossProductZ(ResultPoint pointA, ResultPoint pointB, ResultPoint pointC)
      {
         float bX = pointB.x;
         float bY = pointB.y;
         return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));
      }"
"override public byte[] getRow(int y, byte[] row)
      {
         int width = Width;
         if (row"
"public override LuminanceSource rotateCounterClockwise()
      {
         var rotatedLuminances = new byte[Width * Height];
         var newWidth = Height;
         var newHeight = Width;
         var localLuminances = Matrix;
         for (var yold = 0; yold < Height; yold++)
         {
            for (var xold = 0; xold < Width; xold++)
            {
               var ynew = newHeight - xold - 1;
               var xnew = yold;
               rotatedLuminances[ynew * newWidth + xnew] = localLuminances[yold * Width + xold];
            }
         }
         return CreateLuminanceSource(rotatedLuminances, newWidth, newHeight);
      }"
"public override LuminanceSource rotateCounterClockwise45()
      {
         return base.rotateCounterClockwise45();
      }"
"protected override LuminanceSource CreateLuminanceSource(byte[] newLuminances, int width, int height)
      {
         return new BitmapLuminanceSource(width, height) { luminances = newLuminances };
      }"
"protected Decoder getDecoder()
      {
         return decoder;
      }"
"public Result decode(BinaryBitmap image)
      {
         return decode(image, null);
      }"
"public Result decode(BinaryBitmap image, IDictionary<DecodeHintType, object> hints)
      {
         DecoderResult decoderResult;
         ResultPoint[] points;
         if (image"
"public void reset()
      {
      }"
"private static BitMatrix extractPureBits(BitMatrix image)
      {
         int[] leftTopBlack = image.getTopLeftOnBit();
         int[] rightBottomBlack = image.getBottomRightOnBit();
         if (leftTopBlack"
"public static QRCode encode(String content, ErrorCorrectionLevel ecLevel)
      {
         return encode(content, ecLevel, null);
      }"
"public static QRCode encode(String content,
                                ErrorCorrectionLevel ecLevel,
                                IDictionary<EncodeHintType, object> hints)
      {
#if !SILVERLIGHT || WINDOWS_PHONE
         String encoding = hints"
"internal static int getAlphanumericCode(int code)
      {
         if (code < ALPHANUMERIC_TABLE.Length)
         {
            return ALPHANUMERIC_TABLE[code];
         }
         return -1;
      }"
"public static Mode chooseMode(String content)
      {
         return chooseMode(content, null);
      }"
"private static Mode chooseMode(String content, String encoding)
      {
         return Mode.BYTE;
      }"
"internal static void terminateBits(int numDataBytes, BitArray bits)
      {
         int capacity = numDataBytes << 3;
         if (bits.Size > capacity)
         {
            throw new WriterException(""data bits cannot fit in the QR Code"" + bits.Size + "" > "" +
                capacity);
         }
         for (int i = 0; i < 4 && bits.Size < capacity; ++i)
         {
            bits.appendBit(false);
         }
         int numBitsInLastByte = bits.Size & 0x07;
         if (numBitsInLastByte > 0)
         {
            for (int i = numBitsInLastByte; i < 8; i++)
            {
               bits.appendBit(false);
            }
         }
         int numPaddingBytes = numDataBytes - bits.SizeInBytes;
         for (int i = 0; i < numPaddingBytes; ++i)
         {
            bits.appendBits((i & 0x01)"
"internal static void getNumDataBytesAndNumECBytesForBlockID(int numTotalBytes,
                                                         int numDataBytes,
                                                         int numRSBlocks,
                                                         int blockID,
                                                         int[] numDataBytesInBlock,
                                                         int[] numECBytesInBlock)
      {
         if (blockID >= numRSBlocks)
         {
            throw new WriterException(""Block ID too large"");
         }
         int numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
         int numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
         int numTotalBytesInGroup1 = numTotalBytes / numRSBlocks;
         int numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
         int numDataBytesInGroup1 = numDataBytes / numRSBlocks;
         int numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
         int numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
         int numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
         if (numEcBytesInGroup1 != numEcBytesInGroup2)
         {
            throw new WriterException(""EC bytes mismatch"");
         }
         if (numRSBlocks != numRsBlocksInGroup1 + numRsBlocksInGroup2)
         {
            throw new WriterException(""RS blocks mismatch"");
         }
         if (numTotalBytes !=
             ((numDataBytesInGroup1 + numEcBytesInGroup1) *
                 numRsBlocksInGroup1) +
                 ((numDataBytesInGroup2 + numEcBytesInGroup2) *
                     numRsBlocksInGroup2))
         {
            throw new WriterException(""Total bytes mismatch"");
         }
         if (blockID < numRsBlocksInGroup1)
         {
            numDataBytesInBlock[0] = numDataBytesInGroup1;
            numECBytesInBlock[0] = numEcBytesInGroup1;
         }
         else
         {
            numDataBytesInBlock[0] = numDataBytesInGroup2;
            numECBytesInBlock[0] = numEcBytesInGroup2;
         }
      }"
"internal static BitArray interleaveWithECBytes(BitArray bits,
                                             int numTotalBytes,
                                             int numDataBytes,
                                             int numRSBlocks)
      {
         if (bits.SizeInBytes != numDataBytes)
         {
            throw new WriterException(""Number of bits and data bytes does not match"");
         }
         int dataBytesOffset = 0;
         int maxNumDataBytes = 0;
         int maxNumEcBytes = 0;
         var blocks = new List<BlockPair>(numRSBlocks);
         for (int i = 0; i < numRSBlocks; ++i)
         {
            int[] numDataBytesInBlock = new int[1];
            int[] numEcBytesInBlock = new int[1];
            getNumDataBytesAndNumECBytesForBlockID(
                numTotalBytes, numDataBytes, numRSBlocks, i,
                numDataBytesInBlock, numEcBytesInBlock);
            int size = numDataBytesInBlock[0];
            byte[] dataBytes = new byte[size];
            bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);
            byte[] ecBytes = generateECBytes(dataBytes, numEcBytesInBlock[0]);
            blocks.Add(new BlockPair(dataBytes, ecBytes));
            maxNumDataBytes = Math.Max(maxNumDataBytes, size);
            maxNumEcBytes = Math.Max(maxNumEcBytes, ecBytes.Length);
            dataBytesOffset += numDataBytesInBlock[0];
         }
         if (numDataBytes != dataBytesOffset)
         {
            throw new WriterException(""Data bytes does not match offset"");
         }
         BitArray result = new BitArray();
         for (int i = 0; i < maxNumDataBytes; ++i)
         {
            foreach (BlockPair block in blocks)
            {
               byte[] dataBytes = block.DataBytes;
               if (i < dataBytes.Length)
               {
                  result.appendBits(dataBytes[i], 8);
               }
            }
         }
         for (int i = 0; i < maxNumEcBytes; ++i)
         {
            foreach (BlockPair block in blocks)
            {
               byte[] ecBytes = block.ErrorCorrectionBytes;
               if (i < ecBytes.Length)
               {
                  result.appendBits(ecBytes[i], 8);
               }
            }
         }
         if (numTotalBytes != result.SizeInBytes)
         {  
            throw new WriterException(""Interleaving error: "" + numTotalBytes + "" and "" +
                result.SizeInBytes + "" differ."");
         }
         return result;
      }"
"internal static void appendModeInfo(Mode mode, BitArray bits)
      {
         bits.appendBits(mode.Bits, 4);
      }"
"internal static void appendLengthInfo(int numLetters, Version version, Mode mode, BitArray bits)
      {
         int numBits = mode.getCharacterCountBits(version);
         if (numLetters >= (1 << numBits))
         {
            throw new WriterException(numLetters + "" is bigger than "" + ((1 << numBits) - 1));
         }
         bits.appendBits(numLetters, numBits);
      }"
"internal static void appendBytes(String content,
                              Mode mode,
                              BitArray bits,
                              String encoding)
      {
        if (mode.Equals(Mode.BYTE))
            append8BitBytes(content, bits, encoding);
            else
                throw new WriterException(""Invalid mode: "" + mode);
      }"
"public void set(int x, int y, byte value)
      {
         bytes[y][x] = value;
      }"
"public void set(int x, int y, bool value)
      {
         bytes[y][x] = (byte)(value ? 1 : 0);
      }"
"public void clear(byte value)
      {
         for (int y = 0; y < height; ++y)
         {
            for (int x = 0; x < width; ++x)
            {
               bytes[y][x] = value;
            }
         }
      }"
"override public String ToString()
      {
         var result = new StringBuilder(2 * width * height + 2);
         for (int y = 0; y < height; ++y)
         {
            for (int x = 0; x < width; ++x)
            {
               switch (bytes[y][x])
               {
                  case 0:
                     result.Append("" 0"");
                     break;
                  case 1:
                     result.Append("" 1"");
                     break;
                  default:
                     result.Append(""  "");
                     break;
               }
            }
            result.Append('\n');
         }
         return result.ToString();
      }"
"public static void buildMatrix(BitArray dataBits, ErrorCorrectionLevel ecLevel, Version version, int maskPattern, ByteMatrix matrix)
      {
         clearMatrix(matrix);
         embedBasicPatterns(version, matrix);
         embedTypeInfo(ecLevel, maskPattern, matrix);
         maybeEmbedVersionInfo(version, matrix);
         embedDataBits(dataBits, maskPattern, matrix);
      }"
"public static void embedBasicPatterns(Version version, ByteMatrix matrix)
      {
         embedPositionDetectionPatternsAndSeparators(matrix);
         embedDarkDotAtLeftBottomCorner(matrix);
         maybeEmbedPositionAdjustmentPatterns(version, matrix);
         embedTimingPatterns(matrix);
      }"
"public static void embedTypeInfo(ErrorCorrectionLevel ecLevel, int maskPattern, ByteMatrix matrix)
      {
         BitArray typeInfoBits = new BitArray();
         makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
         for (int i = 0; i < typeInfoBits.Size; ++i)
         {
            int bit = typeInfoBits[typeInfoBits.Size - 1 - i] ? 1 : 0;
            int x1 = TYPE_INFO_COORDINATES[i][0];
            int y1 = TYPE_INFO_COORDINATES[i][1];
            matrix[x1, y1] = bit;
            if (i < 8)
            {
               int x2 = matrix.Width - i - 1;
               int y2 = 8;
               matrix[x2, y2] = bit;
            }
            else
            {
               int x2 = 8;
               int y2 = matrix.Height - 7 + (i - 8);
               matrix[x2, y2] = bit;
            }
         }
      }"
"public static void maybeEmbedVersionInfo(Version version, ByteMatrix matrix)
      {
         if (version.VersionNumber < 7)
         {
            return; 
         }
         BitArray versionInfoBits = new BitArray();
         makeVersionInfoBits(version, versionInfoBits);
         int bitIndex = 6 * 3 - 1; 
         for (int i = 0; i < 6; ++i)
         {
            for (int j = 0; j < 3; ++j)
            {
               var bit = versionInfoBits[bitIndex] ? 1 : 0;
               bitIndex--;
               matrix[i, matrix.Height - 11 + j] = bit;
               matrix[matrix.Height - 11 + j, i] = bit;
            }
         }
      }"
"public static void embedDataBits(BitArray dataBits, int maskPattern, ByteMatrix matrix)
      {
         int bitIndex = 0;
         int direction = -1;
         int x = matrix.Width - 1;
         int y = matrix.Height - 1;
         while (x > 0)
         {
            if (x"
"public static int findMSBSet(int value_Renamed)
      {
         int numDigits = 0;
         while (value_Renamed != 0)
         {
            value_Renamed = (int)((uint)value_Renamed >> 1);
            ++numDigits;
         }
         return numDigits;
      }"
"public static int calculateBCHCode(int value, int poly)
      {
         int msbSetInPoly = findMSBSet(poly);
         value <<= msbSetInPoly - 1;
         while (findMSBSet(value) >= msbSetInPoly)
         {
            value ^= poly << (findMSBSet(value) - msbSetInPoly);
         }
         return value;
      }"
"public static void makeTypeInfoBits(ErrorCorrectionLevel ecLevel, int maskPattern, BitArray bits)
      {
         if (!QRCode.isValidMaskPattern(maskPattern))
         {
            throw new WriterException(""Invalid mask pattern"");
         }
         int typeInfo = (ecLevel.Bits << 3) | maskPattern;
         bits.appendBits(typeInfo, 5);
         int bchCode = calculateBCHCode(typeInfo, TYPE_INFO_POLY);
         bits.appendBits(bchCode, 10);
         BitArray maskBits = new BitArray();
         maskBits.appendBits(TYPE_INFO_MASK_PATTERN, 15);
         bits.xor(maskBits);
         if (bits.Size != 15)
         {
            throw new WriterException(""should not happen but we got: "" + bits.Size);
         }
      }"
"public static void makeVersionInfoBits(Version version, BitArray bits)
      {
         bits.appendBits(version.VersionNumber, 6);
         int bchCode = calculateBCHCode(version.VersionNumber, VERSION_INFO_POLY);
         bits.appendBits(bchCode, 12);
         if (bits.Size != 18)
         {
            throw new WriterException(""should not happen but we got: "" + bits.Size);
         }
      }"
"private static bool isEmpty(int value)
      {
         return value"
"private static void embedDarkDotAtLeftBottomCorner(ByteMatrix matrix)
      {
         if (matrix[8, matrix.Height - 8]"
"private static void embedPositionAdjustmentPattern(int xStart, int yStart, ByteMatrix matrix)
      {
         for (int y = 0; y < 5; ++y)
         {
            for (int x = 0; x < 5; ++x)
            {
               matrix[xStart + x, yStart + y] = POSITION_ADJUSTMENT_PATTERN[y][x];
            }
         }
      }"
"private static void embedPositionDetectionPatternsAndSeparators(ByteMatrix matrix)
      {
         int pdpWidth = POSITION_DETECTION_PATTERN[0].Length;
         embedPositionDetectionPattern(0, 0, matrix);
         embedPositionDetectionPattern(matrix.Width - pdpWidth, 0, matrix);
         embedPositionDetectionPattern(0, matrix.Width - pdpWidth, matrix);
         const int hspWidth = 8;
         embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
         embedHorizontalSeparationPattern(matrix.Width - hspWidth, hspWidth - 1, matrix);
         embedHorizontalSeparationPattern(0, matrix.Width - hspWidth, matrix);
         const int vspSize = 7;
         embedVerticalSeparationPattern(vspSize, 0, matrix);
         embedVerticalSeparationPattern(matrix.Height - vspSize - 1, 0, matrix);
         embedVerticalSeparationPattern(vspSize, matrix.Height - vspSize, matrix);
      }"
"private static void maybeEmbedPositionAdjustmentPatterns(Version version, ByteMatrix matrix)
      {
         if (version.VersionNumber < 2)
         {
            return;
         }
         int index = version.VersionNumber - 1;
         int[] coordinates = POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
         int numCoordinates = POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index].Length;
         for (int i = 0; i < numCoordinates; ++i)
         {
            for (int j = 0; j < numCoordinates; ++j)
            {
               int y = coordinates[i];
               int x = coordinates[j];
               if (x"
"public static int applyMaskPenaltyRule2(ByteMatrix matrix)
      {
         int penalty = 0;
         var array = matrix.Array;
         int width = matrix.Width;
         int height = matrix.Height;
         for (int y = 0; y < height - 1; y++)
         {
            for (int x = 0; x < width - 1; x++)
            {
               int value = array[y][x];
               if (value"
"public static int applyMaskPenaltyRule3(ByteMatrix matrix)
      {
         int numPenalties = 0;
         byte[][] array = matrix.Array;
         int width = matrix.Width;
         int height = matrix.Height;
         for (int y = 0; y < height; y++)
         {
            for (int x = 0; x < width; x++)
            {
               byte[] arrayY = array[y];  
               if (x + 6 < width &&
                   arrayY[x]"
"public static int applyMaskPenaltyRule4(ByteMatrix matrix)
      {
         int numDarkCells = 0;
         var array = matrix.Array;
         int width = matrix.Width;
         int height = matrix.Height;
         for (int y = 0; y < height; y++)
         {
            var arrayY = array[y];
            for (int x = 0; x < width; x++)
            {
               if (arrayY[x]"
"public static bool getDataMaskBit(int maskPattern, int x, int y)
      {
         int intermediate, temp;
         switch (maskPattern)
         {
            case 0:
               intermediate = (y + x) & 0x1;
               break;
            case 1:
               intermediate = y & 0x1;
               break;
            case 2:
               intermediate = x % 3;
               break;
            case 3:
               intermediate = (y + x) % 3;
               break;
            case 4:
               intermediate = (((int)((uint)y >> 1)) + (x / 3)) & 0x1;
               break;
            case 5:
               temp = y * x;
               intermediate = (temp & 0x1) + (temp % 3);
               break;
            case 6:
               temp = y * x;
               intermediate = (((temp & 0x1) + (temp % 3)) & 0x1);
               break;
            case 7:
               temp = y * x;
               intermediate = (((temp % 3) + ((y + x) & 0x1)) & 0x1);
               break;
            default:
               throw new ArgumentException(""Invalid mask pattern: "" + maskPattern);
         }
         return intermediate"
"private static int applyMaskPenaltyRule1Internal(ByteMatrix matrix, bool isHorizontal)
      {
         int penalty = 0;
         int iLimit = isHorizontal ? matrix.Height : matrix.Width;
         int jLimit = isHorizontal ? matrix.Width : matrix.Height;
         var array = matrix.Array;
         for (int i = 0; i < iLimit; i++)
         {
            int numSameBitCells = 0;
            int prevBit = -1;
            for (int j = 0; j < jLimit; j++)
            {
               int bit = isHorizontal ? array[i][j] : array[j][i];
               if (bit"
"internal static int numBitsDiffering(int a, int b)
      {
         a ^= b; 
         return BITS_SET_IN_HALF_BYTE[a & 0x0F] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 4)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 8)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 12)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 16)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 20)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 24)) & 0x0F)] +
            BITS_SET_IN_HALF_BYTE[(((int)((uint)a >> 28)) & 0x0F)];
      }"
"internal static FormatInformation decodeFormatInformation(int maskedFormatInfo1, int maskedFormatInfo2)
      {
         FormatInformation formatInfo = doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
         if (formatInfo != null)
         {
            return formatInfo;
         }
         return doDecodeFormatInformation(maskedFormatInfo1 ^ FORMAT_INFO_MASK_QR,
                                          maskedFormatInfo2 ^ FORMAT_INFO_MASK_QR);
      }"
"public int ordinal()
      {
         return ordinal_Renamed_Field;
      }"
"public override String ToString()
      {
         return name;
      }"
"public static ErrorCorrectionLevel forBits(int bits)
      {
         if (bits < 0 || bits >= FOR_BITS.Length)
         {
            throw new ArgumentException();
         }
         return FOR_BITS[bits];
      }"
"internal static DecoderResult decode(byte[] bytes,
                                           Version version,
                                           ErrorCorrectionLevel ecLevel,
                                           IDictionary<DecodeHintType, object> hints)
      {
         var bits = new BitSource(bytes);
         var result = new StringBuilder(50);
         var byteSegments = new List<byte[]>(1);
         var symbolSequence = -1;
         var parityData = -1;
         try
         {
            bool fc1InEffect = false;
            Mode mode;
            do
            {
               if (bits.available() < 4)
               {
                  mode = Mode.TERMINATOR;
               }
               else
               {
                  try
                  {
                     mode = Mode.forBits(bits.readBits(4)); 
                  }
                  catch (ArgumentException)
                  {
                     return null;
                  }
               }
               if (mode != Mode.TERMINATOR)
               {
                  if (mode"
"private static bool decodeHanziSegment(BitSource bits,
                                             StringBuilder result,
                                             int count)
      {
         if (count * 13 > bits.available())
         {
            return false;
         }
         byte[] buffer = new byte[2 * count];
         int offset = 0;
         while (count > 0)
         {
            int twoBytes = bits.readBits(13);
            int assembledTwoBytes = ((twoBytes / 0x060) << 8) | (twoBytes % 0x060);
            if (assembledTwoBytes < 0x003BF)
            {
               assembledTwoBytes += 0x0A1A1;
            }
            else
            {
               assembledTwoBytes += 0x0A6A1;
            }
            buffer[offset] = (byte)((assembledTwoBytes >> 8) & 0xFF);
            buffer[offset + 1] = (byte)(assembledTwoBytes & 0xFF);
            offset += 2;
            count--;
         }
         try
         {
            result.Append(Encoding.GetEncoding(StringUtils.GB2312).GetString(buffer, 0, buffer.Length));
         }
#if (WINDOWS_PHONE70 || WINDOWS_PHONE71 || SILVERLIGHT4 || SILVERLIGHT5 || NETFX_CORE || MONOANDROID || MONOTOUCH)
         catch (ArgumentException)
         {
            try
            {
               result.Append(Encoding.GetEncoding(""UTF-8"").GetString(buffer, 0, buffer.Length));
            }
            catch (Exception)
            {
               return false;
            }
         }
#endif
         catch (Exception)
         {
            return false;
         }
         return true;
      }"
"public DecoderResult decode(bool[][] image, IDictionary<DecodeHintType, object> hints)
      {
         var dimension = image.Length;
         var bits = new BitMatrix(dimension);
         for (int i = 0; i < dimension; i++)
         {
            for (int j = 0; j < dimension; j++)
            {
               bits[j, i] = image[i][j];
            }
         }
         return decode(bits, hints);
      }"
"public DecoderResult decode(BitMatrix bits, IDictionary<DecodeHintType, object> hints)
      {
         var parser = BitMatrixParser.createBitMatrixParser(bits);
         if (parser"
"private bool correctErrors(byte[] codewordBytes, int numDataCodewords)
      {
         int numCodewords = codewordBytes.Length;
         int[] codewordsInts = new int[numCodewords];
         for (int i = 0; i < numCodewords; i++)
         {
            codewordsInts[i] = codewordBytes[i] & 0xFF;
         }
         int numECCodewords = codewordBytes.Length - numDataCodewords;
         if (!rsDecoder.decode(codewordsInts, numECCodewords))
            return false;
         for (int i = 0; i < numDataCodewords; i++)
         {
            codewordBytes[i] = (byte)codewordsInts[i];
         }
         return true;
      }"
"internal static DataBlock[] getDataBlocks(byte[] rawCodewords, Version version, ErrorCorrectionLevel ecLevel)
      {
         if (rawCodewords.Length != version.TotalCodewords)
         {
            throw new System.ArgumentException();
         }
         Version.ECBlocks ecBlocks = version.getECBlocksForLevel(ecLevel);
         int totalBlocks = 0;
         Version.ECB[] ecBlockArray = ecBlocks.getECBlocks();
         foreach (var ecBlock in ecBlockArray)
         {
            totalBlocks += ecBlock.Count;
         }
         DataBlock[] result = new DataBlock[totalBlocks];
         int numResultBlocks = 0;
         foreach (var ecBlock in ecBlockArray)
         {
            for (int i = 0; i < ecBlock.Count; i++)
            {
               int numDataCodewords = ecBlock.DataCodewords;
               int numBlockCodewords = ecBlocks.ECCodewordsPerBlock + numDataCodewords;
               result[numResultBlocks++] = new DataBlock(numDataCodewords, new byte[numBlockCodewords]);
            }
         }
         int shorterBlocksTotalCodewords = result[0].codewords.Length;
         int longerBlocksStartAt = result.Length - 1;
         while (longerBlocksStartAt >= 0)
         {
            int numCodewords = result[longerBlocksStartAt].codewords.Length;
            if (numCodewords"
"public static Version getProvisionalVersionForDimension(int dimension)
      {
         if (dimension % 4 != 1)
         {
            return null;
         }
         try
         {
            return getVersionForNumber((dimension - 17) >> 2);
         }
         catch (ArgumentException)
         {
            return null;
         }
      }"
"public static Version getVersionForNumber(int versionNumber)
      {
         if (versionNumber < 1 || versionNumber > 40)
         {
            throw new ArgumentException();
         }
         return VERSIONS[versionNumber - 1];
      }"
"internal BitMatrix buildFunctionPattern()
      {
         int dimension = DimensionForVersion;
         BitMatrix bitMatrix = new BitMatrix(dimension);
         bitMatrix.setRegion(0, 0, 9, 9);
         bitMatrix.setRegion(dimension - 8, 0, 8, 9);
         bitMatrix.setRegion(0, dimension - 8, 9, 8);
         int max = alignmentPatternCenters.Length;
         for (int x = 0; x < max; x++)
         {
            int i = alignmentPatternCenters[x] - 2;
            for (int y = 0; y < max; y++)
            {
               if ((x"
"public ECB[] getECBlocks()
         {
            return ecBlocks;
         }"
"public override String ToString()
      {
         return Convert.ToString(versionNumber);
      }"
"private static Version[] buildVersions()
      {
         return new Version[]{
            new Version(1, new int[]{},
               new ECBlocks(7, new ECB(1, 19)),
               new ECBlocks(10, new ECB(1, 16)),
               new ECBlocks(13, new ECB(1, 13)),
               new ECBlocks(17, new ECB(1, 9))),
            new Version(2, new int[]{6, 18},
               new ECBlocks(10, new ECB(1, 34)),
               new ECBlocks(16, new ECB(1, 28)),
               new ECBlocks(22, new ECB(1, 22)),
               new ECBlocks(28, new ECB(1, 16))),
            new Version(3, new int[]{6, 22},
               new ECBlocks(15, new ECB(1, 55)),
               new ECBlocks(26, new ECB(1, 44)),
               new ECBlocks(18, new ECB(2, 17)),
               new ECBlocks(22, new ECB(2, 13))),
            new Version(4, new int[]{6, 26},
               new ECBlocks(20, new ECB(1, 80)),
               new ECBlocks(18, new ECB(2, 32)),
               new ECBlocks(26, new ECB(2, 24)),
               new ECBlocks(16, new ECB(4, 9))),
            new Version(5, new int[]{6, 30},
               new ECBlocks(26, new ECB(1, 108)),
               new ECBlocks(24, new ECB(2, 43)),
               new ECBlocks(18, new ECB(2, 15),
                  new ECB(2, 16)),
               new ECBlocks(22, new ECB(2, 11),
                  new ECB(2, 12))),
            new Version(6, new int[]{6, 34},
               new ECBlocks(18, new ECB(2, 68)),
               new ECBlocks(16, new ECB(4, 27)),
               new ECBlocks(24, new ECB(4, 19)),
               new ECBlocks(28, new ECB(4, 15))),
            new Version(7, new int[]{6, 22, 38},
               new ECBlocks(20, new ECB(2, 78)),
               new ECBlocks(18, new ECB(4, 31)),
               new ECBlocks(18, new ECB(2, 14),
                  new ECB(4, 15)),
               new ECBlocks(26, new ECB(4, 13),
                  new ECB(1, 14))),
            new Version(8, new int[]{6, 24, 42},
               new ECBlocks(24, new ECB(2, 97)),
               new ECBlocks(22, new ECB(2, 38),
                  new ECB(2, 39)),
               new ECBlocks(22, new ECB(4, 18),
                  new ECB(2, 19)),
               new ECBlocks(26, new ECB(4, 14),
                  new ECB(2, 15))),
            new Version(9, new int[]{6, 26, 46},
               new ECBlocks(30, new ECB(2, 116)),
               new ECBlocks(22, new ECB(3, 36),
                  new ECB(2, 37)),
               new ECBlocks(20, new ECB(4, 16),
                  new ECB(4, 17)),
               new ECBlocks(24, new ECB(4, 12),
                  new ECB(4, 13))),
            new Version(10, new int[]{6, 28, 50},
               new ECBlocks(18, new ECB(2, 68),
                  new ECB(2, 69)),
               new ECBlocks(26, new ECB(4, 43),
                  new ECB(1, 44)),
               new ECBlocks(24, new ECB(6, 19),
                  new ECB(2, 20)),
               new ECBlocks(28, new ECB(6, 15),
                  new ECB(2, 16))),
            new Version(11, new int[]{6, 30, 54}, new ECBlocks(20, new ECB(4, 81)),
				new ECBlocks(30, new ECB(1, 50), new ECB(4, 51)), new ECBlocks(28, new ECB(4, 22), new ECB(4, 23)), new ECBlocks(24, new ECB(3, 12), new ECB(8, 13))), new Version(12, new int[]{6, 32, 58}, new ECBlocks(24, new ECB(2, 92), new ECB(2, 93)), new ECBlocks(22, new ECB(6, 36), new ECB(2, 37)), new ECBlocks(26, new ECB(4, 20), new ECB(6, 21)), new ECBlocks(28, new ECB(7, 14), new ECB(4, 15))), new Version(13, new int[]{6, 34, 62}, new ECBlocks(26, new ECB(4, 107)), new ECBlocks(22, new ECB(8, 37), new ECB(1, 38)), new ECBlocks(24, new ECB(8, 20), new ECB(4, 21)), new ECBlocks(22, new ECB(12, 11), new ECB(4, 12))), new Version(14, new int[]{6, 26, 46, 66}, new ECBlocks(30, new ECB(3, 115), new ECB(1, 116)), new ECBlocks(24, new ECB(4, 40), new ECB(5, 41)), new ECBlocks(20, new ECB(11, 16), new ECB(5, 17)), new ECBlocks(24, new ECB(11, 12), new ECB(5, 13))), new Version(15, new int[]{6, 26, 48, 70}, new ECBlocks(22, new ECB(5, 87), new ECB(1, 88)), new ECBlocks(24, new ECB(5, 41), new ECB(5, 42)), new ECBlocks(30, new ECB(5, 24), new ECB(7, 25)), new ECBlocks(24, new ECB(11, 12), new ECB(7, 13))), new Version(16, new int[]{6, 26, 50, 74}, new ECBlocks(24, new ECB(5, 98), new ECB(1, 99)), new ECBlocks(28, new ECB(7, 45), new ECB(3, 46)), new ECBlocks(24, new ECB(15, 19), new ECB(2, 20)), new ECBlocks(30, new ECB(3, 15), new ECB(13, 16))), new Version(17, new int[]{6, 30, 54, 78}, new ECBlocks(28, new ECB(1, 107), new ECB(5, 108)), new ECBlocks(28, new ECB(10, 46), new ECB(1, 47)), new ECBlocks(28, new ECB(1, 22), new ECB(15, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(17, 15))), new Version(18, new int[]{6, 30, 56, 82}, new ECBlocks(30, new ECB(5, 120), new ECB(1, 121)), new ECBlocks(26, new ECB(9, 43), new ECB(4, 44)), new ECBlocks(28, new ECB(17, 22), new ECB(1, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(19, 15))), new Version(19, new int[]{6, 30, 58, 86}, new ECBlocks(28, new ECB(3, 113), new ECB(4, 114)), new ECBlocks(26, new ECB(3, 44), new ECB(11, 45)), new ECBlocks(26, new ECB(17, 21),
				new ECB(4, 22)), new ECBlocks(26, new ECB(9, 13), new ECB(16, 14))), new Version(20, new int[]{6, 34, 62, 90}, new ECBlocks(28, new ECB(3, 107), new ECB(5, 108)), new ECBlocks(26, new ECB(3, 41), new ECB(13, 42)), new ECBlocks(30, new ECB(15, 24), new ECB(5, 25)), new ECBlocks(28, new ECB(15, 15), new ECB(10, 16))), new Version(21, new int[]{6, 28, 50, 72, 94}, new ECBlocks(28, new ECB(4, 116), new ECB(4, 117)), new ECBlocks(26, new ECB(17, 42)), new ECBlocks(28, new ECB(17, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(19, 16), new ECB(6, 17))), new Version(22, new int[]{6, 26, 50, 74, 98}, new ECBlocks(28, new ECB(2, 111), new ECB(7, 112)), new ECBlocks(28, new ECB(17, 46)), new ECBlocks(30, new ECB(7, 24), new ECB(16, 25)), new ECBlocks(24, new ECB(34, 13))), new Version(23, new int[]{6, 30, 54, 74, 102}, new ECBlocks(30, new ECB(4, 121), new ECB(5, 122)), new ECBlocks(28, new ECB(4, 47), new ECB(14, 48)), new ECBlocks(30, new ECB(11, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(16, 15), new ECB(14, 16))), new Version(24, new int[]{6, 28, 54, 80, 106}, new ECBlocks(30, new ECB(6, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(6, 45), new ECB(14, 46)), new ECBlocks(30, new ECB(11, 24), new ECB(16, 25)), new ECBlocks(30, new ECB(30, 16), new ECB(2, 17))), new Version(25, new int[]{6, 32, 58, 84, 110}, new ECBlocks(26, new ECB(8, 106), new ECB(4, 107)), new ECBlocks(28, new ECB(8, 47), new ECB(13, 48)), new ECBlocks(30, new ECB(7, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(13, 16))), new Version(26, new int[]{6, 30, 58, 86, 114}, new ECBlocks(28, new ECB(10, 114), new ECB(2, 115)), new ECBlocks(28, new ECB(19, 46), new ECB(4, 47)), new ECBlocks(28, new ECB(28, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(33, 16), new ECB(4, 17))), new Version(27, new int[]{6, 34, 62, 90, 118}, new ECBlocks(30, new ECB(8, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(22, 45), new ECB(3, 46)), new ECBlocks(30, new ECB(8, 23), new ECB(26, 24)), new ECBlocks(30, new ECB(12, 15),
				new ECB(28, 16))), new Version(28, new int[]{6, 26, 50, 74, 98, 122}, new ECBlocks(30, new ECB(3, 117), new ECB(10, 118)), new ECBlocks(28, new ECB(3, 45), new ECB(23, 46)), new ECBlocks(30, new ECB(4, 24), new ECB(31, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(31, 16))), new Version(29, new int[]{6, 30, 54, 78, 102, 126}, new ECBlocks(30, new ECB(7, 116), new ECB(7, 117)), new ECBlocks(28, new ECB(21, 45), new ECB(7, 46)), new ECBlocks(30, new ECB(1, 23), new ECB(37, 24)), new ECBlocks(30, new ECB(19, 15), new ECB(26, 16))), new Version(30, new int[]{6, 26, 52, 78, 104, 130}, new ECBlocks(30, new ECB(5, 115), new ECB(10, 116)), new ECBlocks(28, new ECB(19, 47), new ECB(10, 48)), new ECBlocks(30, new ECB(15, 24), new ECB(25, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(25, 16))), new Version(31, new int[]{6, 30, 56, 82, 108, 134}, new ECBlocks(30, new ECB(13, 115), new ECB(3, 116)), new ECBlocks(28, new ECB(2, 46), new ECB(29, 47)), new ECBlocks(30, new ECB(42, 24), new ECB(1, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(28, 16))), new Version(32, new int[]{6, 34, 60, 86, 112, 138}, new ECBlocks(30, new ECB(17, 115)), new ECBlocks(28, new ECB(10, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(10, 24), new ECB(35, 25)), new ECBlocks(30, new ECB(19, 15), new ECB(35, 16))), new Version(33, new int[]{6, 30, 58, 86, 114, 142}, new ECBlocks(30, new ECB(17, 115), new ECB(1, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(21, 47)), new ECBlocks(30, new ECB(29, 24), new ECB(19, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(46, 16))), new Version(34, new int[]{6, 34, 62, 90, 118, 146}, new ECBlocks(30, new ECB(13, 115), new ECB(6, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(44, 24), new ECB(7, 25)), new ECBlocks(30, new ECB(59, 16), new ECB(1, 17))), new Version(35, new int[]{6, 30, 54, 78, 102, 126, 150}, new ECBlocks(30, new ECB(12, 121), new ECB(7, 122)), new ECBlocks(28, new ECB(12, 47), new ECB(26, 48)), new ECBlocks(30, new ECB(39, 24), new
				ECB(14, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(41, 16))), new Version(36, new int[]{6, 24, 50, 76, 102, 128, 154}, new ECBlocks(30, new ECB(6, 121), new ECB(14, 122)), new ECBlocks(28, new ECB(6, 47), new ECB(34, 48)), new ECBlocks(30, new ECB(46, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(2, 15), new ECB(64, 16))), new Version(37, new int[]{6, 28, 54, 80, 106, 132, 158}, new ECBlocks(30, new ECB(17, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(29, 46), new ECB(14, 47)), new ECBlocks(30, new ECB(49, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(24, 15), new ECB(46, 16))), new Version(38, new int[]{6, 32, 58, 84, 110, 136, 162}, new ECBlocks(30, new ECB(4, 122), new ECB(18, 123)), new ECBlocks(28, new ECB(13, 46), new ECB(32, 47)), new ECBlocks(30, new ECB(48, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(42, 15), new ECB(32, 16))), new Version(39, new int[]{6, 26, 54, 82, 110, 138, 166}, new ECBlocks(30, new ECB(20, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(40, 47), new ECB(7, 48)), new ECBlocks(30, new ECB(43, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(10, 15), new ECB(67, 16))), new Version(40, new int[]{6, 30, 58, 86, 114, 142, 170}, new ECBlocks(30, new ECB(19, 118), new ECB(6, 119)), new ECBlocks(28, new ECB(18, 47), new ECB(31, 48)), new ECBlocks(30, new ECB(34, 24), new ECB(34, 25)), new ECBlocks(30, new ECB(20, 15), new ECB(61, 16)))};
      }"
"internal FormatInformation readFormatInformation()
      {
         if (parsedFormatInfo != null)
         {
            return parsedFormatInfo;
         }
         int formatInfoBits1 = 0;
         for (int i = 0; i < 6; i++)
         {
            formatInfoBits1 = copyBit(i, 8, formatInfoBits1);
         }
         formatInfoBits1 = copyBit(7, 8, formatInfoBits1);
         formatInfoBits1 = copyBit(8, 8, formatInfoBits1);
         formatInfoBits1 = copyBit(8, 7, formatInfoBits1);
         for (int j = 5; j >= 0; j--)
         {
            formatInfoBits1 = copyBit(8, j, formatInfoBits1);
         }
         int dimension = bitMatrix.Height;
         int formatInfoBits2 = 0;
         int jMin = dimension - 7;
         for (int j = dimension - 1; j >= jMin; j--)
         {
            formatInfoBits2 = copyBit(8, j, formatInfoBits2);
         }
         for (int i = dimension - 8; i < dimension; i++)
         {
            formatInfoBits2 = copyBit(i, 8, formatInfoBits2);
         }
         parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
         if (parsedFormatInfo != null)
         {
            return parsedFormatInfo;
         }
         return null;
      }"
"internal Version readVersion()
      {
         if (parsedVersion != null)
         {
            return parsedVersion;
         }
         int dimension = bitMatrix.Height;
         int provisionalVersion = (dimension - 17) >> 2;
         if (provisionalVersion <= 6)
         {
            return Version.getVersionForNumber(provisionalVersion);
         }
         int versionBits = 0;
         int ijMin = dimension - 11;
         for (int j = 5; j >= 0; j--)
         {
            for (int i = dimension - 9; i >= ijMin; i--)
            {
               versionBits = copyBit(i, j, versionBits);
            }
         }
         parsedVersion = Version.decodeVersionInformation(versionBits);
         if (parsedVersion != null && parsedVersion.DimensionForVersion"
"internal byte[] readCodewords()
      {
         FormatInformation formatInfo = readFormatInformation();
         if (formatInfo"
"public static Mode forBits(int bits)
      {
         switch (bits)
         {
            case 0x0:
               return TERMINATOR;
            case 0x1:
               return NUMERIC;
            case 0x2:
               return ALPHANUMERIC;
            case 0x3:
               return STRUCTURED_APPEND;
            case 0x4:
               return BYTE;
            case 0x5:
               return FNC1_FIRST_POSITION;
            case 0x7:
               return ECI;
            case 0x8:
               return KANJI;
            case 0x9:
               return FNC1_SECOND_POSITION;
            case 0xD:
               return HANZI;
            default:
               throw new ArgumentException();
         }
      }"
"public override String ToString()
      {
         return name;
      }"
"public void applyMirroredCorrection(ResultPoint[] points)
      {
         if (!mirrored || points"
"internal void unmaskBitMatrix(BitMatrix bits, int dimension)
      {
         for (int i = 0; i < dimension; i++)
         {
            for (int j = 0; j < dimension; j++)
            {
               if (isMasked(i, j))
               {
                  bits.flip(j, i);
               }
            }
         }
      }"
"internal override bool isMasked(int i, int j)
         {
            return ((i + j) & 0x01)"
"internal override bool isMasked(int i, int j)
         {
            return (i & 0x01)"
"internal override bool isMasked(int i, int j)
         {
            return j % 3"
"internal override bool isMasked(int i, int j)
         {
            return (i + j) % 3"
"internal override bool isMasked(int i, int j)
         {
            return ((((int)((uint)i >> 1)) + (j / 3)) & 0x01)"
"internal override bool isMasked(int i, int j)
         {
            int temp = i * j;
            return (temp & 0x01) + (temp % 3)"
"internal override bool isMasked(int i, int j)
         {
            int temp = i * j;
            return (((temp & 0x01) + (temp % 3)) & 0x01)"
"internal override bool isMasked(int i, int j)
         {
            return ((((i + j) & 0x01) + ((i * j) % 3)) & 0x01)"
"public virtual DetectorResult detect()
      {
         return detect(null);
      }"
"public virtual DetectorResult detect(IDictionary<DecodeHintType, object> hints)
      {
         resultPointCallback = hints"
"protected internal virtual DetectorResult processFinderPatternInfo(FinderPatternInfo info)
      {
         FinderPattern topLeft = info.TopLeft;
         FinderPattern topRight = info.TopRight;
         FinderPattern bottomLeft = info.BottomLeft;
         float moduleSize = calculateModuleSize(topLeft, topRight, bottomLeft);
         if (moduleSize < 1.0f)
         {
            return null;
         }
         int dimension;
         if (!computeDimension(topLeft, topRight, bottomLeft, moduleSize, out dimension))
            return null;
         Internal.Version provisionalVersion = Internal.Version.getProvisionalVersionForDimension(dimension);
         if (provisionalVersion"
"private static bool computeDimension(ResultPoint topLeft, ResultPoint topRight, ResultPoint bottomLeft, float moduleSize, out int dimension)
      {
         int tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);
         int tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);
         dimension = ((tltrCentersDimension + tlblCentersDimension) >> 1) + 7;
         switch (dimension & 0x03)
         {
            case 0:
               dimension++;
               break;
            case 2:
               dimension--;
               break;
            case 3:
               return true;
         }
         return true;
      }"
"protected internal virtual float calculateModuleSize(ResultPoint topLeft, ResultPoint topRight, ResultPoint bottomLeft)
      {
         return (calculateModuleSizeOneWay(topLeft, topRight) + calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0f;
      }"
"private float calculateModuleSizeOneWay(ResultPoint pattern, ResultPoint otherPattern)
      {
         float moduleSizeEst1 = sizeOfBlackWhiteBlackRunBothWays((int)pattern.X, (int)pattern.Y, (int)otherPattern.X, (int)otherPattern.Y);
         float moduleSizeEst2 = sizeOfBlackWhiteBlackRunBothWays((int)otherPattern.X, (int)otherPattern.Y, (int)pattern.X, (int)pattern.Y);
         if (Single.IsNaN(moduleSizeEst1))
         {
            return moduleSizeEst2 / 7.0f;
         }
         if (Single.IsNaN(moduleSizeEst2))
         {
            return moduleSizeEst1 / 7.0f;
         }
         return (moduleSizeEst1 + moduleSizeEst2) / 14.0f;
      }"
"private float sizeOfBlackWhiteBlackRunBothWays(int fromX, int fromY, int toX, int toY)
      {
         float result = sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
         float scale = 1.0f;
         int otherToX = fromX - (toX - fromX);
         if (otherToX < 0)
         {
            scale = (float)fromX / (float)(fromX - otherToX);
            otherToX = 0;
         }
         else if (otherToX >= image.Width)
         {
            scale = (float)(image.Width - 1 - fromX) / (float)(otherToX - fromX);
            otherToX = image.Width - 1;
         }
         int otherToY = (int)(fromY - (toY - fromY) * scale);
         scale = 1.0f;
         if (otherToY < 0)
         {
            scale = (float)fromY / (float)(fromY - otherToY);
            otherToY = 0;
         }
         else if (otherToY >= image.Height)
         {
            scale = (float)(image.Height - 1 - fromY) / (float)(otherToY - fromY);
            otherToY = image.Height - 1;
         }
         otherToX = (int)(fromX + (otherToX - fromX) * scale);
         result += sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
         return result - 1.0f; 
      }"
"private float sizeOfBlackWhiteBlackRun(int fromX, int fromY, int toX, int toY)
      {
         bool steep = Math.Abs(toY - fromY) > Math.Abs(toX - fromX);
         if (steep)
         {
            int temp = fromX;
            fromX = fromY;
            fromY = temp;
            temp = toX;
            toX = toY;
            toY = temp;
         }
         int dx = Math.Abs(toX - fromX);
         int dy = Math.Abs(toY - fromY);
         int error = -dx >> 1;
         int xstep = fromX < toX ? 1 : -1;
         int ystep = fromY < toY ? 1 : -1;
         int state = 0;"
"protected AlignmentPattern findAlignmentInRegion(float overallEstModuleSize, int estAlignmentX, int estAlignmentY, float allowanceFactor)
      {
         int allowance = (int)(allowanceFactor * overallEstModuleSize);
         int alignmentAreaLeftX = Math.Max(0, estAlignmentX - allowance);
         int alignmentAreaRightX = Math.Min(image.Width - 1, estAlignmentX + allowance);
         if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3)
         {
            return null;
         }
         int alignmentAreaTopY = Math.Max(0, estAlignmentY - allowance);
         int alignmentAreaBottomY = Math.Min(image.Height - 1, estAlignmentY + allowance);
         var alignmentFinder = new AlignmentPatternFinder(
            image,
            alignmentAreaLeftX,
            alignmentAreaTopY,
            alignmentAreaRightX - alignmentAreaLeftX,
            alignmentAreaBottomY - alignmentAreaTopY,
            overallEstModuleSize,
            resultPointCallback);
         return alignmentFinder.find();
      }"
"internal void incrementCount()
      {
         this.count++;
      }"
"internal bool aboutEquals(float moduleSize, float i, float j)
      {
         if (Math.Abs(i - Y) <= moduleSize && Math.Abs(j - X) <= moduleSize)
         {
            float moduleSizeDiff = Math.Abs(moduleSize - estimatedModuleSize);
            return moduleSizeDiff <= 1.0f || moduleSizeDiff <= estimatedModuleSize;
         }
         return false;
      }"
"internal FinderPattern combineEstimate(float i, float j, float newModuleSize)
      {
         int combinedCount = count + 1;
         float combinedX = (count * X + j) / combinedCount;
         float combinedY = (count * Y + i) / combinedCount;
         float combinedModuleSize = (count * estimatedModuleSize + newModuleSize) / combinedCount;
         return new FinderPattern(combinedX, combinedY, combinedModuleSize, combinedCount);
      }"
"internal virtual FinderPatternInfo find(IDictionary<DecodeHintType, object> hints)
      {
         bool tryHarder = hints != null && hints.ContainsKey(DecodeHintType.TRY_HARDER);
         bool pureBarcode = hints != null && hints.ContainsKey(DecodeHintType.PURE_BARCODE);
         int maxI = image.Height;
         int maxJ = image.Width;
         int iSkip = (3 * maxI) / (4 * MAX_MODULES);
         if (iSkip < MIN_SKIP || tryHarder)
         {
            iSkip = MIN_SKIP;
         }
         bool done = false;
         int[] stateCount = new int[5];
         for (int i = iSkip - 1; i < maxI && !done; i += iSkip)
         {
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            stateCount[3] = 0;
            stateCount[4] = 0;
            int currentState = 0;
            for (int j = 0; j < maxJ; j++)
            {
               if (image[j, i])
               {
                  if ((currentState & 1)"
"protected internal static bool foundPatternCross(int[] stateCount)
      {
         int totalModuleSize = 0;
         for (int i = 0; i < 5; i++)
         {
            int count = stateCount[i];
            if (count"
"private bool crossCheckDiagonal(int startI, int centerJ, int maxCount, int originalStateCountTotal)
      {
         int maxI = image.Height;
         int maxJ = image.Width;
         int[] stateCount = CrossCheckStateCount;
         int i = 0;
         while (startI - i >= 0 && image[centerJ - i, startI - i])
         {
            stateCount[2]++;
            i++;
         }
         if ((startI - i < 0) || (centerJ - i < 0))
         {
            return false;
         }
         while ((startI - i >= 0) && (centerJ - i >= 0) && !image[centerJ - i, startI - i] && stateCount[1] <= maxCount)
         {
            stateCount[1]++;
            i++;
         }
         if ((startI - i < 0) || (centerJ - i < 0) || stateCount[1] > maxCount)
         {
            return false;
         }
         while ((startI - i >= 0) && (centerJ - i >= 0) && image[centerJ - i, startI - i] && stateCount[0] <= maxCount)
         {
            stateCount[0]++;
            i++;
         }
         if (stateCount[0] > maxCount)
         {
            return false;
         }
         i = 1;
         while ((startI + i < maxI) && (centerJ + i < maxJ) && image[centerJ + i, startI + i])
         {
            stateCount[2]++;
            i++;
         }
         if ((startI + i >= maxI) || (centerJ + i >= maxJ))
         {
            return false;
         }
         while ((startI + i < maxI) && (centerJ + i < maxJ) && !image[centerJ + i, startI + i] && stateCount[3] < maxCount)
         {
            stateCount[3]++;
            i++;
         }
         if ((startI + i >= maxI) || (centerJ + i >= maxJ) || stateCount[3] >= maxCount)
         {
            return false;
         }
         while ((startI + i < maxI) && (centerJ + i < maxJ) && image[centerJ + i, startI + i] && stateCount[4] < maxCount)
         {
            stateCount[4]++;
            i++;
         }
         if (stateCount[4] >= maxCount)
         {
            return false;
         }
         int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
         return Math.Abs(stateCountTotal - originalStateCountTotal) < 2*originalStateCountTotal &&
                foundPatternCross(stateCount);
      }"
"protected bool handlePossibleCenter(int[] stateCount, int i, int j, bool pureBarcode)
      {
         int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
             stateCount[4];
         float? centerJ = centerFromEnd(stateCount, j);
         if (centerJ"
"public int Compare(FinderPattern x, FinderPattern y)
         {
            float dA = Math.Abs(y.EstimatedModuleSize - average);
            float dB = Math.Abs(x.EstimatedModuleSize - average);
            return dA < dB ? -1 : dA"
"internal AlignmentPattern find()
      {
         int startX = this.startX;
         int height = this.height;
         int maxJ = startX + width;
         int middleI = startY + (height >> 1);
         int[] stateCount = new int[3];
         for (int iGen = 0; iGen < height; iGen++)
         {
            int i = middleI + ((iGen & 0x01)"
"private bool foundPatternCross(int[] stateCount)
      {
         float maxVariance = moduleSize / 2.0f;
         for (int i = 0; i < 3; i++)
         {
            if (Math.Abs(moduleSize - stateCount[i]) >= maxVariance)
            {
               return false;
            }
         }
         return true;
      }"
"private AlignmentPattern handlePossibleCenter(int[] stateCount, int i, int j)
      {
         int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
         float? centerJ = centerFromEnd(stateCount, j);
         if (centerJ"
"internal bool aboutEquals(float moduleSize, float i, float j)
      {
         if (Math.Abs(i - Y) <= moduleSize && Math.Abs(j - X) <= moduleSize)
         {
            float moduleSizeDiff = Math.Abs(moduleSize - estimatedModuleSize);
            return moduleSizeDiff <= 1.0f || moduleSizeDiff <= estimatedModuleSize;
         }
         return false;
      }"
"internal AlignmentPattern combineEstimate(float i, float j, float newModuleSize)
      {
         float combinedX = (X + j) / 2.0f;
         float combinedY = (Y + i) / 2.0f;
         float combinedModuleSize = (estimatedModuleSize + newModuleSize) / 2.0f;
         return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
      }"
"public static String guessEncoding(byte[] bytes, IDictionary<DecodeHintType, object> hints)
      {
         if (hints != null && hints.ContainsKey(DecodeHintType.CHARACTER_SET))
         {
            String characterSet = (String)hints[DecodeHintType.CHARACTER_SET];
            if (characterSet != null)
            {
               return characterSet;
            }
         }
         int length = bytes.Length;
         bool canBeISO88591 = true;
         bool canBeShiftJIS = true;
         bool canBeUTF8 = true;
         int utf8BytesLeft = 0;
         int utf2BytesChars = 0;
         int utf3BytesChars = 0;
         int utf4BytesChars = 0;
         int sjisBytesLeft = 0;
         int sjisKatakanaChars = 0;
         int sjisCurKatakanaWordLength = 0;
         int sjisCurDoubleBytesWordLength = 0;
         int sjisMaxKatakanaWordLength = 0;
         int sjisMaxDoubleBytesWordLength = 0;
         int isoHighOther = 0;
         bool utf8bom = bytes.Length > 3 &&
             bytes[0]"
"private void ensureCapacity(int size)
      {
         if (size > bits.Length << 5)
         {
            int[] newBits = makeArray(size);
            System.Array.Copy(bits, 0, newBits, 0, bits.Length);
            bits = newBits;
         }
      }"
"public void setBulk(int i, int newBits)
      {
         bits[i >> 5] = newBits;
      }"
"public void clear()
      {
         int max = bits.Length;
         for (int i = 0; i < max; i++)
         {
            bits[i] = 0;
         }
      }"
"public void appendBit(bool bit)
      {
         ensureCapacity(size + 1);
         if (bit)
         {
            bits[size >> 5] |= 1 << (size & 0x1F);
         }
         size++;
      }"
"public void appendBits(int value, int numBits)
      {
         if (numBits < 0 || numBits > 32)
         {
            throw new ArgumentException(""Num bits must be between 0 and 32"");
         }
         ensureCapacity(size + numBits);
         for (int numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--)
         {
            appendBit(((value >> (numBitsLeft - 1)) & 0x01)"
"public void toBytes(int bitOffset, byte[] array, int offset, int numBytes)
      {
         for (int i = 0; i < numBytes; i++)
         {
            int theByte = 0;
            for (int j = 0; j < 8; j++)
            {
               if (this[bitOffset])
               {
                  theByte |= 1 << (7 - j);
               }
               bitOffset++;
            }
            array[offset + i] = (byte)theByte;
         }
      }"
"public override bool Equals(Object o)
      {
         var other = o as BitArray;
         if (other"
"public override int GetHashCode()
      {
         var hash = size;
         foreach (var bit in bits)
         {
            hash = 31 * hash + bit.GetHashCode();
         }
         return hash;
      }"
"public void flip(int x, int y)
      {
         int offset = y * rowSize + (x >> 5);
         bits[offset] ^= 1 << (x & 0x1f);
      }"
"public void setRegion(int left, int top, int width, int height)
      {
         if (top < 0 || left < 0)
         {
            throw new System.ArgumentException(""Left and top must be nonnegative"");
         }
         if (height < 1 || width < 1)
         {
            throw new System.ArgumentException(""Height and width must be at least 1"");
         }
         int right = left + width;
         int bottom = top + height;
         if (bottom > this.height || right > this.width)
         {
            throw new System.ArgumentException(""The region must fit inside the matrix"");
         }
         for (int y = top; y < bottom; y++)
         {
            int offset = y * rowSize;
            for (int x = left; x < right; x++)
            {
               bits[offset + (x >> 5)] |= 1 << (x & 0x1f);
            }
         }
      }"
"public BitArray getRow(int y, BitArray row)
      {
         if (row"
"public void setRow(int y, BitArray row)
      {
         Array.Copy(row.Array, 0, bits, y * rowSize, rowSize);
      }"
"public int[] getTopLeftOnBit()
      {
         int bitsOffset = 0;
         while (bitsOffset < bits.Length && bits[bitsOffset]"
"public static PerspectiveTransform quadrilateralToQuadrilateral(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float x0p, float y0p, float x1p, float y1p, float x2p, float y2p, float x3p, float y3p)
      {
         PerspectiveTransform qToS = quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
         PerspectiveTransform sToQ = squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
         return sToQ.times(qToS);
      }"
"public void transformPoints(float[] xValues, float[] yValues)
      {
         int n = xValues.Length;
         for (int i = 0; i < n; i++)
         {
            float x = xValues[i];
            float y = yValues[i];
            float denominator = a13 * x + a23 * y + a33;
            xValues[i] = (a11 * x + a21 * y + a31) / denominator;
            yValues[i] = (a12 * x + a22 * y + a32) / denominator;
         }
      }"
"public static void setGridSampler(GridSampler newGridSampler)
      {
         if (newGridSampler"
"public abstract BitMatrix sampleGrid(BitMatrix image, int dimensionX, int dimensionY, float p1ToX, float p1ToY, float p2ToX, float p2ToY, float p3ToX, float p3ToY, float p4ToX, float p4ToY, float p1FromX, float p1FromY, float p2FromX, float p2FromY, float p3FromX, float p3FromY, float p4FromX, float p4FromY);
      public virtual BitMatrix sampleGrid(BitMatrix image, int dimensionX, int dimensionY, PerspectiveTransform transform)
      {
         throw new System.NotSupportedException();
      }"
"protected internal static bool checkAndNudgePoints(BitMatrix image, float[] points)
      {
         int width = image.Width;
         int height = image.Height;
         bool nudged = true;
         for (int offset = 0; offset < points.Length && nudged; offset += 2)
         {
            int x = (int)points[offset];
            int y = (int)points[offset + 1];
            if (x < -1 || x > width || y < -1 || y > height)
            {
               return false;
            }
            nudged = false;
            if (x"
"public override BitArray getBlackRow(int y, BitArray row)
      {
         LuminanceSource source = LuminanceSource;
         int width = source.Width;
         if (row"
"public override Binarizer createBinarizer(LuminanceSource source)
      {
         return new GlobalHistogramBinarizer(source);
      }"
"public int readBits(int numBits)
      {
         if (numBits < 1 || numBits > 32 || numBits > available())
         {
            throw new ArgumentException(numBits.ToString(), ""numBits"");
         }
         int result = 0;
         if (bitOffset > 0)
         {
            int bitsLeft = 8 - bitOffset;
            int toRead = numBits < bitsLeft ? numBits : bitsLeft;
            int bitsToNotRead = bitsLeft - toRead;
            int mask = (0xFF >> (8 - toRead)) << bitsToNotRead;
            result = (bytes[byteOffset] & mask) >> bitsToNotRead;
            numBits -= toRead;
            bitOffset += toRead;
            if (bitOffset"
"public override Binarizer createBinarizer(LuminanceSource source)
      {
         return new HybridBinarizer(source);
      }"
"private void binarizeEntireImage()
      {
         if (matrix"
"private static void calculateThresholdForBlock(byte[] luminances, int subWidth, int subHeight, int width, int height, int[][] blackPoints, BitMatrix matrix)
      {
         for (int y = 0; y < subHeight; y++)
         {
            int yoffset = y << BLOCK_SIZE_POWER;
            int maxYOffset = height - BLOCK_SIZE;
            if (yoffset > maxYOffset)
            {
               yoffset = maxYOffset;
            }
            for (int x = 0; x < subWidth; x++)
            {
               int xoffset = x << BLOCK_SIZE_POWER;
               int maxXOffset = width - BLOCK_SIZE;
               if (xoffset > maxXOffset)
               {
                  xoffset = maxXOffset;
               }
               int left = cap(x, 2, subWidth - 3);
               int top = cap(y, 2, subHeight - 3);
               int sum = 0;
               for (int z = -2; z <= 2; z++)
               {
                  int[] blackRow = blackPoints[top + z];
                  sum += blackRow[left - 2];
                  sum += blackRow[left - 1];
                  sum += blackRow[left];
                  sum += blackRow[left + 1];
                  sum += blackRow[left + 2];
               }
               int average = sum / 25;
               thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
            }
         }
      }"
"private static void thresholdBlock(byte[] luminances, int xoffset, int yoffset, int threshold, int stride, BitMatrix matrix)
      {
         int offset = (yoffset * stride) + xoffset;
         for (int y = 0; y < BLOCK_SIZE; y++, offset += stride)
         {
            for (int x = 0; x < BLOCK_SIZE; x++)
            {
               int pixel = luminances[offset + x] & 0xff;"
"private static int[][] calculateBlackPoints(byte[] luminances, int subWidth, int subHeight, int width, int height)
      {
         int[][] blackPoints = new int[subHeight][];
         for (int i = 0; i < subHeight; i++)
         {
            blackPoints[i] = new int[subWidth];
         }
         for (int y = 0; y < subHeight; y++)
         {
            int yoffset = y << BLOCK_SIZE_POWER;
            int maxYOffset = height - BLOCK_SIZE;
            if (yoffset > maxYOffset)
            {
               yoffset = maxYOffset;
            }
            for (int x = 0; x < subWidth; x++)
            {
               int xoffset = x << BLOCK_SIZE_POWER;
               int maxXOffset = width - BLOCK_SIZE;
               if (xoffset > maxXOffset)
               {
                  xoffset = maxXOffset;
               }
               int sum = 0;
               int min = 0xFF;
               int max = 0;
               for (int yy = 0, offset = yoffset * width + xoffset; yy < BLOCK_SIZE; yy++, offset += width)
               {
                  for (int xx = 0; xx < BLOCK_SIZE; xx++)
                  {
                     int pixel = luminances[offset + xx] & 0xFF;
                     sum += pixel;
                     if (pixel < min)
                     {
                        min = pixel;
                     }
                     if (pixel > max)
                     {
                        max = pixel;
                     }
                  }
                  if (max - min > MIN_DYNAMIC_RANGE)
                  {
                     for (yy++, offset += width; yy < BLOCK_SIZE; yy++, offset += width)
                     {
                        for (int xx = 0; xx < BLOCK_SIZE; xx++)
                        {
                           sum += luminances[offset + xx] & 0xFF;
                        }
                     }
                  }
               }
               int average = sum >> (BLOCK_SIZE_POWER * 2);
               if (max - min <= MIN_DYNAMIC_RANGE)
               {
                  average = min >> 1;
                  if (y > 0 && x > 0)
                  {
                     int averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) +
                         blackPoints[y - 1][x - 1]) >> 2;
                     if (min < averageNeighborBlackPoint)
                     {
                        average = averageNeighborBlackPoint;
                     }
                  }
               }
               blackPoints[y][x] = average;
            }
         }
         return blackPoints;
      }"
"public static int round(float d)
      {
         return (int)(d + 0.5f);
      }"
"private void initialize()
      {
         expTable = new int[size];
         logTable = new int[size];
         int x = 1;
         for (int i = 0; i < size; i++)
         {
            expTable[i] = x;
            x <<= 1; 
            if (x >= size)
            {
               x ^= primitive;
               x &= size - 1;
            }
         }
         for (int i = 0; i < size - 1; i++)
         {
            logTable[expTable[i]] = i;
         }"
"internal GenericGFPoly buildMonomial(int degree, int coefficient)
      {
         checkInit();
         if (degree < 0)
         {
            throw new ArgumentException();
         }
         if (coefficient"
"static internal int addOrSubtract(int a, int b)
      {
         return a ^ b;
      }"
"internal int exp(int a)
      {
         checkInit();
         return expTable[a];
      }"
"internal int log(int a)
      {
         checkInit();
         if (a"
"internal int inverse(int a)
      {
         checkInit();
         if (a"
"internal int multiply(int a, int b)
      {
         checkInit();
         if (a"
"override public String ToString()
      {
         return ""GF(0x"" + primitive.ToString(""X"") + ',' + size + ')';
      }"
"private GenericGFPoly buildGenerator(int degree)
      {
         if (degree >= cachedGenerators.Count)
         {
            var lastGenerator = cachedGenerators[cachedGenerators.Count - 1];
            for (int d = cachedGenerators.Count; d <= degree; d++)
            {
               var nextGenerator = lastGenerator.multiply(new GenericGFPoly(field, new int[] { 1, field.exp(d - 1 + field.GeneratorBase) }));
               cachedGenerators.Add(nextGenerator);
               lastGenerator = nextGenerator;
            }
         }
         return cachedGenerators[degree];
      }"
"internal int getCoefficient(int degree)
      {
         return coefficients[coefficients.Length - 1 - degree];
      }"
"internal int evaluateAt(int a)
      {
         int result = 0;
         if (a"
"public bool decode(int[] received, int twoS)
      {
         var poly = new GenericGFPoly(field, received);
         var syndromeCoefficients = new int[twoS];
         var noError = true;
         for (var i = 0; i < twoS; i++)
         {
            var eval = poly.evaluateAt(field.exp(i + field.GeneratorBase));
            syndromeCoefficients[syndromeCoefficients.Length - 1 - i] = eval;
            if (eval != 0)
            {
               noError = false;
            }
         }
         if (noError)
         {
            return true;
         }
         var syndrome = new GenericGFPoly(field, syndromeCoefficients);
         var sigmaOmega = runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
         if (sigmaOmega"
"public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }"
"public static uint GetAllConns(ref string[] allConns)
        {
            int lpNames = 0;
            int entryNameSize = 0;
            int lpSize = 0;
            uint retval = ERROR_SUCCESS;
            RasEntryName[] names = null;
            entryNameSize = Marshal.SizeOf(typeof(RasEntryName));
            retval = RasEnumEntries(null, null, null, ref lpSize, out lpNames);
            if (retval"
"private static void IEProxyUpdate(Configuration config, int sysProxyMode)
        {
            using (RegistryKey registry = OpenUserRegKey(@""Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections"", true))
            {
                try
                {
                    byte[] defConnection = (byte[])registry.GetValue(""DefaultConnectionSettings"");
                    int counter = 0;
                    if (defConnection != null && defConnection.Length >= 8)
                    {
                        counter = defConnection[4] | (defConnection[5] << 8);
                    }
                    defConnection = GenConnectionSettings(config, sysProxyMode, counter);
                    RegistrySetValue(registry, ""DefaultConnectionSettings"", defConnection);
                    RegistrySetValue(registry, ""SavedLegacySettings"", defConnection);
                }
                catch (IOException e)
                {
                    Logging.LogUsefulException(e);
                }
            }
            using (RegistryKey registry = OpenUserRegKey(@""Software\Microsoft\Windows\CurrentVersion\Internet Settings"", true))
            {
                try
                {
                    RegistrySetValue(registry, ""ProxyOverride"", ""localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;172.32.*;192.168.*;<local>"");
                }
                catch (IOException e)
                {
                    Logging.LogUsefulException(e);
                }
            }
        }"
"private void InitializeComponent()
        {
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();
            this.LabelRandom = new System.Windows.Forms.Label();
            this.RandomComboBox = new System.Windows.Forms.ComboBox();
            this.CheckAutoBan = new System.Windows.Forms.CheckBox();
            this.checkRandom = new System.Windows.Forms.CheckBox();
            this.checkAutoStartup = new System.Windows.Forms.CheckBox();
            this.checkBalanceInGroup = new System.Windows.Forms.CheckBox();
            this.Socks5ProxyGroup = new System.Windows.Forms.GroupBox();
            this.tableLayoutPanel9 = new System.Windows.Forms.TableLayoutPanel();
            this.LabelS5Password = new System.Windows.Forms.Label();
            this.LabelS5Username = new System.Windows.Forms.Label();
            this.TextS5Pass = new System.Windows.Forms.TextBox();
            this.LabelS5Port = new System.Windows.Forms.Label();
            this.TextS5User = new System.Windows.Forms.TextBox();
            this.LabelS5Server = new System.Windows.Forms.Label();
            this.NumS5Port = new System.Windows.Forms.NumericUpDown();
            this.TextS5Server = new System.Windows.Forms.TextBox();
            this.comboProxyType = new System.Windows.Forms.ComboBox();
            this.CheckSockProxy = new System.Windows.Forms.CheckBox();
            this.checkBoxPacProxy = new System.Windows.Forms.CheckBox();
            this.label1 = new System.Windows.Forms.Label();
            this.TextUserAgent = new System.Windows.Forms.TextBox();
            this.ListenGroup = new System.Windows.Forms.GroupBox();
            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();
            this.TextAuthPass = new System.Windows.Forms.TextBox();
            this.LabelAuthPass = new System.Windows.Forms.Label();
            this.TextAuthUser = new System.Windows.Forms.TextBox();
            this.LabelAuthUser = new System.Windows.Forms.Label();
            this.checkShareOverLan = new System.Windows.Forms.CheckBox();
            this.NumProxyPort = new System.Windows.Forms.NumericUpDown();
            this.ProxyPortLabel = new System.Windows.Forms.Label();
            this.tableLayoutPanel10 = new System.Windows.Forms.TableLayoutPanel();
            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();
            this.MyCancelButton = new System.Windows.Forms.Button();
            this.OKButton = new System.Windows.Forms.Button();
            this.tableLayoutPanel5 = new System.Windows.Forms.TableLayoutPanel();
            this.ReconnectLabel = new System.Windows.Forms.Label();
            this.NumReconnect = new System.Windows.Forms.NumericUpDown();
            this.TTLLabel = new System.Windows.Forms.Label();
            this.NumTTL = new System.Windows.Forms.NumericUpDown();
            this.labelTimeout = new System.Windows.Forms.Label();
            this.NumTimeout = new System.Windows.Forms.NumericUpDown();
            this.DNSText = new System.Windows.Forms.TextBox();
            this.buttonDefault = new System.Windows.Forms.Button();
            this.label2 = new System.Windows.Forms.Label();
            this.tableLayoutPanel1.SuspendLayout();
            this.tableLayoutPanel2.SuspendLayout();
            this.Socks5ProxyGroup.SuspendLayout();
            this.tableLayoutPanel9.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumS5Port)).BeginInit();
            this.ListenGroup.SuspendLayout();
            this.tableLayoutPanel4.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumProxyPort)).BeginInit();
            this.tableLayoutPanel10.SuspendLayout();
            this.tableLayoutPanel3.SuspendLayout();
            this.tableLayoutPanel5.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumReconnect)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumTTL)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumTimeout)).BeginInit();
            this.SuspendLayout();
            this.tableLayoutPanel1.AutoSize = true;
            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel1.ColumnCount = 2;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel2, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.Socks5ProxyGroup, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.ListenGroup, 0, 2);
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel10, 1, 2);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(15, 16);
            this.tableLayoutPanel1.Name = ""tableLayoutPanel1"";
            this.tableLayoutPanel1.RowCount = 3;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.Size = new System.Drawing.Size(581, 452);
            this.tableLayoutPanel1.TabIndex = 0;
            this.tableLayoutPanel2.AutoSize = true;
            this.tableLayoutPanel2.ColumnCount = 2;
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel2.Controls.Add(this.LabelRandom, 0, 2);
            this.tableLayoutPanel2.Controls.Add(this.RandomComboBox, 1, 2);
            this.tableLayoutPanel2.Controls.Add(this.CheckAutoBan, 1, 4);
            this.tableLayoutPanel2.Controls.Add(this.checkRandom, 1, 1);
            this.tableLayoutPanel2.Controls.Add(this.checkAutoStartup, 1, 0);
            this.tableLayoutPanel2.Controls.Add(this.checkBalanceInGroup, 1, 3);
            this.tableLayoutPanel2.Location = new System.Drawing.Point(372, 3);
            this.tableLayoutPanel2.Name = ""tableLayoutPanel2"";
            this.tableLayoutPanel2.RowCount = 5;
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.Size = new System.Drawing.Size(206, 118);
            this.tableLayoutPanel2.TabIndex = 2;
            this.LabelRandom.AutoSize = true;
            this.LabelRandom.Dock = System.Windows.Forms.DockStyle.Fill;
            this.LabelRandom.Location = new System.Drawing.Point(3, 44);
            this.LabelRandom.Name = ""LabelRandom"";
            this.LabelRandom.Size = new System.Drawing.Size(47, 30);
            this.LabelRandom.TabIndex = 12;
            this.LabelRandom.Text = ""Balance"";
            this.LabelRandom.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.RandomComboBox.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.RandomComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.RandomComboBox.FormattingEnabled = true;
            this.RandomComboBox.Items.AddRange(new object[] {
            ""Order"",
            ""Random"",
            ""LowLatency"",
            ""LowException"",
            ""SelectedFirst"",
            ""Timer""});
            this.RandomComboBox.Location = new System.Drawing.Point(56, 47);
            this.RandomComboBox.Margin = new System.Windows.Forms.Padding(3, 3, 3, 7);
            this.RandomComboBox.Name = ""RandomComboBox"";
            this.RandomComboBox.Size = new System.Drawing.Size(147, 20);
            this.RandomComboBox.TabIndex = 14;
            this.CheckAutoBan.AutoSize = true;
            this.CheckAutoBan.Enabled = false;
            this.CheckAutoBan.Location = new System.Drawing.Point(56, 99);
            this.CheckAutoBan.Name = ""CheckAutoBan"";
            this.CheckAutoBan.Size = new System.Drawing.Size(66, 16);
            this.CheckAutoBan.TabIndex = 15;
            this.CheckAutoBan.Text = ""AutoBan"";
            this.CheckAutoBan.UseVisualStyleBackColor = true;
            this.checkRandom.AutoSize = true;
            this.checkRandom.Location = new System.Drawing.Point(56, 25);
            this.checkRandom.Name = ""checkRandom"";
            this.checkRandom.Size = new System.Drawing.Size(96, 16);
            this.checkRandom.TabIndex = 13;
            this.checkRandom.Text = ""Load balance"";
            this.checkRandom.UseVisualStyleBackColor = true;
            this.checkAutoStartup.AutoSize = true;
            this.checkAutoStartup.Location = new System.Drawing.Point(56, 3);
            this.checkAutoStartup.Name = ""checkAutoStartup"";
            this.checkAutoStartup.Size = new System.Drawing.Size(102, 16);
            this.checkAutoStartup.TabIndex = 12;
            this.checkAutoStartup.Text = ""Start on Boot"";
            this.checkAutoStartup.UseVisualStyleBackColor = true;
            this.checkBalanceInGroup.AutoSize = true;
            this.checkBalanceInGroup.Location = new System.Drawing.Point(56, 77);
            this.checkBalanceInGroup.Name = ""checkBalanceInGroup"";
            this.checkBalanceInGroup.Size = new System.Drawing.Size(120, 16);
            this.checkBalanceInGroup.TabIndex = 15;
            this.checkBalanceInGroup.Text = ""Balance in group"";
            this.checkBalanceInGroup.UseVisualStyleBackColor = true;
            this.Socks5ProxyGroup.AutoSize = true;
            this.Socks5ProxyGroup.Controls.Add(this.tableLayoutPanel9);
            this.Socks5ProxyGroup.Location = new System.Drawing.Point(14, 0);
            this.Socks5ProxyGroup.Margin = new System.Windows.Forms.Padding(14, 0, 0, 0);
            this.Socks5ProxyGroup.Name = ""Socks5ProxyGroup"";
            this.tableLayoutPanel1.SetRowSpan(this.Socks5ProxyGroup, 2);
            this.Socks5ProxyGroup.Size = new System.Drawing.Size(355, 255);
            this.Socks5ProxyGroup.TabIndex = 0;
            this.Socks5ProxyGroup.TabStop = false;
            this.Socks5ProxyGroup.Text = ""Remote proxy"";
            this.tableLayoutPanel9.AutoSize = true;
            this.tableLayoutPanel9.ColumnCount = 2;
            this.tableLayoutPanel9.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel9.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel9.Controls.Add(this.LabelS5Password, 0, 5);
            this.tableLayoutPanel9.Controls.Add(this.LabelS5Username, 0, 4);
            this.tableLayoutPanel9.Controls.Add(this.TextS5Pass, 1, 5);
            this.tableLayoutPanel9.Controls.Add(this.LabelS5Port, 0, 3);
            this.tableLayoutPanel9.Controls.Add(this.TextS5User, 1, 4);
            this.tableLayoutPanel9.Controls.Add(this.LabelS5Server, 0, 2);
            this.tableLayoutPanel9.Controls.Add(this.NumS5Port, 1, 3);
            this.tableLayoutPanel9.Controls.Add(this.TextS5Server, 1, 2);
            this.tableLayoutPanel9.Controls.Add(this.comboProxyType, 1, 1);
            this.tableLayoutPanel9.Controls.Add(this.CheckSockProxy, 0, 0);
            this.tableLayoutPanel9.Controls.Add(this.checkBoxPacProxy, 1, 0);
            this.tableLayoutPanel9.Controls.Add(this.label1, 0, 6);
            this.tableLayoutPanel9.Controls.Add(this.TextUserAgent, 1, 6);
            this.tableLayoutPanel9.Location = new System.Drawing.Point(11, 32);
            this.tableLayoutPanel9.Name = ""tableLayoutPanel9"";
            this.tableLayoutPanel9.RowCount = 7;
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel9.Size = new System.Drawing.Size(338, 203);
            this.tableLayoutPanel9.TabIndex = 0;
            this.LabelS5Password.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelS5Password.AutoSize = true;
            this.LabelS5Password.Location = new System.Drawing.Point(22, 136);
            this.LabelS5Password.Name = ""LabelS5Password"";
            this.LabelS5Password.Size = new System.Drawing.Size(53, 12);
            this.LabelS5Password.TabIndex = 5;
            this.LabelS5Password.Text = ""Password"";
            this.LabelS5Username.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelS5Username.AutoSize = true;
            this.LabelS5Username.Location = new System.Drawing.Point(22, 109);
            this.LabelS5Username.Name = ""LabelS5Username"";
            this.LabelS5Username.Size = new System.Drawing.Size(53, 12);
            this.LabelS5Username.TabIndex = 4;
            this.LabelS5Username.Text = ""Username"";
            this.TextS5Pass.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextS5Pass.Location = new System.Drawing.Point(81, 132);
            this.TextS5Pass.Name = ""TextS5Pass"";
            this.TextS5Pass.Size = new System.Drawing.Size(236, 21);
            this.TextS5Pass.TabIndex = 6;
            this.LabelS5Port.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelS5Port.AutoSize = true;
            this.LabelS5Port.Location = new System.Drawing.Point(46, 82);
            this.LabelS5Port.Name = ""LabelS5Port"";
            this.LabelS5Port.Size = new System.Drawing.Size(29, 12);
            this.LabelS5Port.TabIndex = 1;
            this.LabelS5Port.Text = ""Port"";
            this.TextS5User.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextS5User.Location = new System.Drawing.Point(81, 105);
            this.TextS5User.Name = ""TextS5User"";
            this.TextS5User.Size = new System.Drawing.Size(236, 21);
            this.TextS5User.TabIndex = 5;
            this.LabelS5Server.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelS5Server.AutoSize = true;
            this.LabelS5Server.Location = new System.Drawing.Point(16, 55);
            this.LabelS5Server.Name = ""LabelS5Server"";
            this.LabelS5Server.Size = new System.Drawing.Size(59, 12);
            this.LabelS5Server.TabIndex = 0;
            this.LabelS5Server.Text = ""Server IP"";
            this.NumS5Port.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.NumS5Port.Location = new System.Drawing.Point(81, 78);
            this.NumS5Port.Maximum = new decimal(new int[] {
            65535,
            0,
            0,
            0});
            this.NumS5Port.Name = ""NumS5Port"";
            this.NumS5Port.Size = new System.Drawing.Size(236, 21);
            this.NumS5Port.TabIndex = 4;
            this.TextS5Server.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextS5Server.Location = new System.Drawing.Point(81, 51);
            this.TextS5Server.Name = ""TextS5Server"";
            this.TextS5Server.Size = new System.Drawing.Size(236, 21);
            this.TextS5Server.TabIndex = 3;
            this.comboProxyType.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.comboProxyType.FormattingEnabled = true;
            this.comboProxyType.Items.AddRange(new object[] {
            ""Socks5(support UDP)"",
            ""Http tunnel"",
            ""TCP Port tunnel""});
            this.comboProxyType.Location = new System.Drawing.Point(81, 25);
            this.comboProxyType.Name = ""comboProxyType"";
            this.comboProxyType.Size = new System.Drawing.Size(236, 20);
            this.comboProxyType.TabIndex = 2;
            this.CheckSockProxy.AutoSize = true;
            this.CheckSockProxy.Location = new System.Drawing.Point(3, 3);
            this.CheckSockProxy.Name = ""CheckSockProxy"";
            this.CheckSockProxy.Size = new System.Drawing.Size(72, 16);
            this.CheckSockProxy.TabIndex = 0;
            this.CheckSockProxy.Text = ""Proxy On"";
            this.CheckSockProxy.UseVisualStyleBackColor = true;
            this.checkBoxPacProxy.AutoSize = true;
            this.checkBoxPacProxy.Location = new System.Drawing.Point(81, 3);
            this.checkBoxPacProxy.Name = ""checkBoxPacProxy"";
            this.checkBoxPacProxy.Size = new System.Drawing.Size(204, 16);
            this.checkBoxPacProxy.TabIndex = 1;
            this.checkBoxPacProxy.Text = ""PAC \""direct\"" return this proxy"";
            this.checkBoxPacProxy.UseVisualStyleBackColor = true;
            this.label1.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(16, 173);
            this.label1.Name = ""label1"";
            this.label1.Size = new System.Drawing.Size(59, 12);
            this.label1.TabIndex = 5;
            this.label1.Text = ""UserAgent"";
            this.TextUserAgent.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextUserAgent.Location = new System.Drawing.Point(81, 159);
            this.TextUserAgent.Name = ""TextUserAgent"";
            this.TextUserAgent.Size = new System.Drawing.Size(236, 21);
            this.TextUserAgent.TabIndex = 7;
            this.ListenGroup.AutoSize = true;
            this.ListenGroup.Controls.Add(this.tableLayoutPanel4);
            this.ListenGroup.Location = new System.Drawing.Point(14, 255);
            this.ListenGroup.Margin = new System.Windows.Forms.Padding(14, 0, 0, 0);
            this.ListenGroup.Name = ""ListenGroup"";
            this.ListenGroup.Size = new System.Drawing.Size(339, 176);
            this.ListenGroup.TabIndex = 1;
            this.ListenGroup.TabStop = false;
            this.ListenGroup.Text = ""Local proxy"";
            this.tableLayoutPanel4.AutoSize = true;
            this.tableLayoutPanel4.ColumnCount = 2;
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel4.Controls.Add(this.TextAuthPass, 1, 3);
            this.tableLayoutPanel4.Controls.Add(this.LabelAuthPass, 0, 3);
            this.tableLayoutPanel4.Controls.Add(this.TextAuthUser, 1, 2);
            this.tableLayoutPanel4.Controls.Add(this.LabelAuthUser, 0, 2);
            this.tableLayoutPanel4.Controls.Add(this.checkShareOverLan, 1, 0);
            this.tableLayoutPanel4.Controls.Add(this.NumProxyPort, 1, 1);
            this.tableLayoutPanel4.Controls.Add(this.ProxyPortLabel, 0, 1);
            this.tableLayoutPanel4.Location = new System.Drawing.Point(5, 32);
            this.tableLayoutPanel4.Name = ""tableLayoutPanel4"";
            this.tableLayoutPanel4.RowCount = 4;
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel4.Size = new System.Drawing.Size(328, 124);
            this.tableLayoutPanel4.TabIndex = 0;
            this.TextAuthPass.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextAuthPass.Location = new System.Drawing.Point(62, 79);
            this.TextAuthPass.Name = ""TextAuthPass"";
            this.TextAuthPass.Size = new System.Drawing.Size(236, 21);
            this.TextAuthPass.TabIndex = 11;
            this.LabelAuthPass.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelAuthPass.AutoSize = true;
            this.LabelAuthPass.Location = new System.Drawing.Point(3, 94);
            this.LabelAuthPass.Name = ""LabelAuthPass"";
            this.LabelAuthPass.Size = new System.Drawing.Size(53, 12);
            this.LabelAuthPass.TabIndex = 8;
            this.LabelAuthPass.Text = ""Password"";
            this.TextAuthUser.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.TextAuthUser.Location = new System.Drawing.Point(62, 52);
            this.TextAuthUser.Name = ""TextAuthUser"";
            this.TextAuthUser.Size = new System.Drawing.Size(236, 21);
            this.TextAuthUser.TabIndex = 10;
            this.LabelAuthUser.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.LabelAuthUser.AutoSize = true;
            this.LabelAuthUser.Location = new System.Drawing.Point(3, 56);
            this.LabelAuthUser.Name = ""LabelAuthUser"";
            this.LabelAuthUser.Size = new System.Drawing.Size(53, 12);
            this.LabelAuthUser.TabIndex = 5;
            this.LabelAuthUser.Text = ""Username"";
            this.checkShareOverLan.AutoSize = true;
            this.checkShareOverLan.Location = new System.Drawing.Point(62, 3);
            this.checkShareOverLan.Name = ""checkShareOverLan"";
            this.checkShareOverLan.Size = new System.Drawing.Size(156, 16);
            this.checkShareOverLan.TabIndex = 8;
            this.checkShareOverLan.Text = ""Allow Clients from LAN"";
            this.checkShareOverLan.UseVisualStyleBackColor = true;
            this.NumProxyPort.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.NumProxyPort.Location = new System.Drawing.Point(62, 25);
            this.NumProxyPort.Maximum = new decimal(new int[] {
            65535,
            0,
            0,
            0});
            this.NumProxyPort.Name = ""NumProxyPort"";
            this.NumProxyPort.Size = new System.Drawing.Size(236, 21);
            this.NumProxyPort.TabIndex = 9;
            this.ProxyPortLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.ProxyPortLabel.AutoSize = true;
            this.ProxyPortLabel.Location = new System.Drawing.Point(27, 29);
            this.ProxyPortLabel.Name = ""ProxyPortLabel"";
            this.ProxyPortLabel.Size = new System.Drawing.Size(29, 12);
            this.ProxyPortLabel.TabIndex = 3;
            this.ProxyPortLabel.Text = ""Port"";
            this.tableLayoutPanel10.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.tableLayoutPanel10.AutoSize = true;
            this.tableLayoutPanel10.ColumnCount = 1;
            this.tableLayoutPanel10.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel10.Controls.Add(this.tableLayoutPanel3, 0, 2);
            this.tableLayoutPanel10.Controls.Add(this.tableLayoutPanel5, 0, 1);
            this.tableLayoutPanel10.Location = new System.Drawing.Point(382, 258);
            this.tableLayoutPanel10.Name = ""tableLayoutPanel10"";
            this.tableLayoutPanel10.RowCount = 3;
            this.tableLayoutPanel10.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel10.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel10.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel10.Size = new System.Drawing.Size(186, 191);
            this.tableLayoutPanel10.TabIndex = 3;
            this.tableLayoutPanel3.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
            this.tableLayoutPanel3.AutoSize = true;
            this.tableLayoutPanel3.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel3.ColumnCount = 2;
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Absolute, 23F));
            this.tableLayoutPanel3.Controls.Add(this.MyCancelButton, 1, 0);
            this.tableLayoutPanel3.Controls.Add(this.OKButton, 0, 0);
            this.tableLayoutPanel3.Location = new System.Drawing.Point(3, 146);
            this.tableLayoutPanel3.Margin = new System.Windows.Forms.Padding(3, 3, 0, 3);
            this.tableLayoutPanel3.Name = ""tableLayoutPanel3"";
            this.tableLayoutPanel3.RowCount = 1;
            this.tableLayoutPanel3.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel3.Size = new System.Drawing.Size(183, 42);
            this.tableLayoutPanel3.TabIndex = 14;
            this.MyCancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.MyCancelButton.Dock = System.Windows.Forms.DockStyle.Right;
            this.MyCancelButton.Location = new System.Drawing.Point(96, 3);
            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(3, 3, 0, 0);
            this.MyCancelButton.Name = ""MyCancelButton"";
            this.MyCancelButton.Size = new System.Drawing.Size(87, 39);
            this.MyCancelButton.TabIndex = 22;
            this.MyCancelButton.Text = ""Cancel"";
            this.MyCancelButton.UseVisualStyleBackColor = true;
            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);
            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.OKButton.Dock = System.Windows.Forms.DockStyle.Right;
            this.OKButton.Location = new System.Drawing.Point(3, 3);
            this.OKButton.Margin = new System.Windows.Forms.Padding(3, 3, 3, 0);
            this.OKButton.Name = ""OKButton"";
            this.OKButton.Size = new System.Drawing.Size(87, 39);
            this.OKButton.TabIndex = 21;
            this.OKButton.Text = ""OK"";
            this.OKButton.UseVisualStyleBackColor = true;
            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);
            this.tableLayoutPanel5.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
            this.tableLayoutPanel5.AutoSize = true;
            this.tableLayoutPanel5.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel5.ColumnCount = 2;
            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel5.Controls.Add(this.ReconnectLabel, 0, 3);
            this.tableLayoutPanel5.Controls.Add(this.NumReconnect, 1, 3);
            this.tableLayoutPanel5.Controls.Add(this.TTLLabel, 0, 5);
            this.tableLayoutPanel5.Controls.Add(this.NumTTL, 1, 5);
            this.tableLayoutPanel5.Controls.Add(this.labelTimeout, 0, 4);
            this.tableLayoutPanel5.Controls.Add(this.NumTimeout, 1, 4);
            this.tableLayoutPanel5.Controls.Add(this.DNSText, 1, 1);
            this.tableLayoutPanel5.Controls.Add(this.buttonDefault, 1, 0);
            this.tableLayoutPanel5.Controls.Add(this.label2, 0, 1);
            this.tableLayoutPanel5.Location = new System.Drawing.Point(0, 0);
            this.tableLayoutPanel5.Margin = new System.Windows.Forms.Padding(0);
            this.tableLayoutPanel5.Name = ""tableLayoutPanel5"";
            this.tableLayoutPanel5.Padding = new System.Windows.Forms.Padding(3);
            this.tableLayoutPanel5.RowCount = 6;
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.Size = new System.Drawing.Size(186, 143);
            this.tableLayoutPanel5.TabIndex = 3;
            this.ReconnectLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.ReconnectLabel.AutoSize = true;
            this.ReconnectLabel.Location = new System.Drawing.Point(6, 66);
            this.ReconnectLabel.Name = ""ReconnectLabel"";
            this.ReconnectLabel.Size = new System.Drawing.Size(59, 12);
            this.ReconnectLabel.TabIndex = 3;
            this.ReconnectLabel.Text = ""Reconnect"";
            this.NumReconnect.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.NumReconnect.Location = new System.Drawing.Point(71, 62);
            this.NumReconnect.Maximum = new decimal(new int[] {
            20,
            0,
            0,
            0});
            this.NumReconnect.Name = ""NumReconnect"";
            this.NumReconnect.Size = new System.Drawing.Size(109, 21);
            this.NumReconnect.TabIndex = 18;
            this.TTLLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.TTLLabel.AutoSize = true;
            this.TTLLabel.Location = new System.Drawing.Point(42, 120);
            this.TTLLabel.Name = ""TTLLabel"";
            this.TTLLabel.Size = new System.Drawing.Size(23, 12);
            this.TTLLabel.TabIndex = 3;
            this.TTLLabel.Text = ""TTL"";
            this.NumTTL.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.NumTTL.Location = new System.Drawing.Point(71, 116);
            this.NumTTL.Maximum = new decimal(new int[] {
            600,
            0,
            0,
            0});
            this.NumTTL.Name = ""NumTTL"";
            this.NumTTL.Size = new System.Drawing.Size(109, 21);
            this.NumTTL.TabIndex = 20;
            this.labelTimeout.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelTimeout.AutoSize = true;
            this.labelTimeout.Location = new System.Drawing.Point(12, 93);
            this.labelTimeout.Name = ""labelTimeout"";
            this.labelTimeout.Size = new System.Drawing.Size(53, 12);
            this.labelTimeout.TabIndex = 3;
            this.labelTimeout.Text = "" Timeout"";
            this.NumTimeout.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.NumTimeout.Location = new System.Drawing.Point(71, 89);
            this.NumTimeout.Maximum = new decimal(new int[] {
            60,
            0,
            0,
            0});
            this.NumTimeout.Name = ""NumTimeout"";
            this.NumTimeout.Size = new System.Drawing.Size(109, 21);
            this.NumTimeout.TabIndex = 19;
            this.DNSText.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.DNSText.Location = new System.Drawing.Point(71, 35);
            this.DNSText.MaxLength = 0;
            this.DNSText.Name = ""DNSText"";
            this.DNSText.Size = new System.Drawing.Size(109, 21);
            this.DNSText.TabIndex = 17;
            this.DNSText.WordWrap = false;
            this.buttonDefault.Location = new System.Drawing.Point(71, 6);
            this.buttonDefault.Name = ""buttonDefault"";
            this.buttonDefault.Size = new System.Drawing.Size(109, 23);
            this.buttonDefault.TabIndex = 16;
            this.buttonDefault.Text = ""Set Default"";
            this.buttonDefault.UseVisualStyleBackColor = true;
            this.buttonDefault.Click += new System.EventHandler(this.buttonDefault_Click);
            this.label2.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(42, 39);
            this.label2.Name = ""label2"";
            this.label2.Size = new System.Drawing.Size(23, 12);
            this.label2.TabIndex = 3;
            this.label2.Text = ""DNS"";
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None;
            this.AutoSize = true;
            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.ClientSize = new System.Drawing.Size(728, 513);
            this.Controls.Add(this.tableLayoutPanel1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = ""SettingsForm"";
            this.Padding = new System.Windows.Forms.Padding(12, 13, 12, 13);
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""SettingsForm"";
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.SettingsForm_FormClosed);
            this.tableLayoutPanel1.ResumeLayout(false);
            this.tableLayoutPanel1.PerformLayout();
            this.tableLayoutPanel2.ResumeLayout(false);
            this.tableLayoutPanel2.PerformLayout();
            this.Socks5ProxyGroup.ResumeLayout(false);
            this.Socks5ProxyGroup.PerformLayout();
            this.tableLayoutPanel9.ResumeLayout(false);
            this.tableLayoutPanel9.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumS5Port)).EndInit();
            this.ListenGroup.ResumeLayout(false);
            this.ListenGroup.PerformLayout();
            this.tableLayoutPanel4.ResumeLayout(false);
            this.tableLayoutPanel4.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumProxyPort)).EndInit();
            this.tableLayoutPanel10.ResumeLayout(false);
            this.tableLayoutPanel10.PerformLayout();
            this.tableLayoutPanel3.ResumeLayout(false);
            this.tableLayoutPanel5.ResumeLayout(false);
            this.tableLayoutPanel5.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumReconnect)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumTTL)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumTimeout)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();
        }"
"private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle2 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle3 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle4 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle5 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle6 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle7 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle8 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle9 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle10 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle11 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle12 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle13 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle14 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle15 = new System.Windows.Forms.DataGridViewCellStyle();
            this.ServerDataGrid = new Shadowsocks.View.ServerLogForm.DoubleBufferListView();
            this.timer = new System.Windows.Forms.Timer(this.components);
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.ID = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Group = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Server = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Enable = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.TotalConnect = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Connecting = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.AvgLatency = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.AvgDownSpeed = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.MaxDownSpeed = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.AvgUpSpeed = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.MaxUpSpeed = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Download = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Upload = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.DownloadRaw = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.ErrorPercent = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.ConnectError = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.ConnectTimeout = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.ConnectEmpty = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Continuous = new System.Windows.Forms.DataGridViewTextBoxColumn();
            ((System.ComponentModel.ISupportInitialize)(this.ServerDataGrid)).BeginInit();
            this.tableLayoutPanel1.SuspendLayout();
            this.SuspendLayout();
            this.ServerDataGrid.AllowUserToAddRows = false;
            this.ServerDataGrid.AllowUserToDeleteRows = false;
            this.ServerDataGrid.AllowUserToResizeRows = false;
            this.ServerDataGrid.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.ServerDataGrid.ColumnHeadersHeight = 46;
            this.ServerDataGrid.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.ID,
            this.Group,
            this.Server,
            this.Enable,
            this.TotalConnect,
            this.Connecting,
            this.AvgLatency,
            this.AvgDownSpeed,
            this.MaxDownSpeed,
            this.AvgUpSpeed,
            this.MaxUpSpeed,
            this.Download,
            this.Upload,
            this.DownloadRaw,
            this.ErrorPercent,
            this.ConnectError,
            this.ConnectTimeout,
            this.ConnectEmpty,
            this.Continuous});
            this.ServerDataGrid.Dock = System.Windows.Forms.DockStyle.Fill;
            this.ServerDataGrid.Location = new System.Drawing.Point(0, 0);
            this.ServerDataGrid.Margin = new System.Windows.Forms.Padding(0);
            this.ServerDataGrid.MinimumSize = new System.Drawing.Size(1, 1);
            this.ServerDataGrid.MultiSelect = false;
            this.ServerDataGrid.Name = ""ServerDataGrid"";
            this.ServerDataGrid.ReadOnly = true;
            this.ServerDataGrid.RowHeadersVisible = false;
            this.ServerDataGrid.RowTemplate.Height = 23;
            this.ServerDataGrid.Size = new System.Drawing.Size(132, 34);
            this.ServerDataGrid.TabIndex = 0;
            this.ServerDataGrid.CellClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.ServerDataGrid_CellClick);
            this.ServerDataGrid.CellDoubleClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.ServerDataGrid_CellDoubleClick);
            this.ServerDataGrid.ColumnWidthChanged += new System.Windows.Forms.DataGridViewColumnEventHandler(this.ServerDataGrid_ColumnWidthChanged);
            this.ServerDataGrid.SortCompare += new System.Windows.Forms.DataGridViewSortCompareEventHandler(this.ServerDataGrid_SortCompare);
            this.ServerDataGrid.MouseUp += new System.Windows.Forms.MouseEventHandler(this.ServerDataGrid_MouseUp);
            this.timer.Enabled = true;
            this.timer.Interval = 250;
            this.timer.Tick += new System.EventHandler(this.timer_Tick);
            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel1.ColumnCount = 1;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Controls.Add(this.ServerDataGrid, 0, 0);
            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tableLayoutPanel1.GrowStyle = System.Windows.Forms.TableLayoutPanelGrowStyle.FixedSize;
            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);
            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);
            this.tableLayoutPanel1.Name = ""tableLayoutPanel1"";
            this.tableLayoutPanel1.RowCount = 1;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.Size = new System.Drawing.Size(132, 22);
            this.tableLayoutPanel1.TabIndex = 1;
            dataGridViewCellStyle1.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.ID.DefaultCellStyle = dataGridViewCellStyle1;
            this.ID.HeaderText = ""ID"";
            this.ID.MinimumWidth = 2;
            this.ID.Name = ""ID"";
            this.ID.ReadOnly = true;
            this.ID.Width = 36;
            this.Group.HeaderText = ""Group"";
            this.Group.Name = ""Group"";
            this.Group.ReadOnly = true;
            this.Group.Width = 60;
            dataGridViewCellStyle2.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            this.Server.DefaultCellStyle = dataGridViewCellStyle2;
            this.Server.HeaderText = ""Server"";
            this.Server.MinimumWidth = 2;
            this.Server.Name = ""Server"";
            this.Server.ReadOnly = true;
            this.Server.Width = 88;
            this.Enable.HeaderText = ""Enable"";
            this.Enable.MinimumWidth = 8;
            this.Enable.Name = ""Enable"";
            this.Enable.ReadOnly = true;
            this.Enable.Resizable = System.Windows.Forms.DataGridViewTriState.True;
            this.Enable.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.Enable.Width = 24;
            this.TotalConnect.HeaderText = ""Total Connect"";
            this.TotalConnect.MinimumWidth = 2;
            this.TotalConnect.Name = ""TotalConnect"";
            this.TotalConnect.ReadOnly = true;
            this.TotalConnect.Visible = false;
            this.TotalConnect.Width = 48;
            dataGridViewCellStyle3.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.Connecting.DefaultCellStyle = dataGridViewCellStyle3;
            this.Connecting.HeaderText = ""Connecting"";
            this.Connecting.MinimumWidth = 16;
            this.Connecting.Name = ""Connecting"";
            this.Connecting.ReadOnly = true;
            this.Connecting.Width = 28;
            dataGridViewCellStyle4.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.AvgLatency.DefaultCellStyle = dataGridViewCellStyle4;
            this.AvgLatency.HeaderText = ""Latency"";
            this.AvgLatency.MinimumWidth = 36;
            this.AvgLatency.Name = ""AvgLatency"";
            this.AvgLatency.ReadOnly = true;
            this.AvgLatency.Width = 48;
            dataGridViewCellStyle5.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.AvgDownSpeed.DefaultCellStyle = dataGridViewCellStyle5;
            this.AvgDownSpeed.HeaderText = ""Avg DSpeed"";
            this.AvgDownSpeed.MinimumWidth = 60;
            this.AvgDownSpeed.Name = ""AvgDownSpeed"";
            this.AvgDownSpeed.ReadOnly = true;
            this.AvgDownSpeed.Width = 60;
            dataGridViewCellStyle6.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.MaxDownSpeed.DefaultCellStyle = dataGridViewCellStyle6;
            this.MaxDownSpeed.HeaderText = ""Max DSpeed"";
            this.MaxDownSpeed.MinimumWidth = 2;
            this.MaxDownSpeed.Name = ""MaxDownSpeed"";
            this.MaxDownSpeed.ReadOnly = true;
            this.MaxDownSpeed.Width = 60;
            dataGridViewCellStyle7.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.AvgUpSpeed.DefaultCellStyle = dataGridViewCellStyle7;
            this.AvgUpSpeed.HeaderText = ""Avg UpSpeed"";
            this.AvgUpSpeed.MinimumWidth = 60;
            this.AvgUpSpeed.Name = ""AvgUpSpeed"";
            this.AvgUpSpeed.ReadOnly = true;
            this.AvgUpSpeed.Width = 60;
            dataGridViewCellStyle8.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.MaxUpSpeed.DefaultCellStyle = dataGridViewCellStyle8;
            this.MaxUpSpeed.HeaderText = ""Max UpSpeed"";
            this.MaxUpSpeed.MinimumWidth = 2;
            this.MaxUpSpeed.Name = ""MaxUpSpeed"";
            this.MaxUpSpeed.ReadOnly = true;
            this.MaxUpSpeed.Width = 60;
            dataGridViewCellStyle9.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.Download.DefaultCellStyle = dataGridViewCellStyle9;
            this.Download.HeaderText = ""Dload"";
            this.Download.MinimumWidth = 2;
            this.Download.Name = ""Download"";
            this.Download.ReadOnly = true;
            this.Download.Width = 60;
            dataGridViewCellStyle10.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.Upload.DefaultCellStyle = dataGridViewCellStyle10;
            this.Upload.HeaderText = ""Upload"";
            this.Upload.MinimumWidth = 2;
            this.Upload.Name = ""Upload"";
            this.Upload.ReadOnly = true;
            this.Upload.Width = 60;
            dataGridViewCellStyle11.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.DownloadRaw.DefaultCellStyle = dataGridViewCellStyle11;
            this.DownloadRaw.HeaderText = ""DloadRaw"";
            this.DownloadRaw.MinimumWidth = 2;
            this.DownloadRaw.Name = ""DownloadRaw"";
            this.DownloadRaw.ReadOnly = true;
            this.DownloadRaw.Width = 60;
            this.ErrorPercent.HeaderText = ""Error Percent"";
            this.ErrorPercent.MinimumWidth = 2;
            this.ErrorPercent.Name = ""ErrorPercent"";
            this.ErrorPercent.ReadOnly = true;
            this.ErrorPercent.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.ErrorPercent.Visible = false;
            this.ErrorPercent.Width = 48;
            dataGridViewCellStyle12.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.ConnectError.DefaultCellStyle = dataGridViewCellStyle12;
            this.ConnectError.HeaderText = ""Error"";
            this.ConnectError.MinimumWidth = 2;
            this.ConnectError.Name = ""ConnectError"";
            this.ConnectError.ReadOnly = true;
            this.ConnectError.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.ConnectError.Width = 28;
            dataGridViewCellStyle13.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.ConnectTimeout.DefaultCellStyle = dataGridViewCellStyle13;
            this.ConnectTimeout.HeaderText = ""Timeout"";
            this.ConnectTimeout.MinimumWidth = 2;
            this.ConnectTimeout.Name = ""ConnectTimeout"";
            this.ConnectTimeout.ReadOnly = true;
            this.ConnectTimeout.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.ConnectTimeout.Width = 28;
            dataGridViewCellStyle14.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.ConnectEmpty.DefaultCellStyle = dataGridViewCellStyle14;
            this.ConnectEmpty.HeaderText = ""Empty Response"";
            this.ConnectEmpty.MinimumWidth = 2;
            this.ConnectEmpty.Name = ""ConnectEmpty"";
            this.ConnectEmpty.ReadOnly = true;
            this.ConnectEmpty.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.NotSortable;
            this.ConnectEmpty.Width = 28;
            dataGridViewCellStyle15.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
            this.Continuous.DefaultCellStyle = dataGridViewCellStyle15;
            this.Continuous.HeaderText = ""Continuous"";
            this.Continuous.Name = ""Continuous"";
            this.Continuous.ReadOnly = true;
            this.Continuous.Visible = false;
            this.Continuous.Width = 28;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(132, 22);
            this.Controls.Add(this.tableLayoutPanel1);
            this.Margin = new System.Windows.Forms.Padding(2);
            this.Name = ""ServerLogForm"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""ServerLog"";
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ServerLogForm_FormClosed);
            this.ResizeEnd += new System.EventHandler(this.ServerLogForm_ResizeEnd);
            this.Move += new System.EventHandler(this.ServerLogForm_Move);
            ((System.ComponentModel.ISupportInitialize)(this.ServerDataGrid)).EndInit();
            this.tableLayoutPanel1.ResumeLayout(false);
            this.ResumeLayout(false);
        }"
"private void InitializeComponent()
        {
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.checkBoxAutoUpdate = new System.Windows.Forms.CheckBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.textBoxURL = new System.Windows.Forms.TextBox();
            this.textBoxGroup = new System.Windows.Forms.TextBox();
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();
            this.buttonOK = new System.Windows.Forms.Button();
            this.buttonCancel = new System.Windows.Forms.Button();
            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();
            this.listServerSubscribe = new System.Windows.Forms.ListBox();
            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();
            this.buttonAdd = new System.Windows.Forms.Button();
            this.buttonDel = new System.Windows.Forms.Button();
            this.tableLayoutPanel1.SuspendLayout();
            this.tableLayoutPanel2.SuspendLayout();
            this.tableLayoutPanel3.SuspendLayout();
            this.tableLayoutPanel4.SuspendLayout();
            this.SuspendLayout();
            this.tableLayoutPanel1.AutoSize = true;
            this.tableLayoutPanel1.ColumnCount = 2;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);
            this.tableLayoutPanel1.Controls.Add(this.textBoxURL, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.textBoxGroup, 1, 1);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(352, 3);
            this.tableLayoutPanel1.Name = ""tableLayoutPanel1"";
            this.tableLayoutPanel1.RowCount = 3;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 20F));
            this.tableLayoutPanel1.Size = new System.Drawing.Size(263, 74);
            this.tableLayoutPanel1.TabIndex = 0;
            this.checkBoxAutoUpdate.AutoSize = true;
            this.checkBoxAutoUpdate.Location = new System.Drawing.Point(3, 35);
            this.checkBoxAutoUpdate.Name = ""checkBoxAutoUpdate"";
            this.checkBoxAutoUpdate.Size = new System.Drawing.Size(90, 16);
            this.checkBoxAutoUpdate.TabIndex = 3;
            this.checkBoxAutoUpdate.Text = ""Auto update"";
            this.checkBoxAutoUpdate.UseVisualStyleBackColor = true;
            this.label1.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(45, 7);
            this.label1.Name = ""label1"";
            this.label1.Size = new System.Drawing.Size(23, 12);
            this.label1.TabIndex = 0;
            this.label1.Text = ""URL"";
            this.label2.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(3, 34);
            this.label2.Name = ""label2"";
            this.label2.Size = new System.Drawing.Size(65, 12);
            this.label2.TabIndex = 0;
            this.label2.Text = ""Group name"";
            this.textBoxURL.Location = new System.Drawing.Point(74, 3);
            this.textBoxURL.Name = ""textBoxURL"";
            this.textBoxURL.Size = new System.Drawing.Size(186, 21);
            this.textBoxURL.TabIndex = 1;
            this.textBoxURL.TextChanged += new System.EventHandler(this.textBoxURL_TextChanged);
            this.textBoxGroup.Location = new System.Drawing.Point(74, 30);
            this.textBoxGroup.Name = ""textBoxGroup"";
            this.textBoxGroup.ReadOnly = true;
            this.textBoxGroup.Size = new System.Drawing.Size(186, 21);
            this.textBoxGroup.TabIndex = 1;
            this.tableLayoutPanel2.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
            this.tableLayoutPanel2.ColumnCount = 2;
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel2.Controls.Add(this.buttonOK, 0, 0);
            this.tableLayoutPanel2.Controls.Add(this.buttonCancel, 1, 0);
            this.tableLayoutPanel2.Location = new System.Drawing.Point(352, 264);
            this.tableLayoutPanel2.Name = ""tableLayoutPanel2"";
            this.tableLayoutPanel2.RowCount = 1;
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel2.Size = new System.Drawing.Size(291, 60);
            this.tableLayoutPanel2.TabIndex = 2;
            this.buttonOK.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.buttonOK.Location = new System.Drawing.Point(21, 10);
            this.buttonOK.Name = ""buttonOK"";
            this.buttonOK.Size = new System.Drawing.Size(102, 39);
            this.buttonOK.TabIndex = 0;
            this.buttonOK.Text = ""OK"";
            this.buttonOK.UseVisualStyleBackColor = true;
            this.buttonOK.Click += new System.EventHandler(this.buttonOK_Click);
            this.buttonCancel.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.buttonCancel.Location = new System.Drawing.Point(167, 10);
            this.buttonCancel.Name = ""buttonCancel"";
            this.buttonCancel.Size = new System.Drawing.Size(102, 39);
            this.buttonCancel.TabIndex = 0;
            this.buttonCancel.Text = ""Cancel"";
            this.buttonCancel.UseVisualStyleBackColor = true;
            this.buttonCancel.Click += new System.EventHandler(this.buttonCancel_Click);
            this.tableLayoutPanel3.ColumnCount = 2;
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 54.17957F));
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 45.82043F));
            this.tableLayoutPanel3.Controls.Add(this.tableLayoutPanel1, 1, 0);
            this.tableLayoutPanel3.Controls.Add(this.tableLayoutPanel2, 1, 1);
            this.tableLayoutPanel3.Controls.Add(this.listServerSubscribe, 0, 0);
            this.tableLayoutPanel3.Controls.Add(this.tableLayoutPanel4, 0, 1);
            this.tableLayoutPanel3.Location = new System.Drawing.Point(12, 12);
            this.tableLayoutPanel3.Name = ""tableLayoutPanel3"";
            this.tableLayoutPanel3.RowCount = 2;
            this.tableLayoutPanel3.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 78.59327F));
            this.tableLayoutPanel3.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 21.40673F));
            this.tableLayoutPanel3.Size = new System.Drawing.Size(646, 327);
            this.tableLayoutPanel3.TabIndex = 1;
            this.listServerSubscribe.FormattingEnabled = true;
            this.listServerSubscribe.ItemHeight = 12;
            this.listServerSubscribe.Location = new System.Drawing.Point(3, 3);
            this.listServerSubscribe.Name = ""listServerSubscribe"";
            this.listServerSubscribe.Size = new System.Drawing.Size(343, 244);
            this.listServerSubscribe.TabIndex = 4;
            this.listServerSubscribe.SelectedIndexChanged += new System.EventHandler(this.listServerSubscribe_SelectedIndexChanged);
            this.tableLayoutPanel4.ColumnCount = 2;
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.Controls.Add(this.checkBoxAutoUpdate, 0, 1);
            this.tableLayoutPanel4.Controls.Add(this.buttonAdd, 0, 0);
            this.tableLayoutPanel4.Controls.Add(this.buttonDel, 1, 0);
            this.tableLayoutPanel4.Location = new System.Drawing.Point(3, 259);
            this.tableLayoutPanel4.Name = ""tableLayoutPanel4"";
            this.tableLayoutPanel4.RowCount = 2;
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.Size = new System.Drawing.Size(343, 65);
            this.tableLayoutPanel4.TabIndex = 5;
            this.buttonAdd.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.buttonAdd.Location = new System.Drawing.Point(93, 4);
            this.buttonAdd.Name = ""buttonAdd"";
            this.buttonAdd.Size = new System.Drawing.Size(75, 23);
            this.buttonAdd.TabIndex = 0;
            this.buttonAdd.Text = ""Add"";
            this.buttonAdd.UseVisualStyleBackColor = true;
            this.buttonAdd.Click += new System.EventHandler(this.buttonAdd_Click);
            this.buttonDel.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.buttonDel.Location = new System.Drawing.Point(174, 4);
            this.buttonDel.Name = ""buttonDel"";
            this.buttonDel.Size = new System.Drawing.Size(75, 23);
            this.buttonDel.TabIndex = 1;
            this.buttonDel.Text = ""Delete"";
            this.buttonDel.UseVisualStyleBackColor = true;
            this.buttonDel.Click += new System.EventHandler(this.buttonDel_Click);
            this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
            this.AutoSize = true;
            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.ClientSize = new System.Drawing.Size(681, 364);
            this.Controls.Add(this.tableLayoutPanel3);
            this.Name = ""SubscribeForm"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""Subscribe Settings"";
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.SubscribeForm_FormClosed);
            this.tableLayoutPanel1.ResumeLayout(false);
            this.tableLayoutPanel1.PerformLayout();
            this.tableLayoutPanel2.ResumeLayout(false);
            this.tableLayoutPanel3.ResumeLayout(false);
            this.tableLayoutPanel3.PerformLayout();
            this.tableLayoutPanel4.ResumeLayout(false);
            this.tableLayoutPanel4.PerformLayout();
            this.ResumeLayout(false);
        }"
"private void InitializeComponent()
        {
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.listPorts = new System.Windows.Forms.ListBox();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();
            this.labelType = new System.Windows.Forms.Label();
            this.labelID = new System.Windows.Forms.Label();
            this.labelAddr = new System.Windows.Forms.Label();
            this.labelPort = new System.Windows.Forms.Label();
            this.checkEnable = new System.Windows.Forms.CheckBox();
            this.textAddr = new System.Windows.Forms.TextBox();
            this.NumTargetPort = new System.Windows.Forms.NumericUpDown();
            this.comboBoxType = new System.Windows.Forms.ComboBox();
            this.comboServers = new System.Windows.Forms.ComboBox();
            this.labelLocal = new System.Windows.Forms.Label();
            this.NumLocalPort = new System.Windows.Forms.NumericUpDown();
            this.label1 = new System.Windows.Forms.Label();
            this.textRemarks = new System.Windows.Forms.TextBox();
            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();
            this.OKButton = new System.Windows.Forms.Button();
            this.MyCancelButton = new System.Windows.Forms.Button();
            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();
            this.Add = new System.Windows.Forms.Button();
            this.Del = new System.Windows.Forms.Button();
            this.tableLayoutPanel1.SuspendLayout();
            this.groupBox1.SuspendLayout();
            this.tableLayoutPanel2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumTargetPort)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumLocalPort)).BeginInit();
            this.tableLayoutPanel3.SuspendLayout();
            this.tableLayoutPanel4.SuspendLayout();
            this.SuspendLayout();
            this.tableLayoutPanel1.ColumnCount = 2;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Controls.Add(this.listPorts, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.groupBox1, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel3, 1, 1);
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel4, 0, 1);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(13, 13);
            this.tableLayoutPanel1.Name = ""tableLayoutPanel1"";
            this.tableLayoutPanel1.RowCount = 2;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.Size = new System.Drawing.Size(684, 325);
            this.tableLayoutPanel1.TabIndex = 0;
            this.listPorts.FormattingEnabled = true;
            this.listPorts.ItemHeight = 12;
            this.listPorts.Location = new System.Drawing.Point(3, 3);
            this.listPorts.Name = ""listPorts"";
            this.listPorts.Size = new System.Drawing.Size(144, 244);
            this.listPorts.TabIndex = 0;
            this.listPorts.SelectedIndexChanged += new System.EventHandler(this.listPorts_SelectedIndexChanged);
            this.groupBox1.Controls.Add(this.tableLayoutPanel2);
            this.groupBox1.Location = new System.Drawing.Point(153, 3);
            this.groupBox1.Name = ""groupBox1"";
            this.groupBox1.Size = new System.Drawing.Size(531, 255);
            this.groupBox1.TabIndex = 2;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = ""Map Setting"";
            this.tableLayoutPanel2.ColumnCount = 3;
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel2.Controls.Add(this.labelType, 0, 1);
            this.tableLayoutPanel2.Controls.Add(this.labelID, 0, 2);
            this.tableLayoutPanel2.Controls.Add(this.labelAddr, 0, 4);
            this.tableLayoutPanel2.Controls.Add(this.labelPort, 0, 5);
            this.tableLayoutPanel2.Controls.Add(this.checkEnable, 1, 0);
            this.tableLayoutPanel2.Controls.Add(this.textAddr, 1, 4);
            this.tableLayoutPanel2.Controls.Add(this.NumTargetPort, 1, 5);
            this.tableLayoutPanel2.Controls.Add(this.comboBoxType, 1, 1);
            this.tableLayoutPanel2.Controls.Add(this.comboServers, 1, 2);
            this.tableLayoutPanel2.Controls.Add(this.labelLocal, 0, 3);
            this.tableLayoutPanel2.Controls.Add(this.NumLocalPort, 1, 3);
            this.tableLayoutPanel2.Controls.Add(this.label1, 0, 6);
            this.tableLayoutPanel2.Controls.Add(this.textRemarks, 1, 6);
            this.tableLayoutPanel2.Location = new System.Drawing.Point(7, 21);
            this.tableLayoutPanel2.Name = ""tableLayoutPanel2"";
            this.tableLayoutPanel2.RowCount = 8;
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel2.Size = new System.Drawing.Size(515, 223);
            this.tableLayoutPanel2.TabIndex = 0;
            this.labelType.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelType.AutoSize = true;
            this.labelType.Location = new System.Drawing.Point(45, 29);
            this.labelType.Name = ""labelType"";
            this.labelType.Size = new System.Drawing.Size(29, 12);
            this.labelType.TabIndex = 0;
            this.labelType.Text = ""Type"";
            this.labelID.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelID.AutoSize = true;
            this.labelID.Location = new System.Drawing.Point(15, 55);
            this.labelID.Name = ""labelID"";
            this.labelID.Size = new System.Drawing.Size(59, 12);
            this.labelID.TabIndex = 0;
            this.labelID.Text = ""Server ID"";
            this.labelAddr.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelAddr.AutoSize = true;
            this.labelAddr.Location = new System.Drawing.Point(3, 108);
            this.labelAddr.Name = ""labelAddr"";
            this.labelAddr.Size = new System.Drawing.Size(71, 12);
            this.labelAddr.TabIndex = 0;
            this.labelAddr.Text = ""Target Addr"";
            this.labelPort.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelPort.AutoSize = true;
            this.labelPort.Location = new System.Drawing.Point(3, 135);
            this.labelPort.Name = ""labelPort"";
            this.labelPort.Size = new System.Drawing.Size(71, 12);
            this.labelPort.TabIndex = 0;
            this.labelPort.Text = ""Target Port"";
            this.checkEnable.AutoSize = true;
            this.checkEnable.Location = new System.Drawing.Point(80, 3);
            this.checkEnable.Name = ""checkEnable"";
            this.checkEnable.Size = new System.Drawing.Size(60, 16);
            this.checkEnable.TabIndex = 3;
            this.checkEnable.Text = ""Enable"";
            this.checkEnable.UseVisualStyleBackColor = true;
            this.textAddr.Location = new System.Drawing.Point(80, 104);
            this.textAddr.Name = ""textAddr"";
            this.textAddr.Size = new System.Drawing.Size(403, 21);
            this.textAddr.TabIndex = 7;
            this.NumTargetPort.Location = new System.Drawing.Point(80, 131);
            this.NumTargetPort.Maximum = new decimal(new int[] {
            65535,
            0,
            0,
            0});
            this.NumTargetPort.Name = ""NumTargetPort"";
            this.NumTargetPort.Size = new System.Drawing.Size(403, 21);
            this.NumTargetPort.TabIndex = 8;
            this.comboBoxType.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.comboBoxType.FormattingEnabled = true;
            this.comboBoxType.Items.AddRange(new object[] {
            ""Port Forward"",
            ""Force Proxy"",
            ""Proxy With Rule""});
            this.comboBoxType.Location = new System.Drawing.Point(80, 25);
            this.comboBoxType.Name = ""comboBoxType"";
            this.comboBoxType.Size = new System.Drawing.Size(403, 20);
            this.comboBoxType.TabIndex = 4;
            this.comboBoxType.SelectedIndexChanged += new System.EventHandler(this.comboBoxType_SelectedIndexChanged);
            this.comboServers.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.comboServers.FormattingEnabled = true;
            this.comboServers.Location = new System.Drawing.Point(80, 51);
            this.comboServers.Name = ""comboServers"";
            this.comboServers.Size = new System.Drawing.Size(403, 20);
            this.comboServers.TabIndex = 5;
            this.labelLocal.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.labelLocal.AutoSize = true;
            this.labelLocal.Location = new System.Drawing.Point(9, 81);
            this.labelLocal.Name = ""labelLocal"";
            this.labelLocal.Size = new System.Drawing.Size(65, 12);
            this.labelLocal.TabIndex = 0;
            this.labelLocal.Text = ""Local Port"";
            this.NumLocalPort.Location = new System.Drawing.Point(80, 77);
            this.NumLocalPort.Maximum = new decimal(new int[] {
            65535,
            0,
            0,
            0});
            this.NumLocalPort.Name = ""NumLocalPort"";
            this.NumLocalPort.Size = new System.Drawing.Size(403, 21);
            this.NumLocalPort.TabIndex = 6;
            this.label1.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(27, 162);
            this.label1.Name = ""label1"";
            this.label1.Size = new System.Drawing.Size(47, 12);
            this.label1.TabIndex = 0;
            this.label1.Text = ""Remarks"";
            this.textRemarks.Location = new System.Drawing.Point(80, 158);
            this.textRemarks.Name = ""textRemarks"";
            this.textRemarks.Size = new System.Drawing.Size(403, 21);
            this.textRemarks.TabIndex = 9;
            this.tableLayoutPanel3.ColumnCount = 2;
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel3.Controls.Add(this.OKButton, 0, 0);
            this.tableLayoutPanel3.Controls.Add(this.MyCancelButton, 1, 0);
            this.tableLayoutPanel3.Location = new System.Drawing.Point(153, 264);
            this.tableLayoutPanel3.Name = ""tableLayoutPanel3"";
            this.tableLayoutPanel3.RowCount = 1;
            this.tableLayoutPanel3.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel3.Size = new System.Drawing.Size(490, 54);
            this.tableLayoutPanel3.TabIndex = 3;
            this.OKButton.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.OKButton.Location = new System.Drawing.Point(46, 3);
            this.OKButton.Name = ""OKButton"";
            this.OKButton.Size = new System.Drawing.Size(152, 35);
            this.OKButton.TabIndex = 10;
            this.OKButton.Text = ""OK"";
            this.OKButton.UseVisualStyleBackColor = true;
            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);
            this.MyCancelButton.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.MyCancelButton.Location = new System.Drawing.Point(291, 3);
            this.MyCancelButton.Name = ""MyCancelButton"";
            this.MyCancelButton.Size = new System.Drawing.Size(152, 35);
            this.MyCancelButton.TabIndex = 11;
            this.MyCancelButton.Text = ""Cancel"";
            this.MyCancelButton.UseVisualStyleBackColor = true;
            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);
            this.tableLayoutPanel4.ColumnCount = 1;
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel4.Controls.Add(this.Add, 0, 0);
            this.tableLayoutPanel4.Controls.Add(this.Del, 0, 1);
            this.tableLayoutPanel4.Location = new System.Drawing.Point(3, 264);
            this.tableLayoutPanel4.Name = ""tableLayoutPanel4"";
            this.tableLayoutPanel4.RowCount = 2;
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel4.Size = new System.Drawing.Size(144, 54);
            this.tableLayoutPanel4.TabIndex = 1;
            this.Add.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.Add.Location = new System.Drawing.Point(22, 3);
            this.Add.Name = ""Add"";
            this.Add.Size = new System.Drawing.Size(100, 21);
            this.Add.TabIndex = 1;
            this.Add.Text = ""&Add"";
            this.Add.UseVisualStyleBackColor = true;
            this.Add.Click += new System.EventHandler(this.Add_Click);
            this.Del.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.Del.Location = new System.Drawing.Point(22, 30);
            this.Del.Name = ""Del"";
            this.Del.Size = new System.Drawing.Size(100, 21);
            this.Del.TabIndex = 2;
            this.Del.Text = ""&Delete"";
            this.Del.UseVisualStyleBackColor = true;
            this.Del.Click += new System.EventHandler(this.Del_Click);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None;
            this.AutoSize = true;
            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.ClientSize = new System.Drawing.Size(727, 489);
            this.Controls.Add(this.tableLayoutPanel1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            this.Name = ""PortSettingsForm"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""Port Settings"";
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.PortMapForm_FormClosed);
            this.tableLayoutPanel1.ResumeLayout(false);
            this.groupBox1.ResumeLayout(false);
            this.tableLayoutPanel2.ResumeLayout(false);
            this.tableLayoutPanel2.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.NumTargetPort)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.NumLocalPort)).EndInit();
            this.tableLayoutPanel3.ResumeLayout(false);
            this.tableLayoutPanel4.ResumeLayout(false);
            this.ResumeLayout(false);
        }"
"private void InitializeComponent()
        {
            this.textPassword = new System.Windows.Forms.TextBox();
            this.buttonOK = new System.Windows.Forms.Button();
            this.label_info = new System.Windows.Forms.Label();
            this.SuspendLayout();
            this.textPassword.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.textPassword.Location = new System.Drawing.Point(41, 44);
            this.textPassword.Name = ""textPassword"";
            this.textPassword.Size = new System.Drawing.Size(330, 21);
            this.textPassword.TabIndex = 0;
            this.textPassword.UseSystemPasswordChar = true;
            this.buttonOK.Location = new System.Drawing.Point(131, 76);
            this.buttonOK.Name = ""buttonOK"";
            this.buttonOK.Size = new System.Drawing.Size(151, 28);
            this.buttonOK.TabIndex = 1;
            this.buttonOK.Text = ""OK"";
            this.buttonOK.UseVisualStyleBackColor = true;
            this.buttonOK.Click += new System.EventHandler(this.buttonOK_Click);
            this.label_info.AutoSize = true;
            this.label_info.Location = new System.Drawing.Point(24, 26);
            this.label_info.Name = ""label_info"";
            this.label_info.Size = new System.Drawing.Size(350, 15);
            this.label_info.TabIndex = 2;
            this.label_info.Text = ""Parse gui-config.json error, maybe require password to decrypt"";
            this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
            this.ClientSize = new System.Drawing.Size(412, 119);
            this.Controls.Add(this.label_info);
            this.Controls.Add(this.buttonOK);
            this.Controls.Add(this.textPassword);
            this.Font = new System.Drawing.Font(""Arial"", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.KeyPreview = true;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = ""InputPassword"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""InputPassword"";
            this.TopMost = true;
            this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.InputPassword_KeyDown);
            this.ResumeLayout(false);
            this.PerformLayout();
        }"
"private void InitializeComponent()
        {
            this.buttonOK = new System.Windows.Forms.Button();
            this.textOld = new System.Windows.Forms.TextBox();
            this.textPassword = new System.Windows.Forms.TextBox();
            this.textPassword2 = new System.Windows.Forms.TextBox();
            this.SuspendLayout();
            this.buttonOK.Location = new System.Drawing.Point(107, 132);
            this.buttonOK.Name = ""buttonOK"";
            this.buttonOK.Size = new System.Drawing.Size(75, 23);
            this.buttonOK.TabIndex = 3;
            this.buttonOK.Text = ""OK"";
            this.buttonOK.UseVisualStyleBackColor = true;
            this.buttonOK.Click += new System.EventHandler(this.buttonOK_Click);
            this.textOld.Location = new System.Drawing.Point(28, 13);
            this.textOld.Name = ""textOld"";
            this.textOld.Size = new System.Drawing.Size(233, 21);
            this.textOld.TabIndex = 0;
            this.textOld.UseSystemPasswordChar = true;
            this.textPassword.Location = new System.Drawing.Point(28, 60);
            this.textPassword.Name = ""textPassword"";
            this.textPassword.Size = new System.Drawing.Size(233, 21);
            this.textPassword.TabIndex = 1;
            this.textPassword.UseSystemPasswordChar = true;
            this.textPassword2.Location = new System.Drawing.Point(28, 87);
            this.textPassword2.Name = ""textPassword2"";
            this.textPassword2.Size = new System.Drawing.Size(233, 21);
            this.textPassword2.TabIndex = 2;
            this.textPassword2.UseSystemPasswordChar = true;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(284, 167);
            this.Controls.Add(this.textPassword2);
            this.Controls.Add(this.textPassword);
            this.Controls.Add(this.textOld);
            this.Controls.Add(this.buttonOK);
            this.ImeMode = System.Windows.Forms.ImeMode.Off;
            this.KeyPreview = true;
            this.Name = ""ResetPassword"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""ResetPassword"";
            this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.ResetPassword_KeyDown);
            this.ResumeLayout(false);
            this.PerformLayout();
        }"
"private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.logMenu = new System.Windows.Forms.MenuStrip();
            this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.clearLogToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.showInExplorerToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.closeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.viewToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.fontToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.wrapTextToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.alwaysOnTopToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.logTextBox = new System.Windows.Forms.TextBox();
            this.refreshTimer = new System.Windows.Forms.Timer(this.components);
            this.logMenu.SuspendLayout();
            this.SuspendLayout();
            this.logMenu.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fileToolStripMenuItem,
            this.viewToolStripMenuItem});
            this.logMenu.Location = new System.Drawing.Point(0, 0);
            this.logMenu.Name = ""logMenu"";
            this.logMenu.Size = new System.Drawing.Size(986, 25);
            this.logMenu.TabIndex = 0;
            this.logMenu.Text = ""menuStrip1"";
            this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.clearLogToolStripMenuItem,
            this.showInExplorerToolStripMenuItem,
            this.toolStripSeparator1,
            this.closeToolStripMenuItem});
            this.fileToolStripMenuItem.Name = ""fileToolStripMenuItem"";
            this.fileToolStripMenuItem.Size = new System.Drawing.Size(39, 21);
            this.fileToolStripMenuItem.Text = ""&File"";
            this.clearLogToolStripMenuItem.Name = ""clearLogToolStripMenuItem"";
            this.clearLogToolStripMenuItem.Size = new System.Drawing.Size(174, 22);
            this.clearLogToolStripMenuItem.Text = ""Clear &log"";
            this.clearLogToolStripMenuItem.Click += new System.EventHandler(this.clearLogToolStripMenuItem_Click);
            this.showInExplorerToolStripMenuItem.Name = ""showInExplorerToolStripMenuItem"";
            this.showInExplorerToolStripMenuItem.Size = new System.Drawing.Size(174, 22);
            this.showInExplorerToolStripMenuItem.Text = ""Show in &Explorer"";
            this.showInExplorerToolStripMenuItem.Click += new System.EventHandler(this.showInExplorerToolStripMenuItem_Click);
            this.toolStripSeparator1.Name = ""toolStripSeparator1"";
            this.toolStripSeparator1.Size = new System.Drawing.Size(171, 6);
            this.closeToolStripMenuItem.Name = ""closeToolStripMenuItem"";
            this.closeToolStripMenuItem.Size = new System.Drawing.Size(174, 22);
            this.closeToolStripMenuItem.Text = ""&Close"";
            this.closeToolStripMenuItem.Click += new System.EventHandler(this.closeToolStripMenuItem_Click);
            this.viewToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fontToolStripMenuItem,
            this.wrapTextToolStripMenuItem,
            this.alwaysOnTopToolStripMenuItem});
            this.viewToolStripMenuItem.Name = ""viewToolStripMenuItem"";
            this.viewToolStripMenuItem.Size = new System.Drawing.Size(47, 21);
            this.viewToolStripMenuItem.Text = ""&View"";
            this.fontToolStripMenuItem.Name = ""fontToolStripMenuItem"";
            this.fontToolStripMenuItem.Size = new System.Drawing.Size(158, 22);
            this.fontToolStripMenuItem.Text = ""&Font"";
            this.fontToolStripMenuItem.Click += new System.EventHandler(this.fontToolStripMenuItem_Click);
            this.wrapTextToolStripMenuItem.Name = ""wrapTextToolStripMenuItem"";
            this.wrapTextToolStripMenuItem.Size = new System.Drawing.Size(158, 22);
            this.wrapTextToolStripMenuItem.Text = ""&Wrap text"";
            this.wrapTextToolStripMenuItem.CheckedChanged += new System.EventHandler(this.wrapTextToolStripMenuItem_CheckedChanged);
            this.wrapTextToolStripMenuItem.Click += new System.EventHandler(this.wrapTextToolStripMenuItem_Click);
            this.alwaysOnTopToolStripMenuItem.Name = ""alwaysOnTopToolStripMenuItem"";
            this.alwaysOnTopToolStripMenuItem.Size = new System.Drawing.Size(158, 22);
            this.alwaysOnTopToolStripMenuItem.Text = ""&Always on top"";
            this.alwaysOnTopToolStripMenuItem.CheckedChanged += new System.EventHandler(this.alwaysOnTopToolStripMenuItem_CheckedChanged);
            this.alwaysOnTopToolStripMenuItem.Click += new System.EventHandler(this.alwaysOnTopToolStripMenuItem_Click);
            this.logTextBox.BackColor = System.Drawing.Color.Black;
            this.logTextBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.logTextBox.Font = new System.Drawing.Font(""Courier New"", 10.5F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.logTextBox.ForeColor = System.Drawing.Color.White;
            this.logTextBox.Location = new System.Drawing.Point(0, 25);
            this.logTextBox.MaxLength = 2147483647;
            this.logTextBox.Multiline = true;
            this.logTextBox.Name = ""logTextBox"";
            this.logTextBox.ReadOnly = true;
            this.logTextBox.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.logTextBox.Size = new System.Drawing.Size(986, 411);
            this.logTextBox.TabIndex = 1;
            this.logTextBox.WordWrap = false;
            this.refreshTimer.Enabled = true;
            this.refreshTimer.Tick += new System.EventHandler(this.refreshTimer_Tick);
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(986, 436);
            this.Controls.Add(this.logTextBox);
            this.Controls.Add(this.logMenu);
            this.Name = ""LogForm"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""Log Viewer"";
            this.Load += new System.EventHandler(this.LogForm_Load);
            this.Shown += new System.EventHandler(this.LogForm_Shown);
            this.logMenu.ResumeLayout(false);
            this.logMenu.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();
        }"
"private void InitializeComponent()
        {
            this.textBox = new System.Windows.Forms.TextBox();
            this.PictureQRcode = new System.Windows.Forms.PictureBox();
            ((System.ComponentModel.ISupportInitialize)(this.PictureQRcode)).BeginInit();
            this.SuspendLayout();
            this.textBox.Dock = System.Windows.Forms.DockStyle.Top;
            this.textBox.Font = new System.Drawing.Font(""宋体"", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134)));
            this.textBox.Location = new System.Drawing.Point(0, 0);
            this.textBox.Multiline = true;
            this.textBox.Name = ""textBox"";
            this.textBox.Size = new System.Drawing.Size(350, 63);
            this.textBox.TabIndex = 0;
            this.textBox.TextChanged += new System.EventHandler(this.textBox_TextChanged);
            this.textBox.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.textBox_KeyPress);
            this.PictureQRcode.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.PictureQRcode.Location = new System.Drawing.Point(0, 68);
            this.PictureQRcode.Name = ""PictureQRcode"";
            this.PictureQRcode.Size = new System.Drawing.Size(350, 350);
            this.PictureQRcode.TabIndex = 1;
            this.PictureQRcode.TabStop = false;
            this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
            this.ClientSize = new System.Drawing.Size(350, 418);
            this.Controls.Add(this.PictureQRcode);
            this.Controls.Add(this.textBox);
            this.Font = new System.Drawing.Font(""宋体"", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134)));
            this.Name = ""ShowTextForm"";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = ""ShowTextForm"";
            this.TopMost = true;
            this.SizeChanged += new System.EventHandler(this.ShowTextForm_SizeChanged);
            ((System.ComponentModel.ISupportInitialize)(this.PictureQRcode)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();
        }"
"public static object GetSession(string name)
        {
            return HttpContext.Current.Session[name];
        }"
"public static IPEndPoint CreateIPEndPoint(string ip, int port)
        {
            IPAddress ipAddress = StringToIPAddress(ip);
            return new IPEndPoint(ipAddress, port);
        }"
"private static extern IntPtr LoadLibrary(string libname);
        public static void LoadNativeAssemblies(string rootApplicationPath)
        {
            var nativeBinaryPath = IntPtr.Size > 4
                ? Path.Combine(rootApplicationPath, @""SqlServerTypes\x64\"")
                : Path.Combine(rootApplicationPath, @""SqlServerTypes\x86\"");
            LoadNativeAssembly(nativeBinaryPath, ""msvcr120.dll"");
            LoadNativeAssembly(nativeBinaryPath, ""SqlServerSpatial140.dll"");
        }"
"public static void UpdateToMaster(DbConnection conn)
        {
        }"
"public static SqlDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            try
            {
                SqlConnection conn = new SqlConnection(connectionString);
                    PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                    SqlDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                    cmd.Parameters.Clear();
                    return rdr;
            }
            catch
            {
                throw;
            }
        }"
"public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"public static object ExecuteScalar(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"public static void CacheParameters(string cacheKey, params SqlParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"public static SqlParameter[] GetCachedParameters(string cacheKey)
        {
            SqlParameter[] cachedParms = (SqlParameter[])parmCache[cacheKey];
            if (cachedParms"
"public string GenerateCheckCodeNum(int codeCount)
        {
            codeCount = codeCount > 10 ? 10 :codeCount;   
            int[] arrInt = {0,1,2,3,4,5,6,7,8,9};
		    arrInt = arrInt.OrderBy(c => Guid.NewGuid()).ToArray<int>();
            string str = string.Empty;
            for (int i = 0; i < codeCount; i++)
            {
                str += arrInt[i];
            }
            return str;
        }"
"public string GenerateCheckCode(int CodeCount)
        {
            char[] MixedList = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I','J', 'K', 'L', 'M', 'N','O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' }; 
			return GetRandomCode(MixedList, CodeCount);
		}"
"private string GetRandomCode(char[] CharList, int CodeLength)
        {
			string result = string.Empty;
			for (int i = 0; i < CodeLength; i++)
			{
				int rnd = Random.Next(0, CharList.Length);
				result += CharList[rnd];
			}
			return result;
        }"
"public static IPEndPoint CreateIPEndPoint(string ip, int port)
        {
            IPAddress ipAddress = StringToIPAddress(ip);
            return new IPEndPoint(ipAddress, port);
        }"
"public static string ToJson(DataTable dt, string jsonName)
        {
            StringBuilder Json = new StringBuilder();
            if (string.IsNullOrEmpty(jsonName)) jsonName = dt.TableName;
            Json.Append(""{\"""" + jsonName + ""\"":["");
            if (dt.Rows.Count > 0)
            {
                for (int i = 0; i < dt.Rows.Count; i++)
                {
                    Json.Append(""{"");
                    for (int j = 0; j < dt.Columns.Count; j++)
                    {
                        Type type = dt.Rows[i][j].GetType();
                        Json.Append(""\"""" + dt.Columns[j].ColumnName.ToString() + ""\"":"" + StringFormat(dt.Rows[i][j].ToString(), type));
                        if (j < dt.Columns.Count - 1)
                        {
                            Json.Append("","");
                        }
                    }
                    Json.Append(""}"");
                    if (i < dt.Rows.Count - 1)
                    {
                        Json.Append("","");
                    }
                }
            }
            Json.Append(""]}"");
            return Json.ToString();
        }"
"public static string ToJson(DbDataReader dataReader)
        {
            StringBuilder jsonString = new StringBuilder();
            jsonString.Append(""["");
            while (dataReader.Read())
            {
                jsonString.Append(""{"");
                for (int i = 0; i < dataReader.FieldCount; i++)
                {
                    Type type = dataReader.GetFieldType(i);
                    string strKey = dataReader.GetName(i);
                    string strValue = dataReader[i].ToString();
                    jsonString.Append(""\"""" + strKey + ""\"":"");
                    strValue = StringFormat(strValue, type);
                    if (i < dataReader.FieldCount - 1)
                    {
                        jsonString.Append(strValue + "","");
                    }
                    else
                    {
                        jsonString.Append(strValue);
                    }
                }
                jsonString.Append(""},"");
            }
            dataReader.Close();
            jsonString.Remove(jsonString.Length - 1, 1);
            jsonString.Append(""]"");
            return jsonString.ToString();
        }"
"public static IntervalTask CreateTask(Action taskAction)
		{
			if (Current != null)
				throw new FieldAccessException(""CreateTask requested, but a task already exists."");
			Current = new IntervalTask(taskAction);
			return Current;
		}"
"public void SetInterval(int interval)
		{
			intervalTimer.SetInterval(interval);
		}"
"public void StopTimer()
		{
			intervalTimer.Stop();
		}"
"public void Stop(bool immediate)
		{
			lock (syncLock)
			{
				ShuttingDown = true;
				if (!TaskRunning)
					this.Dispose();
			}
		}"
"public void Dispose()
		{
			StopTimer();
			System.Web.Hosting.HostingEnvironment.UnregisterObject(this);
		}"
"public void SetInterval(int milliseconds)
		{
			if (timer"
"public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"private static OracleCommand BuildIntCommand(OracleConnection connection,string storedProcName, IDataParameter[] parameters)
		{
			OracleCommand command = BuildQueryCommand(connection,storedProcName, parameters );
			command.Parameters.Add( new OracleParameter ( ""ReturnValue"",
                OracleType.Int32, 4, ParameterDirection.ReturnValue,
				false,0,0,string.Empty,DataRowVersion.Default,null ));
			return command;
		}"
"public bool ColumnExists(string tableName, string columnName)
        {
            string sql = ""select count(1) from syscolumns where [id]=object_id('"" + tableName + ""') and [name]='"" + columnName + ""'"";
            object res = GetSingle(sql);
            if (res"
"public static bool ColumnExists(string tableName, string columnName)
        {
            string sql = ""select count(1) from syscolumns where [id]=object_id('"" + tableName + ""') and [name]='"" + columnName + ""'"";
            object res = GetSingle(sql);
            if (res"
"public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = DbHelperSQL.GetSingle(strsql);
            if (obj"
"public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"public static int ExecuteNonQuery(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            using (OracleConnection connection = new OracleConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                int val = cmd.ExecuteNonQuery();
                connection.Close();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"public static int ExecuteNonQuery(OracleTransaction trans, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, trans.Connection, trans, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"public static int ExecuteNonQuery(OracleConnection connection, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"public static OracleDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            OracleConnection conn = new OracleConnection(connectionString);
            try
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                OracleDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                cmd.Parameters.Clear();
                return rdr;
            }
            catch
            {
                conn.Close();
                throw;
            }
        }"
"public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            using (OracleConnection conn = new OracleConnection(connectionString))
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"public static object ExecuteScalar(OracleTransaction transaction, CommandType commandType, string commandText, params OracleParameter[] commandParameters)
        {
            if (transaction"
"public static object ExecuteScalar(OracleConnection connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, connectionString, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"public static void CacheParameters(string cacheKey, params OracleParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"public static OracleParameter[] GetCachedParameters(string cacheKey)
        {
            OracleParameter[] cachedParms = (OracleParameter[])parmCache[cacheKey];
            if (cachedParms"
"public static string OraBit(bool value)
        {
            if (value)
                return ""Y"";
            else
                return ""N"";
        }"
"public static bool OraBool(string value)
        {
            if (value.Equals(""Y""))
                return true;
            else
                return false;
        }"
"public static int ExecuteNonQuery(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection conn = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                int val = cmd.ExecuteNonQuery();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"public static int ExecuteNonQuery(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"public static int ExecuteNonQuery(SqlTransaction trans, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, trans.Connection, trans, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"public static SqlDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            SqlConnection conn = new SqlConnection(connectionString);
            try
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                SqlDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                cmd.Parameters.Clear();
                return rdr;
            }
            catch
            {
                conn.Close();
                throw;
            }
        }"
"public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"public static object ExecuteScalar(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"public static void CacheParameters(string cacheKey, params SqlParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"public static SqlParameter[] GetCachedParameters(string cacheKey)
        {
            SqlParameter[] cachedParms = (SqlParameter[])parmCache[cacheKey];
            if (cachedParms"
"private static void PrepareCommand(SqlCommand cmd, SqlConnection conn, SqlTransaction trans, CommandType cmdType, string cmdText, SqlParameter[] cmdParms)
        {
            if (conn.State != ConnectionState.Open)
                conn.Open();
            cmd.Connection = conn;
            cmd.CommandText = cmdText;
            if (trans != null)
                cmd.Transaction = trans;
            cmd.CommandType = cmdType;
            if (cmdParms != null)
            {
                foreach (SqlParameter parm in cmdParms)
                    cmd.Parameters.Add(parm);
            }
        }"
"private void Page_Load(object sender, EventArgs e)
        {
            char[] chars = ""023456789"".ToCharArray();
            System.Random random = new Random();
            string validateCode = string.Empty;
            for (int i = 0; i < 4; i++)
            {
                char rc = chars[random.Next(0, chars.Length)];
                if (validateCode.IndexOf(rc) > -1)
                {
                    i--;
                    continue;
                }
                validateCode += rc;
            }
            Session[""xk_validate_code""] = validateCode;
            CreateImage(validateCode);
        }"
"public static string Encrypt(string original)
        {
            return Encrypt(original, ""kuiyu.net"");
        }"
"static public string SEncryptString(string inputStr, string keyStr)
        {
            MySecurity ws = new MySecurity();
            return ws.EncryptString(inputStr, keyStr);
        }"
"public static void Export(string fileName, GridView gv)
        {
            HttpContext.Current.Response.Clear();
            HttpContext.Current.Response.AddHeader(
                ""content-disposition"", string.Format(""attachment; filename={0}"", fileName));
            HttpContext.Current.Response.ContentType = ""application/ms-excel"";
            using (StringWriter sw = new StringWriter())
            {
                using (HtmlTextWriter htw = new HtmlTextWriter(sw))
                {
                    Table table = new Table();
                    table.GridLines = GridLines.Both;  
                    if (gv.HeaderRow != null)
                    {
                        PrepareControlForExport(gv.HeaderRow);
                        table.Rows.Add(gv.HeaderRow);
                    }
                    foreach (GridViewRow row in gv.Rows)
                    {
                        PrepareControlForExport(row);
                        table.Rows.Add(row);
                    }
                    if (gv.FooterRow != null)
                    {
                        PrepareControlForExport(gv.FooterRow);
                        table.Rows.Add(gv.FooterRow);
                    }
                    table.RenderControl(htw);
                    HttpContext.Current.Response.Write(sw.ToString());
                    HttpContext.Current.Response.End();
                }
            }
        }"
"private static void PrepareControlForExport(Control control)
        {
            for (int i = 0; i < control.Controls.Count; i++)
            {
                Control current = control.Controls[i];
                if (current is LinkButton)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as LinkButton).Text));
                }
                else if (current is ImageButton)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as ImageButton).AlternateText));
                }
                else if (current is HyperLink)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as HyperLink).Text));
                }
                else if (current is DropDownList)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as DropDownList).SelectedItem.Text));
                }
                else if (current is CheckBox)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as CheckBox).Checked ? ""True"" : ""False""));
                }
                if (current.HasControls())
                {
                    PrepareControlForExport(current);
                }
            }
        }"
"public string GetFormatDate(DateTime dt, char Separator)
        {
            if (dt != null && !dt.Equals(DBNull.Value))
            {
                string tem = string.Format(""yyyy{0}MM{1}dd"", Separator, Separator);
                return dt.ToString(tem);
            }
            else
            {
                return GetFormatDate(DateTime.Now, Separator);
            }
        }"
"public static string FormatDate(string dateString)
        {
            var dt = ParseToDateValue(dateString);
            if (dt"
"public static List<string> GetStrArray(string str, char speater, bool toLower)
        {
            List<string> list = new List<string>();
            string[] ss = str.Split(speater);
            foreach (string s in ss)
            {
                if (!string.IsNullOrEmpty(s) && s != speater.ToString())
                {
                    string strVal = s;
                    if (toLower)
                    {
                        strVal = s.ToLower();
                    }
                    list.Add(strVal);
                }
            }
            return list;
        }"
"private static string Create(int Length, bool Sleep, char[] List)
		{
			if (Sleep) Thread.Sleep(3);
			char[] Pattern = List;
			string result = string.Empty;
			int n = Pattern.Length;
			for (int i = 0; i < Length; i++)
			{
				int rnd = Random.Next(0, n);
				result += Pattern[rnd];
			}
			return result;
		}"
"public static string ToJson(DataTable dt, string jsonName)
        {
            StringBuilder Json = new StringBuilder();
            if (string.IsNullOrEmpty(jsonName)) jsonName = dt.TableName;
            Json.Append(""{\"""" + jsonName + ""\"":["");
            if (dt.Rows.Count > 0)
            {
                for (int i = 0; i < dt.Rows.Count; i++)
                {
                    Json.Append(""{"");
                    for (int j = 0; j < dt.Columns.Count; j++)
                    {
                        Type type = dt.Rows[i][j].GetType();
                        Json.Append(""\"""" + dt.Columns[j].ColumnName.ToString() + ""\"":"" + StringFormat(dt.Rows[i][j].ToString(), type));
                        if (j < dt.Columns.Count - 1)
                        {
                            Json.Append("","");
                        }
                    }
                    Json.Append(""}"");
                    if (i < dt.Rows.Count - 1)
                    {
                        Json.Append("","");
                    }
                }
            }
            Json.Append(""]}"");
            return Json.ToString();
        }"
"public static void RemoveAppConfig(string key)
        {
            ConfigurationManager.AppSettings.Remove(key);
        }"
"private static extern IntPtr LoadLibrary(string libname);
        public static void LoadNativeAssemblies(string rootApplicationPath)
        {
            var nativeBinaryPath = IntPtr.Size > 4
                ? Path.Combine(rootApplicationPath, @""SqlServerTypes\x64\"")
                : Path.Combine(rootApplicationPath, @""SqlServerTypes\x86\"");
            LoadNativeAssembly(nativeBinaryPath, ""msvcr120.dll"");
            LoadNativeAssembly(nativeBinaryPath, ""SqlServerSpatial140.dll"");
        }"
"private int ParseHeaders()
        {
            string lastHeader = string.Empty;
            string line = string.Empty;
            while (_lines.Count > 0 && !string.IsNullOrEmpty(_lines.Peek()))
            {
                line = _lines.Dequeue();
                if (line.StartsWith("" "") || line.StartsWith(Convert.ToString('\t')))
                {
                    _entity.Headers[lastHeader] = string.Concat(_entity.Headers[lastHeader], line);
                    continue;
                }
                int separatorIndex = line.IndexOf(':');
                if (separatorIndex < 0)
                {
                    System.Diagnostics.Debug.WriteLine(""Invalid header:{0}"", line);
                    continue;
                }  
                string headerName = line.Substring(0, separatorIndex);
                string headerValue = line.Substring(separatorIndex + 1).Trim(HeaderWhitespaceChars);
                _entity.Headers.Add(headerName.ToLower(), headerValue);
                lastHeader = headerName;
            }
            if (_lines.Count > 0)
            {
                _lines.Dequeue();
            } 
            return _entity.Headers.Count;
        }"
"private void ProcessHeaders()
        {
            foreach (string key in _entity.Headers.AllKeys)
            {
                switch (key)
                {
                    case ""content-description"":
                        _entity.ContentDescription = _entity.Headers[key];
                        break;
                    case ""content-disposition"":
                        _entity.ContentDisposition = new ContentDisposition(_entity.Headers[key]);
                        break;
                    case ""content-id"":
                        _entity.ContentId = _entity.Headers[key];
                        break;
                    case ""content-transfer-encoding"":
                        _entity.TransferEncoding = _entity.Headers[key];
                        _entity.ContentTransferEncoding = MimeReader.GetTransferEncoding(_entity.Headers[key]);
                        break;
                    case ""content-type"":
                        _entity.SetContentType(MimeReader.GetContentType(_entity.Headers[key]));
                        break;
                    case ""mime-version"":
                        _entity.MimeVersion = _entity.Headers[key];
                        break;
                }
            }
        }"
"public MimeEntity CreateMimeEntity()
        {
            try
            {
                ParseHeaders();
                ProcessHeaders();
                ParseBody();
                SetDecodedContentStream();
                return _entity;
            }
            catch
            {
                return null;
            }
        }"
"private void SetDecodedContentStream()
        {
            switch (_entity.ContentTransferEncoding)
            {
                case System.Net.Mime.TransferEncoding.Base64:
                    _entity.Content = new MemoryStream(Convert.FromBase64String(_entity.EncodedMessage.ToString()), false);
                    break;
                case System.Net.Mime.TransferEncoding.QuotedPrintable:
                    _entity.Content = new MemoryStream(GetBytes(QuotedPrintableEncoding.Decode(_entity.EncodedMessage.ToString())), false);
                    break;
                case System.Net.Mime.TransferEncoding.SevenBit:
                default:
                    _entity.Content = new MemoryStream(GetBytes(_entity.EncodedMessage.ToString()), false);
                    break;
            }
        }"
"private byte[] GetBytes(string content)
        {
            using (MemoryStream stream = new MemoryStream())
            {
                using (StreamWriter writer = new StreamWriter(stream))
                {
                    writer.Write(content);
                }
                return stream.ToArray();
            }
        }"
"private void ParseBody()
        {
            if (_entity.HasBoundary)
            {
                while (_lines.Count > 0
                    && !string.Equals(_lines.Peek(), _entity.EndBoundary))
                {
                    if (_entity.Parent != null
                        && string.Equals(_entity.Parent.StartBoundary, _lines.Peek()))
                    {
                        return;
                    }
                    if (string.Equals(_lines.Peek(), _entity.StartBoundary))
                    {
                        AddChildEntity(_entity, _lines);
                    } 
                    else if (string.Equals(_entity.ContentType.MediaType, MediaTypes.MessageRfc822, StringComparison.InvariantCultureIgnoreCase)
                        && string.Equals(_entity.ContentDisposition.DispositionType, DispositionTypeNames.Attachment, StringComparison.InvariantCultureIgnoreCase))
                    {
                        AddChildEntity(_entity, _lines);
                        break;
                    }
                    else
                    {
                        _entity.EncodedMessage.Append(string.Concat(_lines.Dequeue(), Pop3Commands.Crlf));
                    } 
                }
            } 
            else
            {
                while (_lines.Count > 0)
                {
                    _entity.EncodedMessage.Append(string.Concat(_lines.Dequeue(), Pop3Commands.Crlf));
                }
            } 
        }"
"private void AddChildEntity(MimeEntity entity, Queue<string> lines)
        {"
"public static ContentType GetContentType(string contentType)
        {
            if (string.IsNullOrEmpty(contentType))
            {
                contentType = ""text/plain; charset=us-ascii"";
            }
            return new ContentType(contentType);
        }"
"public static string GetMediaType(string mediaType)
        {
            if (string.IsNullOrEmpty(mediaType))
            {
                return ""text/plain"";
            }
            return mediaType.Trim();
        }"
"public static string GetMediaMainType(string mediaType)
        {
            int separatorIndex = mediaType.IndexOf('/');
            if (separatorIndex < 0)
            {
                return mediaType;
            }
            else
            {
                return mediaType.Substring(0, separatorIndex);
            }
        }"
"public static string GetMediaSubType(string mediaType)
        {
            int separatorIndex = mediaType.IndexOf('/');
            if (separatorIndex < 0)
            {
                if (mediaType.Equals(""text""))
                {
                    return ""plain"";
                }
                return string.Empty;
            }
            else
            {
                if (mediaType.Length > separatorIndex)
                {
                    return mediaType.Substring(separatorIndex + 1);
                }
                else
                {
                    string mainType = GetMediaMainType(mediaType);
                    if (mainType.Equals(""text""))
                    {
                        return ""plain"";
                    }
                    return string.Empty;
                }
            }
        }"
"public static TransferEncoding GetTransferEncoding(string transferEncoding)
        {
            switch (transferEncoding.Trim().ToLowerInvariant())
            {
                case ""7bit"":
                case ""8bit"":
                    return System.Net.Mime.TransferEncoding.SevenBit;
                case ""quoted-printable"":
                    return System.Net.Mime.TransferEncoding.QuotedPrintable;
                case ""base64"":
                    return System.Net.Mime.TransferEncoding.Base64;
                case ""binary"":
                default:
                    return System.Net.Mime.TransferEncoding.Unknown;
            }
        }"
"public static string Decode(string contents)
        {
            if (contents"
"public static void QueueUserWorkItem(WaitCallback callback)
        {
            QueueUserWorkItem(callback, null);
        }"
"public static void QueueUserWorkItem(WaitCallback callback, object state)
        {
            WaitingCallback waiting = new WaitingCallback(callback, state);
            lock (_poolLock) { _waitingCallbacks.Enqueue(waiting); }
            _workerThreadNeeded.AddOne();
        }"
"public static void Reset()
        {
            lock (_poolLock)
            {
                try
                {
                    foreach (object obj in _waitingCallbacks)
                    {
                        WaitingCallback callback = (WaitingCallback)obj;
                        if (callback.State is IDisposable) ((IDisposable)callback.State).Dispose();
                    }
                }
                catch { }
                try
                {
                    foreach (Thread thread in _workerThreads)
                    {
                        if (thread != null) thread.Abort(""reset"");
                    }
                }
                catch { }
                Initialize();
            }
        }"
"private static void ProcessQueuedItems()
        {
            while (true)
            {
                _workerThreadNeeded.WaitOne();
                WaitingCallback callback = null;
                lock (_poolLock)
                {
                    if (_waitingCallbacks.Count > 0)
                    {
                        try { callback = (WaitingCallback)_waitingCallbacks.Dequeue(); }
                        catch { } 
                    }
                }
                if (callback != null)
                {
                    try
                    {
                        Interlocked.Increment(ref _inUseThreads);
                        callback.Callback(callback.State);
                    }
                    catch (Exception)
                    {
                    }
                    finally
                    {
                        Interlocked.Decrement(ref _inUseThreads);
                    }
                }
            }
        }"
"public void P()
        {
            lock (_semLock)
            {
                while (_count <= 0) Monitor.Wait(_semLock, Timeout.Infinite);
                _count--;
            }
        }"
"public void V()
        {
            lock (_semLock)
            {
                _count++;
                Monitor.Pulse(_semLock);
            }
        }"
"public void Reset(int count)
        {
            lock (_semLock) { _count = count; }
        }"
"public static MemoryStream Export(DataTable dtSource, string strHeaderText)
        {
            HSSFWorkbook workbook = new HSSFWorkbook();
            ISheet sheet = workbook.CreateSheet();
            ICellStyle dateStyle = workbook.CreateCellStyle();
            IDataFormat format = workbook.CreateDataFormat();
            dateStyle.DataFormat = format.GetFormat(""yyyy-MM-dd"");
            #region 取得每列的列宽（最大宽度）
            int[] arrColWidth = new int[dtSource.Columns.Count];
            foreach (DataColumn item in dtSource.Columns)
            {
                arrColWidth[item.Ordinal] = Encoding.GetEncoding(936).GetBytes(item.ColumnName.ToString()).Length;
            }
            for (int i = 0; i < dtSource.Rows.Count; i++)
            {
                for (int j = 0; j < dtSource.Columns.Count; j++)
                {
                    int intTemp = Encoding.GetEncoding(936).GetBytes(dtSource.Rows[i][j].ToString()).Length;
                    if (intTemp > arrColWidth[j])
                    {
                        arrColWidth[j] = intTemp;
                    }
                }
            }
            #endregion
            int rowIndex = 0;
            foreach (DataRow row in dtSource.Rows)
            {
                #region 新建表，填充表头，填充列头，样式
                if (rowIndex"
"public static string GetQueryString(string queryStringName)
        {
            if ((HttpContext.Current.Request.QueryString[queryStringName] != null) &&
                (HttpContext.Current.Request.QueryString[queryStringName] != ""undefined""))
            {
                return HttpContext.Current.Request.QueryString[queryStringName].Trim();
            }
            else
            {
                return """";
            }
        }"
"private static DirectoryEntry GetDirectoryObject(string domainReference)
        {
            DirectoryEntry entry = new DirectoryEntry(ADPath + domainReference, ADUser, ADPassword,
                AuthenticationTypes.Secure);
            return entry;
        }"
"private static DirectoryEntry GetDirectoryObject(string domainReference,
            string userName, string password)
        {
            DirectoryEntry entry = new DirectoryEntry(ADPath + domainReference,
                userName, password, AuthenticationTypes.Secure);
            return entry;
        }"
"public static bool RenameAcc(string oldAcc, string newAcc)
        {
            try
            {
                if (IsAccExists(oldAcc))
                {
                    if (IsAccExists(newAcc))
                        return false;
                    DirectoryEntry userEntry = GetDirectoryEntryByAccount(oldAcc);
                    userEntry.Properties[""sAMAccountName""][0] = newAcc;
                    userEntry.CommitChanges();
                    userEntry.Dispose();
                    return true;
                }
                else
                    return false;
            }
            catch (Exception)
            {
                return false;
            }
        }"
"public static string GetDomainDN()
        {
            return LDAPDomain;
        }"
"public static void BindDropDownList_Replace(DropDownList list, Type TypeEnum)
       {
           List<ListItem> TypeList = new List<ListItem>();
           foreach (object type in Enum.GetValues(TypeEnum))
           {
               string str=type.ToString();
               if (str.Contains('N') || str.Contains('D') || str.Contains('G')||str.Contains('M')||str.Contains('Q'))
               {
                   str=str.Replace(""N"", ""$"");
                   str=str.Replace(""D"", "","");
                   str=str.Replace(""G"", "" - "");
                   str = str.Replace(""M"", ""."");
                   str = str.Replace(""Q"", """");
               }
               TypeList.Add(new ListItem(str, ((int)type).ToString()));
           }
           list.DataSource = TypeList;
           list.DataTextField = ""text"";
           list.DataValueField = ""value"";
           list.DataBind();
       }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Rset);
        }"
"protected override byte[] CreateRequestMessage()
        {
            string requestMessage = Pop3Commands.List;
            if (!IsMultiline)
            {
                requestMessage += _messageId.ToString();
            } 
            return GetRequestMessage(requestMessage, Pop3Commands.Crlf);
        }"
"protected override ListResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            List<Pop3ListItem> items;
            if (IsMultiline)
            {
                items = new List<Pop3ListItem>();
                string[] values;
                string[] lines = GetResponseLines(StripPop3HostMessage(buffer, response.HostMessage));
                foreach (string line in lines)
                {
                    values = line.Split(' ');
                    if (values.Length < 2)
                    {
                        throw new Pop3Exception(string.Concat(""Invalid line in multiline response:  "", line));
                    }
                    items.Add(new Pop3ListItem(Convert.ToInt32(values[0]),
                        Convert.ToInt64(values[1])));
                }
            } 
            else
            {
                items = new List<Pop3ListItem>(1);
                string[] values = response.HostMessage.Split(' ');
                if (values.Length < 3)
                {
                    throw new Pop3Exception(string.Concat(""Invalid response message: "", response.HostMessage));
                }
                items.Add(new Pop3ListItem(Convert.ToInt32(values[1]), Convert.ToInt64(values[2])));
            } 
            return new ListResponse(response, items);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.User, _username, Pop3Commands.Crlf);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Quit);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Pass, _password, Pop3Commands.Crlf);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Stat);
        }"
"protected override StatResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            string[] values = response.HostMessage.Split(' ');
            if (values.Length < 3)
            {
                throw new Pop3Exception(string.Concat(""Invalid response message: "", response.HostMessage));
            }
            int messageCount = Convert.ToInt32(values[1]);
            long octets = Convert.ToInt64(values[2]);
            return new StatResponse(response, messageCount, octets);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Noop);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Retr, _message.ToString(), Pop3Commands.Crlf);
        }"
"protected override RetrResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            string[] messageLines = GetResponseLines(StripPop3HostMessage(buffer, response.HostMessage));
            return new RetrResponse(response, messageLines);
        }"
"public static Pop3Response CreateResponse(byte[] responseContents)
        {
            string hostMessage;
            MemoryStream stream = new MemoryStream(responseContents);
            using (StreamReader reader = new StreamReader(stream))
            {
                hostMessage = reader.ReadLine();
                if (hostMessage"
"protected override byte[] CreateRequestMessage()
        {
            return null;
        }"
"internal override ConnectResponse Execute(Pop3State currentState)
        {
            EnsurePop3State(currentState);
            try
            {
                _client.Connect(_hostname, _port);
                SetClientStream();
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(string.Format(""Unable to connect to {0}:{1}."", _hostname, _port), e);
            }
            return base.Execute(currentState);
        }"
"private void SetClientStream()
        {
            if (_useSsl)
            {
                try
                {
                    NetworkStream = new SslStream(_client.GetStream(), true); 
                    ((SslStream)NetworkStream).AuthenticateAsClient(_hostname);
                }
                catch (ArgumentException e)
                {
                    throw new Pop3Exception(""Unable to create Ssl Stream for hostname: "" + _hostname, e);
                }
                catch (AuthenticationException e)
                {
                    throw new Pop3Exception(""Unable to authenticate ssl stream for hostname: "" + _hostname, e);
                }
                catch (InvalidOperationException e)
                {
                    throw new Pop3Exception(""There was a problem  attempting to authenticate this SSL stream for hostname: "" + _hostname, e);
                }
            } 
            else
            {
                NetworkStream = _client.GetStream();
            }
        }"
"protected override ConnectResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            return new ConnectResponse(response, NetworkStream);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Top, _messageNumber.ToString(), "" "", _lineCount.ToString(), Pop3Commands.Crlf);
        }"
"protected override RetrResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            if (response"
"protected void OnTrace(string message)
        {
            if (Trace != null)
            {
                Trace(message);
            }
        }"
"protected abstract byte[] CreateRequestMessage();
        private void Send(byte[] message)
        {
            try
            {
                _networkStream.Write(message, 0, message.Length);
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(""Unable to send the request message: "" + Encoding.ASCII.GetString(message), e);
            }
        }"
"internal virtual T Execute(Pop3State currentState)
        {
            EnsurePop3State(currentState);
            byte[] message = CreateRequestMessage();
            if (message != null)
            {
                Send(message);
            }
            T response = CreateResponse(GetResponse());
            if (response"
"protected void EnsurePop3State(Pop3State currentState)
        {
            if (!((currentState & ValidExecuteState)"
"protected virtual T CreateResponse(byte[] buffer)
        {
            return Pop3Response.CreateResponse(buffer) as T;
        }"
"private byte[] GetResponse()
        {
            AsyncCallback callback;
            if (_isMultiline)
            {
                callback = new AsyncCallback(GetMultiLineResponseCallback);
            }
            else
            {
                callback = new AsyncCallback(GetSingleLineResponseCallback);
            }
            try
            {
                Receive(callback);
                _manualResetEvent.WaitOne();
                return _responseContents.ToArray();
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(""Unable to get response."", e);
            }
        }"
"private IAsyncResult Receive(AsyncCallback callback)
        {
            return _networkStream.BeginRead(_buffer, 0, _buffer.Length, callback, null);
        }"
"private string WriteReceivedBytesToBuffer(int bytesReceived)
        {
            _responseContents.Write(_buffer, 0, bytesReceived);
            byte[] contents = _responseContents.ToArray();
            return Encoding.ASCII.GetString(contents, (contents.Length > 5 ? contents.Length - 5 : 0), 5);
        }"
"private void GetSingleLineResponseCallback(IAsyncResult ar)
        {
            int bytesReceived = _networkStream.EndRead(ar);
            string message = WriteReceivedBytesToBuffer(bytesReceived);
            if (message.EndsWith(Pop3Commands.Crlf))
            {
                _manualResetEvent.Set();
            }
            else
            {
                Receive(new AsyncCallback(GetSingleLineResponseCallback));
            }
        }"
"private void GetMultiLineResponseCallback(IAsyncResult ar)
        {
            int bytesReceived = _networkStream.EndRead(ar);
            string message = WriteReceivedBytesToBuffer(bytesReceived);
            if (message.EndsWith(MultilineMessageTerminator)
                || bytesReceived"
"protected byte[] GetRequestMessage(params string[] args)
        {
            string message = string.Join(string.Empty, args);
            OnTrace(message);
            return Encoding.ASCII.GetBytes(message);
        }"
"protected MemoryStream StripPop3HostMessage(byte[] bytes, string header)
        {
            int position = header.Length + 2;
            MemoryStream stream = new MemoryStream(bytes, position, bytes.Length - position);
            return stream;
        }"
"protected string[] GetResponseLines(MemoryStream stream)
        {
            List<string> lines = new List<string>();
            using (StreamReader reader = new StreamReader(stream))
            {
                try
                {
                    string line;
                    do
                    {
                        line = reader.ReadLine();
                        if (line.StartsWith(MessageTerminator))
                        {
                            if (line"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(string.Concat(Pop3Commands.Dele, _messageId.ToString(), Pop3Commands.Crlf));
        }"
"private void OnTrace(string message)
        {
            if (Trace != null)
            {
                Trace(message);
            }
        }"
"private void EnsureConnection()
        {
            if (!_client.Connected)
            {
                throw new Pop3Exception(""Pop3 client is not connected."");
            }
        }"
"private void SetState(Pop3State state)
        {
            _currentState = state;
        }"
"private void EnsureResponse(Pop3Response response, string error)
        {
            if (response"
"private void EnsureResponse(Pop3Response response)
        {
            EnsureResponse(response, string.Empty);
        }"
"private void Connect()
        {
            if (_client"
"private void SetClientStream(Stream networkStream)
        {
            if (_clientStream != null)
            {
                _clientStream.Dispose();
            }
            _clientStream = networkStream;
        }"
"public void Authenticate()
        {
            Connect();
            using (UserCommand userCommand = new UserCommand(_clientStream, _username))
            {
                ExecuteCommand<Pop3Response, UserCommand>(userCommand);
            }
            using (PassCommand passCommand = new PassCommand(_clientStream, _password))
            {
                ExecuteCommand<Pop3Response, PassCommand>(passCommand);
            }
            _currentState = Pop3State.Transaction;
        }"
"public void Dele(Pop3ListItem item)
        {
            if (item"
"public void Noop()
        {
            using (NoopCommand command = new NoopCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, NoopCommand>(command);
            }
        }"
"public void Rset()
        {
            using (RsetCommand command = new RsetCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, RsetCommand>(command);
            }
        }"
"public Stat Stat()
        {
            StatResponse response;
            using (StatCommand command = new StatCommand(_clientStream))
            {
                response = ExecuteCommand<StatResponse, StatCommand>(command);
            }
            return new Stat(response.MessageCount, response.Octets);
        }"
"public List<Pop3ListItem> List()
        {
            ListResponse response;
            using (ListCommand command = new ListCommand(_clientStream))
            {
                response = ExecuteCommand<ListResponse, ListCommand>(command);
            }
            return response.Items;
        }"
"public Pop3ListItem List(int messageId)
        {
            ListResponse response;
            using (ListCommand command = new ListCommand(_clientStream, messageId))
            {
                response = ExecuteCommand<ListResponse, ListCommand>(command);
            }
            return new Pop3ListItem(response.MessageNumber, response.Octets);
        }"
"public MimeEntity RetrMimeEntity(Pop3ListItem item)
        {
            if (item"
"public MailMessageEx RetrMailMessageEx(Pop3ListItem item)
        {
            MailMessageEx message = RetrMimeEntity(item).ToMailMessageEx();
            if (message != null)
            {
                message.MessageNumber = item.MessageId;
            }
            return message;
        }"
"public void Quit()
        {
            using (QuitCommand command = new QuitCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, QuitCommand>(command);
                if (CurrentState.Equals(Pop3State.Transaction))
                {
                    SetState(Pop3State.Update);
                } 
                Disconnect();
                SetState(Pop3State.Unknown);
            }
        }"
"private void Disconnect()
        {
            if (_clientStream != null)
            {
                _clientStream.Close();
            }  
            if (_client != null)
            {
                _client.Close();
                _client = null;
            }
        }"
"private static extern long WritePrivateProfileString(string section,string key,string val,string filePath);
        [DllImport(""kernel32"")]
        private static extern int GetPrivateProfileString(string section,string key,string def, StringBuilder retVal,int size,string filePath);
        [DllImport(""kernel32"")]
        private static extern int GetPrivateProfileString(string section, string key, string defVal, Byte[] retVal, int size, string filePath);
        public void IniWriteValue(string Section,string Key,string Value)
        {
            WritePrivateProfileString(Section,Key,Value,this.path);
        }"
"public static void UpdateToMaster(DbConnection conn)
        {
        }"
"public static object GetSession(string name)
        {
            return HttpContext.Current.Session[name];
        }"
"public static IPEndPoint CreateIPEndPoint(string ip, int port)
        {
            IPAddress ipAddress = StringToIPAddress(ip);
            return new IPEndPoint(ipAddress, port);
        }"
"private static extern long WritePrivateProfileString(string section,string key,string val,string filePath);
        [DllImport(""kernel32"")]
        private static extern int GetPrivateProfileString(string section,string key,string def, StringBuilder retVal,int size,string filePath);
        [DllImport(""kernel32"")]
        private static extern int GetPrivateProfileString(string section, string key, string defVal, Byte[] retVal, int size, string filePath);
        public void IniWriteValue(string Section,string Key,string Value)
        {
            WritePrivateProfileString(Section,Key,Value,this.path);
        }"
"private static extern IntPtr LoadLibrary(string libname);
        public static void LoadNativeAssemblies(string rootApplicationPath)
        {
            var nativeBinaryPath = IntPtr.Size > 4
                ? Path.Combine(rootApplicationPath, @""SqlServerTypes\x64\"")
                : Path.Combine(rootApplicationPath, @""SqlServerTypes\x86\"");
            LoadNativeAssembly(nativeBinaryPath, ""msvcr120.dll"");
            LoadNativeAssembly(nativeBinaryPath, ""SqlServerSpatial140.dll"");
        }"
"public static SqlDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            try
            {
                SqlConnection conn = new SqlConnection(connectionString);
                    PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                    SqlDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                    cmd.Parameters.Clear();
                    return rdr;
            }
            catch
            {
                throw;
            }
        }"
"public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"public static object ExecuteScalar(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"public static void CacheParameters(string cacheKey, params SqlParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"public static SqlParameter[] GetCachedParameters(string cacheKey)
        {
            SqlParameter[] cachedParms = (SqlParameter[])parmCache[cacheKey];
            if (cachedParms"
"public static IPEndPoint CreateIPEndPoint(string ip, int port)
        {
            IPAddress ipAddress = StringToIPAddress(ip);
            return new IPEndPoint(ipAddress, port);
        }"
"public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"private static OracleCommand BuildIntCommand(OracleConnection connection,string storedProcName, IDataParameter[] parameters)
		{
			OracleCommand command = BuildQueryCommand(connection,storedProcName, parameters );
			command.Parameters.Add( new OracleParameter ( ""ReturnValue"",
                OracleType.Int32, 4, ParameterDirection.ReturnValue,
				false,0,0,string.Empty,DataRowVersion.Default,null ));
			return command;
		}"
"public bool ColumnExists(string tableName, string columnName)
        {
            string sql = ""select count(1) from syscolumns where [id]=object_id('"" + tableName + ""') and [name]='"" + columnName + ""'"";
            object res = GetSingle(sql);
            if (res"
"public static bool ColumnExists(string tableName, string columnName)
        {
            string sql = ""select count(1) from syscolumns where [id]=object_id('"" + tableName + ""') and [name]='"" + columnName + ""'"";
            object res = GetSingle(sql);
            if (res"
"public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = DbHelperSQL.GetSingle(strsql);
            if (obj"
"public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"public static int GetMaxID(string FieldName, string TableName)
        {
            string strsql = ""select max("" + FieldName + "")+1 from "" + TableName;
            object obj = GetSingle(strsql);
            if (obj"
"public static int ExecuteNonQuery(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            using (OracleConnection connection = new OracleConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                int val = cmd.ExecuteNonQuery();
                connection.Close();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"public static int ExecuteNonQuery(OracleTransaction trans, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, trans.Connection, trans, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"public static int ExecuteNonQuery(OracleConnection connection, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"public static OracleDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            OracleConnection conn = new OracleConnection(connectionString);
            try
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                OracleDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                cmd.Parameters.Clear();
                return rdr;
            }
            catch
            {
                conn.Close();
                throw;
            }
        }"
"public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            using (OracleConnection conn = new OracleConnection(connectionString))
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"public static object ExecuteScalar(OracleTransaction transaction, CommandType commandType, string commandText, params OracleParameter[] commandParameters)
        {
            if (transaction"
"public static object ExecuteScalar(OracleConnection connectionString, CommandType cmdType, string cmdText, params OracleParameter[] commandParameters)
        {
            OracleCommand cmd = new OracleCommand();
            PrepareCommand(cmd, connectionString, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"public static void CacheParameters(string cacheKey, params OracleParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"public static OracleParameter[] GetCachedParameters(string cacheKey)
        {
            OracleParameter[] cachedParms = (OracleParameter[])parmCache[cacheKey];
            if (cachedParms"
"public static string OraBit(bool value)
        {
            if (value)
                return ""Y"";
            else
                return ""N"";
        }"
"public static bool OraBool(string value)
        {
            if (value.Equals(""Y""))
                return true;
            else
                return false;
        }"
"public static int ExecuteNonQuery(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection conn = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                int val = cmd.ExecuteNonQuery();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"public static int ExecuteNonQuery(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"public static int ExecuteNonQuery(SqlTransaction trans, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, trans.Connection, trans, cmdType, cmdText, commandParameters);
            int val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }"
"public static SqlDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            SqlConnection conn = new SqlConnection(connectionString);
            try
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                SqlDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                cmd.Parameters.Clear();
                return rdr;
            }
            catch
            {
                conn.Close();
                throw;
            }
        }"
"public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }"
"public static object ExecuteScalar(SqlConnection connection, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
            object val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }"
"public static void CacheParameters(string cacheKey, params SqlParameter[] commandParameters)
        {
            parmCache[cacheKey] = commandParameters;
        }"
"public static SqlParameter[] GetCachedParameters(string cacheKey)
        {
            SqlParameter[] cachedParms = (SqlParameter[])parmCache[cacheKey];
            if (cachedParms"
"private static void PrepareCommand(SqlCommand cmd, SqlConnection conn, SqlTransaction trans, CommandType cmdType, string cmdText, SqlParameter[] cmdParms)
        {
            if (conn.State != ConnectionState.Open)
                conn.Open();
            cmd.Connection = conn;
            cmd.CommandText = cmdText;
            if (trans != null)
                cmd.Transaction = trans;
            cmd.CommandType = cmdType;
            if (cmdParms != null)
            {
                foreach (SqlParameter parm in cmdParms)
                    cmd.Parameters.Add(parm);
            }
        }"
"public static string ToJson(DataTable dt, string jsonName)
        {
            StringBuilder Json = new StringBuilder();
            if (string.IsNullOrEmpty(jsonName)) jsonName = dt.TableName;
            Json.Append(""{\"""" + jsonName + ""\"":["");
            if (dt.Rows.Count > 0)
            {
                for (int i = 0; i < dt.Rows.Count; i++)
                {
                    Json.Append(""{"");
                    for (int j = 0; j < dt.Columns.Count; j++)
                    {
                        Type type = dt.Rows[i][j].GetType();
                        Json.Append(""\"""" + dt.Columns[j].ColumnName.ToString() + ""\"":"" + StringFormat(dt.Rows[i][j].ToString(), type));
                        if (j < dt.Columns.Count - 1)
                        {
                            Json.Append("","");
                        }
                    }
                    Json.Append(""}"");
                    if (i < dt.Rows.Count - 1)
                    {
                        Json.Append("","");
                    }
                }
            }
            Json.Append(""]}"");
            return Json.ToString();
        }"
"public static List<Dictionary<string, object>> DataTableToDictionary(DataTable dt)
        {
            List<Dictionary<string, object>> list = new List<Dictionary<string, object>>();
            foreach (DataRow dr in dt.Rows)
            {
                Dictionary<string, object> result = new Dictionary<string, object>();
                foreach (DataColumn dc in dt.Columns)
                {
                    result.Add(dc.ColumnName, dr[dc].ToString());
                }
                list.Add(result);
            }
            return list;
        }"
"public static List<string> GetStrArray(string str, char speater, bool toLower)
        {
            List<string> list = new List<string>();
            string[] ss = str.Split(speater);
            foreach (string s in ss)
            {
                if (!string.IsNullOrEmpty(s) && s != speater.ToString())
                {
                    string strVal = s;
                    if (toLower)
                    {
                        strVal = s.ToLower();
                    }
                    list.Add(strVal);
                }
            }
            return list;
        }"
"private static string Create(int Length, bool Sleep, char[] List)
		{
			if (Sleep) Thread.Sleep(3);
			char[] Pattern = List;
			string result = string.Empty;
			int n = Pattern.Length;
			for (int i = 0; i < Length; i++)
			{
				int rnd = Random.Next(0, n);
				result += Pattern[rnd];
			}
			return result;
		}"
"public static void BindDropDownList_Replace(DropDownList list, Type TypeEnum)
       {
           List<ListItem> TypeList = new List<ListItem>();
           foreach (object type in Enum.GetValues(TypeEnum))
           {
               string str=type.ToString();
               if (str.Contains('N') || str.Contains('D') || str.Contains('G')||str.Contains('M')||str.Contains('Q'))
               {
                   str=str.Replace(""N"", ""$"");
                   str=str.Replace(""D"", "","");
                   str=str.Replace(""G"", "" - "");
                   str = str.Replace(""M"", ""."");
                   str = str.Replace(""Q"", """");
               }
               TypeList.Add(new ListItem(str, ((int)type).ToString()));
           }
           list.DataSource = TypeList;
           list.DataTextField = ""text"";
           list.DataValueField = ""value"";
           list.DataBind();
       }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Rset);
        }"
"protected override byte[] CreateRequestMessage()
        {
            string requestMessage = Pop3Commands.List;
            if (!IsMultiline)
            {
                requestMessage += _messageId.ToString();
            } 
            return GetRequestMessage(requestMessage, Pop3Commands.Crlf);
        }"
"protected override ListResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            List<Pop3ListItem> items;
            if (IsMultiline)
            {
                items = new List<Pop3ListItem>();
                string[] values;
                string[] lines = GetResponseLines(StripPop3HostMessage(buffer, response.HostMessage));
                foreach (string line in lines)
                {
                    values = line.Split(' ');
                    if (values.Length < 2)
                    {
                        throw new Pop3Exception(string.Concat(""Invalid line in multiline response:  "", line));
                    }
                    items.Add(new Pop3ListItem(Convert.ToInt32(values[0]),
                        Convert.ToInt64(values[1])));
                }
            } 
            else
            {
                items = new List<Pop3ListItem>(1);
                string[] values = response.HostMessage.Split(' ');
                if (values.Length < 3)
                {
                    throw new Pop3Exception(string.Concat(""Invalid response message: "", response.HostMessage));
                }
                items.Add(new Pop3ListItem(Convert.ToInt32(values[1]), Convert.ToInt64(values[2])));
            } 
            return new ListResponse(response, items);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.User, _username, Pop3Commands.Crlf);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Quit);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Pass, _password, Pop3Commands.Crlf);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Stat);
        }"
"protected override StatResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            string[] values = response.HostMessage.Split(' ');
            if (values.Length < 3)
            {
                throw new Pop3Exception(string.Concat(""Invalid response message: "", response.HostMessage));
            }
            int messageCount = Convert.ToInt32(values[1]);
            long octets = Convert.ToInt64(values[2]);
            return new StatResponse(response, messageCount, octets);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Noop);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Retr, _message.ToString(), Pop3Commands.Crlf);
        }"
"protected override RetrResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            string[] messageLines = GetResponseLines(StripPop3HostMessage(buffer, response.HostMessage));
            return new RetrResponse(response, messageLines);
        }"
"public static Pop3Response CreateResponse(byte[] responseContents)
        {
            string hostMessage;
            MemoryStream stream = new MemoryStream(responseContents);
            using (StreamReader reader = new StreamReader(stream))
            {
                hostMessage = reader.ReadLine();
                if (hostMessage"
"protected override byte[] CreateRequestMessage()
        {
            return null;
        }"
"internal override ConnectResponse Execute(Pop3State currentState)
        {
            EnsurePop3State(currentState);
            try
            {
                _client.Connect(_hostname, _port);
                SetClientStream();
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(string.Format(""Unable to connect to {0}:{1}."", _hostname, _port), e);
            }
            return base.Execute(currentState);
        }"
"private void SetClientStream()
        {
            if (_useSsl)
            {
                try
                {
                    NetworkStream = new SslStream(_client.GetStream(), true); 
                    ((SslStream)NetworkStream).AuthenticateAsClient(_hostname);
                }
                catch (ArgumentException e)
                {
                    throw new Pop3Exception(""Unable to create Ssl Stream for hostname: "" + _hostname, e);
                }
                catch (AuthenticationException e)
                {
                    throw new Pop3Exception(""Unable to authenticate ssl stream for hostname: "" + _hostname, e);
                }
                catch (InvalidOperationException e)
                {
                    throw new Pop3Exception(""There was a problem  attempting to authenticate this SSL stream for hostname: "" + _hostname, e);
                }
            } 
            else
            {
                NetworkStream = _client.GetStream();
            }
        }"
"protected override ConnectResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            return new ConnectResponse(response, NetworkStream);
        }"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(Pop3Commands.Top, _messageNumber.ToString(), "" "", _lineCount.ToString(), Pop3Commands.Crlf);
        }"
"protected override RetrResponse CreateResponse(byte[] buffer)
        {
            Pop3Response response = Pop3Response.CreateResponse(buffer);
            if (response"
"protected void OnTrace(string message)
        {
            if (Trace != null)
            {
                Trace(message);
            }
        }"
"protected abstract byte[] CreateRequestMessage();
        private void Send(byte[] message)
        {
            try
            {
                _networkStream.Write(message, 0, message.Length);
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(""Unable to send the request message: "" + Encoding.ASCII.GetString(message), e);
            }
        }"
"internal virtual T Execute(Pop3State currentState)
        {
            EnsurePop3State(currentState);
            byte[] message = CreateRequestMessage();
            if (message != null)
            {
                Send(message);
            }
            T response = CreateResponse(GetResponse());
            if (response"
"protected void EnsurePop3State(Pop3State currentState)
        {
            if (!((currentState & ValidExecuteState)"
"protected virtual T CreateResponse(byte[] buffer)
        {
            return Pop3Response.CreateResponse(buffer) as T;
        }"
"private byte[] GetResponse()
        {
            AsyncCallback callback;
            if (_isMultiline)
            {
                callback = new AsyncCallback(GetMultiLineResponseCallback);
            }
            else
            {
                callback = new AsyncCallback(GetSingleLineResponseCallback);
            }
            try
            {
                Receive(callback);
                _manualResetEvent.WaitOne();
                return _responseContents.ToArray();
            }
            catch (SocketException e)
            {
                throw new Pop3Exception(""Unable to get response."", e);
            }
        }"
"private IAsyncResult Receive(AsyncCallback callback)
        {
            return _networkStream.BeginRead(_buffer, 0, _buffer.Length, callback, null);
        }"
"private string WriteReceivedBytesToBuffer(int bytesReceived)
        {
            _responseContents.Write(_buffer, 0, bytesReceived);
            byte[] contents = _responseContents.ToArray();
            return Encoding.ASCII.GetString(contents, (contents.Length > 5 ? contents.Length - 5 : 0), 5);
        }"
"private void GetSingleLineResponseCallback(IAsyncResult ar)
        {
            int bytesReceived = _networkStream.EndRead(ar);
            string message = WriteReceivedBytesToBuffer(bytesReceived);
            if (message.EndsWith(Pop3Commands.Crlf))
            {
                _manualResetEvent.Set();
            }
            else
            {
                Receive(new AsyncCallback(GetSingleLineResponseCallback));
            }
        }"
"private void GetMultiLineResponseCallback(IAsyncResult ar)
        {
            int bytesReceived = _networkStream.EndRead(ar);
            string message = WriteReceivedBytesToBuffer(bytesReceived);
            if (message.EndsWith(MultilineMessageTerminator)
                || bytesReceived"
"protected byte[] GetRequestMessage(params string[] args)
        {
            string message = string.Join(string.Empty, args);
            OnTrace(message);
            return Encoding.ASCII.GetBytes(message);
        }"
"protected MemoryStream StripPop3HostMessage(byte[] bytes, string header)
        {
            int position = header.Length + 2;
            MemoryStream stream = new MemoryStream(bytes, position, bytes.Length - position);
            return stream;
        }"
"protected string[] GetResponseLines(MemoryStream stream)
        {
            List<string> lines = new List<string>();
            using (StreamReader reader = new StreamReader(stream))
            {
                try
                {
                    string line;
                    do
                    {
                        line = reader.ReadLine();
                        if (line.StartsWith(MessageTerminator))
                        {
                            if (line"
"protected override byte[] CreateRequestMessage()
        {
            return GetRequestMessage(string.Concat(Pop3Commands.Dele, _messageId.ToString(), Pop3Commands.Crlf));
        }"
"private void OnTrace(string message)
        {
            if (Trace != null)
            {
                Trace(message);
            }
        }"
"private void EnsureConnection()
        {
            if (!_client.Connected)
            {
                throw new Pop3Exception(""Pop3 client is not connected."");
            }
        }"
"private void SetState(Pop3State state)
        {
            _currentState = state;
        }"
"private void EnsureResponse(Pop3Response response, string error)
        {
            if (response"
"private void EnsureResponse(Pop3Response response)
        {
            EnsureResponse(response, string.Empty);
        }"
"private void Connect()
        {
            if (_client"
"private void SetClientStream(Stream networkStream)
        {
            if (_clientStream != null)
            {
                _clientStream.Dispose();
            }
            _clientStream = networkStream;
        }"
"public void Authenticate()
        {
            Connect();
            using (UserCommand userCommand = new UserCommand(_clientStream, _username))
            {
                ExecuteCommand<Pop3Response, UserCommand>(userCommand);
            }
            using (PassCommand passCommand = new PassCommand(_clientStream, _password))
            {
                ExecuteCommand<Pop3Response, PassCommand>(passCommand);
            }
            _currentState = Pop3State.Transaction;
        }"
"public void Dele(Pop3ListItem item)
        {
            if (item"
"public void Noop()
        {
            using (NoopCommand command = new NoopCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, NoopCommand>(command);
            }
        }"
"public void Rset()
        {
            using (RsetCommand command = new RsetCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, RsetCommand>(command);
            }
        }"
"public Stat Stat()
        {
            StatResponse response;
            using (StatCommand command = new StatCommand(_clientStream))
            {
                response = ExecuteCommand<StatResponse, StatCommand>(command);
            }
            return new Stat(response.MessageCount, response.Octets);
        }"
"public List<Pop3ListItem> List()
        {
            ListResponse response;
            using (ListCommand command = new ListCommand(_clientStream))
            {
                response = ExecuteCommand<ListResponse, ListCommand>(command);
            }
            return response.Items;
        }"
"public Pop3ListItem List(int messageId)
        {
            ListResponse response;
            using (ListCommand command = new ListCommand(_clientStream, messageId))
            {
                response = ExecuteCommand<ListResponse, ListCommand>(command);
            }
            return new Pop3ListItem(response.MessageNumber, response.Octets);
        }"
"public MimeEntity RetrMimeEntity(Pop3ListItem item)
        {
            if (item"
"public MailMessageEx RetrMailMessageEx(Pop3ListItem item)
        {
            MailMessageEx message = RetrMimeEntity(item).ToMailMessageEx();
            if (message != null)
            {
                message.MessageNumber = item.MessageId;
            }
            return message;
        }"
"public void Quit()
        {
            using (QuitCommand command = new QuitCommand(_clientStream))
            {
                ExecuteCommand<Pop3Response, QuitCommand>(command);
                if (CurrentState.Equals(Pop3State.Transaction))
                {
                    SetState(Pop3State.Update);
                } 
                Disconnect();
                SetState(Pop3State.Unknown);
            }
        }"
"private void Disconnect()
        {
            if (_clientStream != null)
            {
                _clientStream.Close();
            }  
            if (_client != null)
            {
                _client.Close();
                _client = null;
            }
        }"
"public static void QueueUserWorkItem(WaitCallback callback)
        {
            QueueUserWorkItem(callback, null);
        }"
"public static void QueueUserWorkItem(WaitCallback callback, object state)
        {
            WaitingCallback waiting = new WaitingCallback(callback, state);
            lock (_poolLock) { _waitingCallbacks.Enqueue(waiting); }
            _workerThreadNeeded.AddOne();
        }"
"public static void Reset()
        {
            lock (_poolLock)
            {
                try
                {
                    foreach (object obj in _waitingCallbacks)
                    {
                        WaitingCallback callback = (WaitingCallback)obj;
                        if (callback.State is IDisposable) ((IDisposable)callback.State).Dispose();
                    }
                }
                catch { }
                try
                {
                    foreach (Thread thread in _workerThreads)
                    {
                        if (thread != null) thread.Abort(""reset"");
                    }
                }
                catch { }
                Initialize();
            }
        }"
"private static void ProcessQueuedItems()
        {
            while (true)
            {
                _workerThreadNeeded.WaitOne();
                WaitingCallback callback = null;
                lock (_poolLock)
                {
                    if (_waitingCallbacks.Count > 0)
                    {
                        try { callback = (WaitingCallback)_waitingCallbacks.Dequeue(); }
                        catch { } 
                    }
                }
                if (callback != null)
                {
                    try
                    {
                        Interlocked.Increment(ref _inUseThreads);
                        callback.Callback(callback.State);
                    }
                    catch (Exception)
                    {
                    }
                    finally
                    {
                        Interlocked.Decrement(ref _inUseThreads);
                    }
                }
            }
        }"
"public void P()
        {
            lock (_semLock)
            {
                while (_count <= 0) Monitor.Wait(_semLock, Timeout.Infinite);
                _count--;
            }
        }"
"public void V()
        {
            lock (_semLock)
            {
                _count++;
                Monitor.Pulse(_semLock);
            }
        }"
"public void Reset(int count)
        {
            lock (_semLock) { _count = count; }
        }"
"public static void Export(string fileName, GridView gv)
        {
            HttpContext.Current.Response.Clear();
            HttpContext.Current.Response.AddHeader(
                ""content-disposition"", string.Format(""attachment; filename={0}"", fileName));
            HttpContext.Current.Response.ContentType = ""application/ms-excel"";
            using (StringWriter sw = new StringWriter())
            {
                using (HtmlTextWriter htw = new HtmlTextWriter(sw))
                {
                    Table table = new Table();
                    table.GridLines = GridLines.Both;  
                    if (gv.HeaderRow != null)
                    {
                        PrepareControlForExport(gv.HeaderRow);
                        table.Rows.Add(gv.HeaderRow);
                    }
                    foreach (GridViewRow row in gv.Rows)
                    {
                        PrepareControlForExport(row);
                        table.Rows.Add(row);
                    }
                    if (gv.FooterRow != null)
                    {
                        PrepareControlForExport(gv.FooterRow);
                        table.Rows.Add(gv.FooterRow);
                    }
                    table.RenderControl(htw);
                    HttpContext.Current.Response.Write(sw.ToString());
                    HttpContext.Current.Response.End();
                }
            }
        }"
"private static void PrepareControlForExport(Control control)
        {
            for (int i = 0; i < control.Controls.Count; i++)
            {
                Control current = control.Controls[i];
                if (current is LinkButton)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as LinkButton).Text));
                }
                else if (current is ImageButton)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as ImageButton).AlternateText));
                }
                else if (current is HyperLink)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as HyperLink).Text));
                }
                else if (current is DropDownList)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as DropDownList).SelectedItem.Text));
                }
                else if (current is CheckBox)
                {
                    control.Controls.Remove(current);
                    control.Controls.AddAt(i, new LiteralControl((current as CheckBox).Checked ? ""True"" : ""False""));
                }
                if (current.HasControls())
                {
                    PrepareControlForExport(current);
                }
            }
        }"
"private void Page_Load(object sender, EventArgs e)
        {
            char[] chars = ""023456789"".ToCharArray();
            System.Random random = new Random();
            string validateCode = string.Empty;
            for (int i = 0; i < 4; i++)
            {
                char rc = chars[random.Next(0, chars.Length)];
                if (validateCode.IndexOf(rc) > -1)
                {
                    i--;
                    continue;
                }
                validateCode += rc;
            }
            Session[""xk_validate_code""] = validateCode;
            CreateImage(validateCode);
        }"
"public string GenerateCheckCodeNum(int codeCount)
        {
            codeCount = codeCount > 10 ? 10 :codeCount;   
            int[] arrInt = {0,1,2,3,4,5,6,7,8,9};
		    arrInt = arrInt.OrderBy(c => Guid.NewGuid()).ToArray<int>();
            string str = string.Empty;
            for (int i = 0; i < codeCount; i++)
            {
                str += arrInt[i];
            }
            return str;
        }"
"public string GenerateCheckCode(int CodeCount)
        {
            char[] MixedList = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I','J', 'K', 'L', 'M', 'N','O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' }; 
			return GetRandomCode(MixedList, CodeCount);
		}"
"private string GetRandomCode(char[] CharList, int CodeLength)
        {
			string result = string.Empty;
			for (int i = 0; i < CodeLength; i++)
			{
				int rnd = Random.Next(0, CharList.Length);
				result += CharList[rnd];
			}
			return result;
        }"
"private static extern IntPtr LoadLibrary(string libname);
        public static void LoadNativeAssemblies(string rootApplicationPath)
        {
            var nativeBinaryPath = IntPtr.Size > 4
                ? Path.Combine(rootApplicationPath, @""SqlServerTypes\x64\"")
                : Path.Combine(rootApplicationPath, @""SqlServerTypes\x86\"");
            LoadNativeAssembly(nativeBinaryPath, ""msvcr120.dll"");
            LoadNativeAssembly(nativeBinaryPath, ""SqlServerSpatial140.dll"");
        }"
"private int ParseHeaders()
        {
            string lastHeader = string.Empty;
            string line = string.Empty;
            while (_lines.Count > 0 && !string.IsNullOrEmpty(_lines.Peek()))
            {
                line = _lines.Dequeue();
                if (line.StartsWith("" "") || line.StartsWith(Convert.ToString('\t')))
                {
                    _entity.Headers[lastHeader] = string.Concat(_entity.Headers[lastHeader], line);
                    continue;
                }
                int separatorIndex = line.IndexOf(':');
                if (separatorIndex < 0)
                {
                    System.Diagnostics.Debug.WriteLine(""Invalid header:{0}"", line);
                    continue;
                }  
                string headerName = line.Substring(0, separatorIndex);
                string headerValue = line.Substring(separatorIndex + 1).Trim(HeaderWhitespaceChars);
                _entity.Headers.Add(headerName.ToLower(), headerValue);
                lastHeader = headerName;
            }
            if (_lines.Count > 0)
            {
                _lines.Dequeue();
            } 
            return _entity.Headers.Count;
        }"
"private void ProcessHeaders()
        {
            foreach (string key in _entity.Headers.AllKeys)
            {
                switch (key)
                {
                    case ""content-description"":
                        _entity.ContentDescription = _entity.Headers[key];
                        break;
                    case ""content-disposition"":
                        _entity.ContentDisposition = new ContentDisposition(_entity.Headers[key]);
                        break;
                    case ""content-id"":
                        _entity.ContentId = _entity.Headers[key];
                        break;
                    case ""content-transfer-encoding"":
                        _entity.TransferEncoding = _entity.Headers[key];
                        _entity.ContentTransferEncoding = MimeReader.GetTransferEncoding(_entity.Headers[key]);
                        break;
                    case ""content-type"":
                        _entity.SetContentType(MimeReader.GetContentType(_entity.Headers[key]));
                        break;
                    case ""mime-version"":
                        _entity.MimeVersion = _entity.Headers[key];
                        break;
                }
            }
        }"
"public MimeEntity CreateMimeEntity()
        {
            try
            {
                ParseHeaders();
                ProcessHeaders();
                ParseBody();
                SetDecodedContentStream();
                return _entity;
            }
            catch
            {
                return null;
            }
        }"
"private void SetDecodedContentStream()
        {
            switch (_entity.ContentTransferEncoding)
            {
                case System.Net.Mime.TransferEncoding.Base64:
                    _entity.Content = new MemoryStream(Convert.FromBase64String(_entity.EncodedMessage.ToString()), false);
                    break;
                case System.Net.Mime.TransferEncoding.QuotedPrintable:
                    _entity.Content = new MemoryStream(GetBytes(QuotedPrintableEncoding.Decode(_entity.EncodedMessage.ToString())), false);
                    break;
                case System.Net.Mime.TransferEncoding.SevenBit:
                default:
                    _entity.Content = new MemoryStream(GetBytes(_entity.EncodedMessage.ToString()), false);
                    break;
            }
        }"
"private byte[] GetBytes(string content)
        {
            using (MemoryStream stream = new MemoryStream())
            {
                using (StreamWriter writer = new StreamWriter(stream))
                {
                    writer.Write(content);
                }
                return stream.ToArray();
            }
        }"
"private void ParseBody()
        {
            if (_entity.HasBoundary)
            {
                while (_lines.Count > 0
                    && !string.Equals(_lines.Peek(), _entity.EndBoundary))
                {
                    if (_entity.Parent != null
                        && string.Equals(_entity.Parent.StartBoundary, _lines.Peek()))
                    {
                        return;
                    }
                    if (string.Equals(_lines.Peek(), _entity.StartBoundary))
                    {
                        AddChildEntity(_entity, _lines);
                    } 
                    else if (string.Equals(_entity.ContentType.MediaType, MediaTypes.MessageRfc822, StringComparison.InvariantCultureIgnoreCase)
                        && string.Equals(_entity.ContentDisposition.DispositionType, DispositionTypeNames.Attachment, StringComparison.InvariantCultureIgnoreCase))
                    {
                        AddChildEntity(_entity, _lines);
                        break;
                    }
                    else
                    {
                        _entity.EncodedMessage.Append(string.Concat(_lines.Dequeue(), Pop3Commands.Crlf));
                    } 
                }
            } 
            else
            {
                while (_lines.Count > 0)
                {
                    _entity.EncodedMessage.Append(string.Concat(_lines.Dequeue(), Pop3Commands.Crlf));
                }
            } 
        }"
"private void AddChildEntity(MimeEntity entity, Queue<string> lines)
        {"
"public static ContentType GetContentType(string contentType)
        {
            if (string.IsNullOrEmpty(contentType))
            {
                contentType = ""text/plain; charset=us-ascii"";
            }
            return new ContentType(contentType);
        }"
"public static string GetMediaType(string mediaType)
        {
            if (string.IsNullOrEmpty(mediaType))
            {
                return ""text/plain"";
            }
            return mediaType.Trim();
        }"
"public static string GetMediaMainType(string mediaType)
        {
            int separatorIndex = mediaType.IndexOf('/');
            if (separatorIndex < 0)
            {
                return mediaType;
            }
            else
            {
                return mediaType.Substring(0, separatorIndex);
            }
        }"
"public static string GetMediaSubType(string mediaType)
        {
            int separatorIndex = mediaType.IndexOf('/');
            if (separatorIndex < 0)
            {
                if (mediaType.Equals(""text""))
                {
                    return ""plain"";
                }
                return string.Empty;
            }
            else
            {
                if (mediaType.Length > separatorIndex)
                {
                    return mediaType.Substring(separatorIndex + 1);
                }
                else
                {
                    string mainType = GetMediaMainType(mediaType);
                    if (mainType.Equals(""text""))
                    {
                        return ""plain"";
                    }
                    return string.Empty;
                }
            }
        }"
"public static TransferEncoding GetTransferEncoding(string transferEncoding)
        {
            switch (transferEncoding.Trim().ToLowerInvariant())
            {
                case ""7bit"":
                case ""8bit"":
                    return System.Net.Mime.TransferEncoding.SevenBit;
                case ""quoted-printable"":
                    return System.Net.Mime.TransferEncoding.QuotedPrintable;
                case ""base64"":
                    return System.Net.Mime.TransferEncoding.Base64;
                case ""binary"":
                default:
                    return System.Net.Mime.TransferEncoding.Unknown;
            }
        }"
"public static string Decode(string contents)
        {
            if (contents"
"public static IntervalTask CreateTask(Action taskAction)
		{
			if (Current != null)
				throw new FieldAccessException(""CreateTask requested, but a task already exists."");
			Current = new IntervalTask(taskAction);
			return Current;
		}"
"public void SetInterval(int interval)
		{
			intervalTimer.SetInterval(interval);
		}"
"public void StopTimer()
		{
			intervalTimer.Stop();
		}"
"public void Stop(bool immediate)
		{
			lock (syncLock)
			{
				ShuttingDown = true;
				if (!TaskRunning)
					this.Dispose();
			}
		}"
"public void Dispose()
		{
			StopTimer();
			System.Web.Hosting.HostingEnvironment.UnregisterObject(this);
		}"
"public void SetInterval(int milliseconds)
		{
			if (timer"
"public string GetFormatDate(DateTime dt, char Separator)
        {
            if (dt != null && !dt.Equals(DBNull.Value))
            {
                string tem = string.Format(""yyyy{0}MM{1}dd"", Separator, Separator);
                return dt.ToString(tem);
            }
            else
            {
                return GetFormatDate(DateTime.Now, Separator);
            }
        }"
"public static string FormatDate(string dateString)
        {
            var dt = ParseToDateValue(dateString);
            if (dt"
"public static MemoryStream Export(DataTable dtSource, string strHeaderText)
        {
            HSSFWorkbook workbook = new HSSFWorkbook();
            ISheet sheet = workbook.CreateSheet();
            ICellStyle dateStyle = workbook.CreateCellStyle();
            IDataFormat format = workbook.CreateDataFormat();
            dateStyle.DataFormat = format.GetFormat(""yyyy-MM-dd"");
            #region 取得每列的列宽（最大宽度）
            int[] arrColWidth = new int[dtSource.Columns.Count];
            foreach (DataColumn item in dtSource.Columns)
            {
                arrColWidth[item.Ordinal] = Encoding.GetEncoding(936).GetBytes(item.ColumnName.ToString()).Length;
            }
            for (int i = 0; i < dtSource.Rows.Count; i++)
            {
                for (int j = 0; j < dtSource.Columns.Count; j++)
                {
                    int intTemp = Encoding.GetEncoding(936).GetBytes(dtSource.Rows[i][j].ToString()).Length;
                    if (intTemp > arrColWidth[j])
                    {
                        arrColWidth[j] = intTemp;
                    }
                }
            }
            #endregion
            int rowIndex = 0;
            foreach (DataRow row in dtSource.Rows)
            {
                #region 新建表，填充表头，填充列头，样式
                if (rowIndex"
"public static string Encrypt(string original)
        {
            return Encrypt(original, ""kuiyu.net"");
        }"
"static public string SEncryptString(string inputStr, string keyStr)
        {
            MySecurity ws = new MySecurity();
            return ws.EncryptString(inputStr, keyStr);
        }"
"public static void RemoveAppConfig(string key)
        {
            ConfigurationManager.AppSettings.Remove(key);
        }"
"public static string GetQueryString(string queryStringName)
        {
            if ((HttpContext.Current.Request.QueryString[queryStringName] != null) &&
                (HttpContext.Current.Request.QueryString[queryStringName] != ""undefined""))
            {
                return HttpContext.Current.Request.QueryString[queryStringName].Trim();
            }
            else
            {
                return """";
            }
        }"
"private static DirectoryEntry GetDirectoryObject(string domainReference)
        {
            DirectoryEntry entry = new DirectoryEntry(ADPath + domainReference, ADUser, ADPassword,
                AuthenticationTypes.Secure);
            return entry;
        }"
"private static DirectoryEntry GetDirectoryObject(string domainReference,
            string userName, string password)
        {
            DirectoryEntry entry = new DirectoryEntry(ADPath + domainReference,
                userName, password, AuthenticationTypes.Secure);
            return entry;
        }"
"public static bool RenameAcc(string oldAcc, string newAcc)
        {
            try
            {
                if (IsAccExists(oldAcc))
                {
                    if (IsAccExists(newAcc))
                        return false;
                    DirectoryEntry userEntry = GetDirectoryEntryByAccount(oldAcc);
                    userEntry.Properties[""sAMAccountName""][0] = newAcc;
                    userEntry.CommitChanges();
                    userEntry.Dispose();
                    return true;
                }
                else
                    return false;
            }
            catch (Exception)
            {
                return false;
            }
        }"
"public class Step6_Use_CustomMapper(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task UseCustomMapperAsync()
    {
        var recordDefinition = new VectorStoreRecordDefinition
        {
            Properties = new List<VectorStoreRecordProperty>
            {
                new VectorStoreRecordKeyProperty(""Key"", typeof(string)),
                new VectorStoreRecordDataProperty(""Category"", typeof(string)),
                new VectorStoreRecordDataProperty(""Term"", typeof(string)),
                new VectorStoreRecordDataProperty(""Definition"", typeof(string)),
                new VectorStoreRecordVectorProperty(""DefinitionEmbedding"", typeof(ReadOnlyMemory<float>)) { Dimensions = 1536 },
            }
        };
        var collection = new AzureAISearchVectorStoreRecordCollection<ComplexGlossary>(
            new SearchIndexClient(
                new Uri(TestConfiguration.AzureAISearch.Endpoint),
                new AzureKeyCredential(TestConfiguration.AzureAISearch.ApiKey)),
            ""skglossary"",
            new()
            {
                JsonObjectCustomMapper = new CustomMapper(),
                VectorStoreRecordDefinition = recordDefinition
            });
        await collection.CreateCollectionIfNotExistsAsync();
        var definition = ""A set of rules and protocols that allows one software application to interact with another."";
        await collection.UpsertAsync(new ComplexGlossary
        {
            Key = ""1"",
            Metadata = new Metadata
            {
                Category = ""API"",
                Term = ""Application Programming Interface""
            },
            Definition = definition,
            DefinitionEmbedding = await fixture.TextEmbeddingGenerationService.GenerateEmbeddingAsync(definition)
        });
        var searchVector = await fixture.TextEmbeddingGenerationService.GenerateEmbeddingAsync(""How do two software applications interact with another?"");
        var searchResult = await collection.VectorizedSearchAsync(
            searchVector,
            new()
            {
                Top = 1
            });
        var searchResultItem = await searchResult.Results.FirstAsync();
        Console.WriteLine(searchResultItem.Record.Metadata.Term);
        Console.WriteLine(searchResultItem.Record.Definition);
        Console.WriteLine(searchResultItem.Score);
    }
    private sealed class CustomMapper : IVectorStoreRecordMapper<ComplexGlossary, JsonObject>
    {
        public JsonObject MapFromDataToStorageModel(ComplexGlossary dataModel)
        {
            return new JsonObject
            {
                [""Key""] = dataModel.Key,
                [""Category""] = dataModel.Metadata.Category,
                [""Term""] = dataModel.Metadata.Term,
                [""Definition""] = dataModel.Definition,
                [""DefinitionEmbedding""] = JsonSerializer.SerializeToNode(dataModel.DefinitionEmbedding.ToArray())
            };
        }
        public ComplexGlossary MapFromStorageToDataModel(JsonObject storageModel, StorageToDataModelMapperOptions options)
        {
            return new ComplexGlossary
            {
                Key = storageModel[""Key""]!.ToString(),
                Metadata = new Metadata
                {
                    Category = storageModel[""Category""]!.ToString(),
                    Term = storageModel[""Term""]!.ToString()
                },
                Definition = storageModel[""Definition""]!.ToString(),
                DefinitionEmbedding = JsonSerializer.Deserialize<ReadOnlyMemory<float>>(storageModel[""DefinitionEmbedding""])
            };
        }
    }
    private sealed class ComplexGlossary
    {
        public string Key { get; set; }
        public Metadata Metadata { get; set; }
        public string Definition { get; set; }
        public ReadOnlyMemory<float> DefinitionEmbedding { get; set; }
    }
    private sealed class Metadata
    {
        public string Category { get; set; }
        public string Term { get; set; }
    }
}"
"public class Step1_Ingest_Data(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task IngestDataIntoInMemoryVectorStoreAsync()
    {
        var vectorStore = new InMemoryVectorStore();
        var collection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        await IngestDataIntoVectorStoreAsync(collection, fixture.TextEmbeddingGenerationService);
        var record = await collection.GetAsync(""4"");
        Console.WriteLine(record!.Definition);
    }
    internal static async Task<IEnumerable<string>> IngestDataIntoVectorStoreAsync(
        IVectorStoreRecordCollection<string, Glossary> collection,
        ITextEmbeddingGenerationService textEmbeddingGenerationService)
    {
        await collection.CreateCollectionIfNotExistsAsync();
        var glossaryEntries = CreateGlossaryEntries().ToList();
        var tasks = glossaryEntries.Select(entry => Task.Run(async () =>
        {
            entry.DefinitionEmbedding = await textEmbeddingGenerationService.GenerateEmbeddingAsync(entry.Definition);
        }));
        await Task.WhenAll(tasks);
        var upsertedKeysTasks = glossaryEntries.Select(x => collection.UpsertAsync(x));
        return await Task.WhenAll(upsertedKeysTasks);
    }
    private static IEnumerable<Glossary> CreateGlossaryEntries()
    {
        yield return new Glossary
        {
            Key = ""1"",
            Category = ""Software"",
            Term = ""API"",
            Definition = ""Application Programming Interface. A set of rules and specifications that allow software components to communicate and exchange data.""
        };
        yield return new Glossary
        {
            Key = ""2"",
            Category = ""Software"",
            Term = ""SDK"",
            Definition = ""Software development kit. A set of libraries and tools that allow software developers to build software more easily.""
        };
        yield return new Glossary
        {
            Key = ""3"",
            Category = ""SK"",
            Term = ""Connectors"",
            Definition = ""Semantic Kernel Connectors allow software developers to integrate with various services providing AI capabilities, including LLM, AudioToText, TextToAudio, Embedding generation, etc.""
        };
        yield return new Glossary
        {
            Key = ""4"",
            Category = ""SK"",
            Term = ""Semantic Kernel"",
            Definition = ""Semantic Kernel is a set of libraries that allow software developers to more easily develop applications that make use of AI experiences.""
        };
        yield return new Glossary
        {
            Key = ""5"",
            Category = ""AI"",
            Term = ""RAG"",
            Definition = ""Retrieval Augmented Generation - a term that refers to the process of retrieving additional data to provide as context to an LLM to use when generating a response (completion) to a user’s question (prompt).""
        };
        yield return new Glossary
        {
            Key = ""6"",
            Category = ""AI"",
            Term = ""LLM"",
            Definition = ""Large language model. A type of artificial ingelligence algorithm that is designed to understand and generate human language.""
        };
    }
}"
"public class Step2_Vector_Search(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task SearchAnInMemoryVectorStoreAsync()
    {
        var collection = await GetVectorStoreCollectionWithDataAsync();
        var searchResultItem = await SearchVectorStoreAsync(
            collection,
            ""What is an Application Programming Interface?"",
            fixture.TextEmbeddingGenerationService);
        Console.WriteLine(searchResultItem.Record.Definition);
        Console.WriteLine(searchResultItem.Score);
    }
    internal static async Task<VectorSearchResult<Glossary>> SearchVectorStoreAsync(IVectorStoreRecordCollection<string, Glossary> collection, string searchString, ITextEmbeddingGenerationService textEmbeddingGenerationService)
    {
        var searchVector = await textEmbeddingGenerationService.GenerateEmbeddingAsync(searchString);
        var searchResult = await collection.VectorizedSearchAsync(
            searchVector,
            new()
            {
                Top = 1
            });
        var searchResultItems = await searchResult.Results.ToListAsync();
        return searchResultItems.First();
    }
    [Fact]
    public async Task SearchAnInMemoryVectorStoreWithFilteringAsync()
    {
        var collection = await GetVectorStoreCollectionWithDataAsync();
        var searchString = ""How do I provide additional context to an LLM?"";
        var searchVector = await fixture.TextEmbeddingGenerationService.GenerateEmbeddingAsync(searchString);
        var searchResult = await collection.VectorizedSearchAsync(
            searchVector,
            new()
            {
                Top = 1,
                Filter = new VectorSearchFilter().EqualTo(nameof(Glossary.Category), ""AI"")
            });
        var searchResultItems = await searchResult.Results.ToListAsync();
        Console.WriteLine(searchResultItems.First().Record.Definition);
        Console.WriteLine(searchResultItems.First().Score);
    }
    private async Task<IVectorStoreRecordCollection<string, Glossary>> GetVectorStoreCollectionWithDataAsync()
    {
        var vectorStore = new InMemoryVectorStore();
        var collection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        await Step1_Ingest_Data.IngestDataIntoVectorStoreAsync(collection, fixture.TextEmbeddingGenerationService);
        return collection;
    }
}"
"public class Step5_Use_GenericDataModel(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task SearchAVectorStoreWithGenericDataModelAsync()
    {
        var vectorStore = new RedisVectorStore(ConnectionMultiplexer.Connect(""localhost:6379"").GetDatabase());
        var collection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        var customDataModelCollection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        await Step1_Ingest_Data.IngestDataIntoVectorStoreAsync(customDataModelCollection, fixture.TextEmbeddingGenerationService);
        var recordDefinition = new VectorStoreRecordDefinition
        {
            Properties = new List<VectorStoreRecordProperty>
            {
                new VectorStoreRecordKeyProperty(""Key"", typeof(string)),
                new VectorStoreRecordDataProperty(""Category"", typeof(string)),
                new VectorStoreRecordDataProperty(""Term"", typeof(string)),
                new VectorStoreRecordDataProperty(""Definition"", typeof(string)),
                new VectorStoreRecordVectorProperty(""DefinitionEmbedding"", typeof(ReadOnlyMemory<float>)) { Dimensions = 1536 },
            }
        };
        var genericDataModelCollection = vectorStore.GetCollection<string, VectorStoreGenericDataModel<string>>(""skglossary"", recordDefinition);
        var searchString = ""How do I provide additional context to an LLM?"";
        var searchVector = await fixture.TextEmbeddingGenerationService.GenerateEmbeddingAsync(searchString);
        var searchResult = await genericDataModelCollection.VectorizedSearchAsync(
            searchVector,
            new()
            {
                Top = 1,
            });
        var searchResultItems = await searchResult.Results.ToListAsync();
        foreach (var dataProperty in searchResultItems.First().Record.Data)
        {
            Console.WriteLine($""{dataProperty.Key}: {dataProperty.Value}"");
        }
        Console.WriteLine(searchResultItems.First().Score);
    }
}"
"public class Step3_Switch_VectorStore(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task UseAnAzureAISearchVectorStoreAsync()
    {
        var vectorStore = new AzureAISearchVectorStore(new SearchIndexClient(
            new Uri(TestConfiguration.AzureAISearch.Endpoint),
            new AzureKeyCredential(TestConfiguration.AzureAISearch.ApiKey)));
        var collection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        await Step1_Ingest_Data.IngestDataIntoVectorStoreAsync(collection, fixture.TextEmbeddingGenerationService);
        var searchResultItem = await Step2_Vector_Search.SearchVectorStoreAsync(
            collection,
            ""What is an Application Programming Interface?"",
            fixture.TextEmbeddingGenerationService);
        Console.WriteLine(searchResultItem.Record.Definition);
        Console.WriteLine(searchResultItem.Score);
    }
    [Fact]
    public async Task UseARedisVectorStoreAsync()
    {
        var vectorStore = new RedisVectorStore(ConnectionMultiplexer.Connect(""localhost:6379"").GetDatabase());
        var collection = vectorStore.GetCollection<string, Glossary>(""skglossary"");
        await Step1_Ingest_Data.IngestDataIntoVectorStoreAsync(collection, fixture.TextEmbeddingGenerationService);
        var searchResultItem = await Step2_Vector_Search.SearchVectorStoreAsync(
            collection,
            ""What is an Application Programming Interface?"",
            fixture.TextEmbeddingGenerationService);
        Console.WriteLine(searchResultItem.Record.Definition);
        Console.WriteLine(searchResultItem.Score);
    }
}"
"public class Step4_NonStringKey_VectorStore(ITestOutputHelper output, VectorStoresFixture fixture) : BaseTest(output), IClassFixture<VectorStoresFixture>
{
    [Fact]
    public async Task UseAQdrantVectorStoreAsync()
    {
        var collection = new QdrantVectorStoreRecordCollection<UlongGlossary>(new QdrantClient(""localhost""), ""skglossary"");
        var stringKeyCollection = new MappingVectorStoreRecordCollection<string, ulong, Glossary, UlongGlossary>(
            collection,
            p => ulong.Parse(p),
            i => i.ToString(),
            p => new UlongGlossary { Key = ulong.Parse(p.Key), Category = p.Category, Term = p.Term, Definition = p.Definition, DefinitionEmbedding = p.DefinitionEmbedding },
            i => new Glossary { Key = i.Key.ToString(""D""), Category = i.Category, Term = i.Term, Definition = i.Definition, DefinitionEmbedding = i.DefinitionEmbedding });
        await Step1_Ingest_Data.IngestDataIntoVectorStoreAsync(stringKeyCollection, fixture.TextEmbeddingGenerationService);
        var searchResultItem = await Step2_Vector_Search.SearchVectorStoreAsync(
            stringKeyCollection,
            ""What is an Application Programming Interface?"",
            fixture.TextEmbeddingGenerationService);
        Console.WriteLine(searchResultItem.Record.Definition);
        Console.WriteLine(searchResultItem.Score);
    }
    private sealed class UlongGlossary
    {
        [VectorStoreRecordKey]
        public ulong Key { get; set; }
        [VectorStoreRecordData(IsFilterable = true)]
        public string Category { get; set; }
        [VectorStoreRecordData]
        public string Term { get; set; }
        [VectorStoreRecordData]
        public string Definition { get; set; }
        [VectorStoreRecordVector(Dimensions: 1536)]
        public ReadOnlyMemory<float> DefinitionEmbedding { get; set; }
    }
    private sealed class MappingVectorStoreRecordCollection<TPublicKey, TInternalKey, TPublicRecord, TInternalRecord> : IVectorStoreRecordCollection<TPublicKey, TPublicRecord>
        where TPublicKey : notnull
        where TInternalKey : notnull
    {
        private readonly IVectorStoreRecordCollection<TInternalKey, TInternalRecord> _collection;
        private readonly Func<TPublicKey, TInternalKey> _publicToInternalKeyMapper;
        private readonly Func<TInternalKey, TPublicKey> _internalToPublicKeyMapper;
        private readonly Func<TPublicRecord, TInternalRecord> _publicToInternalRecordMapper;
        private readonly Func<TInternalRecord, TPublicRecord> _internalToPublicRecordMapper;
        public MappingVectorStoreRecordCollection(
            IVectorStoreRecordCollection<TInternalKey, TInternalRecord> collection,
            Func<TPublicKey, TInternalKey> publicToInternalKeyMapper,
            Func<TInternalKey, TPublicKey> internalToPublicKeyMapper,
            Func<TPublicRecord, TInternalRecord> publicToInternalRecordMapper,
            Func<TInternalRecord, TPublicRecord> internalToPublicRecordMapper)
        {
            this._collection = collection;
            this._publicToInternalKeyMapper = publicToInternalKeyMapper;
            this._internalToPublicKeyMapper = internalToPublicKeyMapper;
            this._publicToInternalRecordMapper = publicToInternalRecordMapper;
            this._internalToPublicRecordMapper = internalToPublicRecordMapper;
        }
        public string CollectionName => this._collection.CollectionName;
        public Task<bool> CollectionExistsAsync(CancellationToken cancellationToken = default)
        {
            return this._collection.CollectionExistsAsync(cancellationToken);
        }
        public Task CreateCollectionAsync(CancellationToken cancellationToken = default)
        {
            return this._collection.CreateCollectionAsync(cancellationToken);
        }
        public Task CreateCollectionIfNotExistsAsync(CancellationToken cancellationToken = default)
        {
            return this._collection.CreateCollectionIfNotExistsAsync(cancellationToken);
        }
        public Task DeleteAsync(TPublicKey key, DeleteRecordOptions? options = null, CancellationToken cancellationToken = default)
        {
            return this._collection.DeleteAsync(this._publicToInternalKeyMapper(key), options, cancellationToken);
        }
        public Task DeleteBatchAsync(IEnumerable<TPublicKey> keys, DeleteRecordOptions? options = null, CancellationToken cancellationToken = default)
        {
            return this._collection.DeleteBatchAsync(keys.Select(this._publicToInternalKeyMapper), options, cancellationToken);
        }
        public Task DeleteCollectionAsync(CancellationToken cancellationToken = default)
        {
            return this._collection.DeleteCollectionAsync(cancellationToken);
        }
        public async Task<TPublicRecord?> GetAsync(TPublicKey key, GetRecordOptions? options = null, CancellationToken cancellationToken = default)
        {
            var internalRecord = await this._collection.GetAsync(this._publicToInternalKeyMapper(key), options, cancellationToken).ConfigureAwait(false);
            if (internalRecord"
"public class Step04_KernelFunctionStrategies(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string ReviewerName = ""ArtDirector"";
    private const string ReviewerInstructions =
        """"""
        You are an art director who has opinions about copywriting born of a love for David Ogilvy.
        The goal is to determine if the given copy is acceptable to print.
        If so, state that it is approved.
        If not, provide insight on how to refine suggested copy without examples.
        """""";
    private const string CopyWriterName = ""CopyWriter"";
    private const string CopyWriterInstructions =
        """"""
        You are a copywriter with ten years of experience and are known for brevity and a dry humor.
        The goal is to refine and decide on the single best copy as an expert in the field.
        Only provide a single proposal per response.
        Never delimit the response with quotation marks.
        You're laser focused on the goal at hand.
        Don't waste time with chit chat.
        Consider suggestions when refining an idea.
        """""";
    [Fact]
    public async Task UseKernelFunctionStrategiesWithAgentGroupChatAsync()
    {
        ChatCompletionAgent agentReviewer =
            new()
            {
                Instructions = ReviewerInstructions,
                Name = ReviewerName,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        ChatCompletionAgent agentWriter =
            new()
            {
                Instructions = CopyWriterInstructions,
                Name = CopyWriterName,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        KernelFunction terminationFunction =
            AgentGroupChat.CreatePromptFunctionForStrategy(
                """"""
                Determine if the copy has been approved.  If so, respond with a single word: yes
                History:
                {{$history}}
                """""",
                safeParameterNames: ""history"");
        KernelFunction selectionFunction =
            AgentGroupChat.CreatePromptFunctionForStrategy(
                $$$""""""
                Determine which participant takes the next turn in a conversation based on the the most recent participant.
                State only the name of the participant to take the next turn.
                No participant should take more than one turn in a row.
                Choose only from these participants:
                - {{{ReviewerName}}}
                - {{{CopyWriterName}}}
                Always follow these rules when selecting the next participant:
                - After {{{CopyWriterName}}}, it is {{{ReviewerName}}}'s turn.
                - After {{{ReviewerName}}}, it is {{{CopyWriterName}}}'s turn.
                History:
                {{$history}}
                """""",
                safeParameterNames: ""history"");
        ChatHistoryTruncationReducer strategyReducer = new(1);
        AgentGroupChat chat =
            new(agentWriter, agentReviewer)
            {
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy =
                            new KernelFunctionTerminationStrategy(terminationFunction, CreateKernelWithChatCompletion())
                            {
                                Agents = [agentReviewer],
                                ResultParser = (result) => result.GetValue<string>()?.Contains(""yes"", StringComparison.OrdinalIgnoreCase) ?? false,
                                HistoryVariableName = ""history"",
                                MaximumIterations = 10,
                                HistoryReducer = strategyReducer,
                            },
                        SelectionStrategy =
                            new KernelFunctionSelectionStrategy(selectionFunction, CreateKernelWithChatCompletion())
                            {
                                InitialAgent = agentWriter,
                                ResultParser = (result) => result.GetValue<string>() ?? CopyWriterName,
                                HistoryVariableName = ""history"",
                                HistoryReducer = strategyReducer,
                            },
                    }
            };
        ChatMessageContent message = new(AuthorRole.User, ""concept: maps made out of egg cartons."");
        chat.AddChatMessage(message);
        this.WriteAgentChatMessage(message);
        await foreach (ChatMessageContent responese in chat.InvokeAsync())
        {
            this.WriteAgentChatMessage(responese);
        }
        Console.WriteLine($""\n[IS COMPLETED: {chat.IsComplete}]"");
    }
}"
"public class Step01_Agent(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string ParrotName = ""Parrot"";
    private const string ParrotInstructions = ""Repeat the user message in the voice of a pirate and then end with a parrot sound."";
    [Fact]
    public async Task UseSingleChatCompletionAgentAsync()
    {
        Kernel kernel = this.CreateKernelWithChatCompletion();
        ChatCompletionAgent agent =
            new()
            {
                Name = ParrotName,
                Instructions = ParrotInstructions,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        ChatHistory chat = [];
        await InvokeAgentAsync(""Fortune favors the bold."");
        await InvokeAgentAsync(""I came, I saw, I conquered."");
        await InvokeAgentAsync(""Practice makes perfect."");
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            chat.Add(message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(chat))
            {
                chat.Add(response);
                this.WriteAgentChatMessage(response);
            }
        }
    }
    [Fact]
    public async Task UseTemplateForChatCompletionAgentAsync()
    {
        string generateStoryYaml = EmbeddedResource.Read(""GenerateStory.yaml"");
        PromptTemplateConfig templateConfig = KernelFunctionYaml.ToPromptTemplateConfig(generateStoryYaml);
        ChatCompletionAgent agent =
            new(templateConfig, new KernelPromptTemplateFactory())
            {
                Kernel = this.CreateKernelWithChatCompletion(),
                Arguments = new KernelArguments()
                {
                    { ""topic"", ""Dog"" },
                    { ""length"", ""3"" },
                }
            };
        ChatHistory chat = [];
        await InvokeAgentAsync();
        await InvokeAgentAsync(
            new()
            {
                { ""topic"", ""Cat"" },
                { ""length"", ""3"" },
            });
        async Task InvokeAgentAsync(KernelArguments? arguments = null)
        {
            await foreach (ChatMessageContent content in agent.InvokeAsync(chat, arguments))
            {
                chat.Add(content);
                WriteAgentChatMessage(content);
            }
        }
    }
}"
"public class Step09_Assistant_Vision(ITestOutputHelper output) : BaseAgentsTest(output)
{
    protected override bool ForceOpenAI => true;
    [Fact]
    public async Task UseSingleAssistantAgentAsync()
    {
        OpenAIClientProvider provider = this.GetClientProvider();
        OpenAIAssistantAgent agent =
            await OpenAIAssistantAgent.CreateAsync(
                provider,
                definition: new OpenAIAssistantDefinition(this.Model)
                {
                    Metadata = AssistantSampleMetadata,
                },
                kernel: new Kernel());
        await using Stream imageStream = EmbeddedResource.ReadStream(""cat.jpg"")!;
        string fileId = await agent.UploadFileAsync(imageStream, ""cat.jpg"");
        string threadId = await agent.CreateThreadAsync(new OpenAIThreadCreationOptions { Metadata = AssistantSampleMetadata });
        try
        {
            await InvokeAgentAsync(CreateMessageWithImageUrl(""Describe this image."", ""https:
            await InvokeAgentAsync(CreateMessageWithImageUrl(""What are is the main color in this image?"", ""https:
            await InvokeAgentAsync(CreateMessageWithImageReference(""Is there an animal in this image?"", fileId));
        }
        finally
        {
            await agent.DeleteThreadAsync(threadId);
            await agent.DeleteAsync();
            await provider.Client.GetOpenAIFileClient().DeleteFileAsync(fileId);
        }
        async Task InvokeAgentAsync(ChatMessageContent message)
        {
            await agent.AddChatMessageAsync(threadId, message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(threadId))
            {
                this.WriteAgentChatMessage(response);
            }
        }
    }
    private ChatMessageContent CreateMessageWithImageUrl(string input, string url)
        => new(AuthorRole.User, [new TextContent(input), new ImageContent(new Uri(url))]);
    private ChatMessageContent CreateMessageWithImageReference(string input, string fileId)
        => new(AuthorRole.User, [new TextContent(input), new FileReferenceContent(fileId)]);
}"
"public class Step10_AssistantTool_CodeInterpreter(ITestOutputHelper output) : BaseAgentsTest(output)
{
    [Fact]
    public async Task UseCodeInterpreterToolWithAssistantAgentAsync()
    {
        OpenAIAssistantAgent agent =
            await OpenAIAssistantAgent.CreateAsync(
                clientProvider: this.GetClientProvider(),
                definition: new(this.Model)
                {
                    EnableCodeInterpreter = true,
                    Metadata = AssistantSampleMetadata,
                },
                kernel: new Kernel());
        string threadId = await agent.CreateThreadAsync(new OpenAIThreadCreationOptions { Metadata = AssistantSampleMetadata });
        try
        {
            await InvokeAgentAsync(""Use code to determine the values in the Fibonacci sequence that that are less then the value of 101?"");
        }
        finally
        {
            await agent.DeleteThreadAsync(threadId);
            await agent.DeleteAsync();
        }
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            await agent.AddChatMessageAsync(threadId, message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(threadId))
            {
                this.WriteAgentChatMessage(response);
            }
        }
    }
}"
"public class Step11_AssistantTool_FileSearch(ITestOutputHelper output) : BaseAgentsTest(output)
{
    [Fact]
    public async Task UseFileSearchToolWithAssistantAgentAsync()
    {
        OpenAIClientProvider provider = this.GetClientProvider();
        OpenAIAssistantAgent agent =
            await OpenAIAssistantAgent.CreateAsync(
                clientProvider: this.GetClientProvider(),
                definition: new OpenAIAssistantDefinition(this.Model)
                {
                    EnableFileSearch = true,
                    Metadata = AssistantSampleMetadata,
                },
                kernel: new Kernel());
        OpenAIFileClient fileClient = provider.Client.GetOpenAIFileClient();
        await using Stream stream = EmbeddedResource.ReadStream(""employees.pdf"")!;
        OpenAIFile fileInfo = await fileClient.UploadFileAsync(stream, ""employees.pdf"", FileUploadPurpose.Assistants);
        VectorStoreClient vectorStoreClient = provider.Client.GetVectorStoreClient();
        CreateVectorStoreOperation result =
            await vectorStoreClient.CreateVectorStoreAsync(waitUntilCompleted: false,
                new VectorStoreCreationOptions()
                {
                    FileIds = { fileInfo.Id },
                    Metadata = { { AssistantSampleMetadataKey, bool.TrueString } }
                });
        string threadId =
            await agent.CreateThreadAsync(
                new OpenAIThreadCreationOptions
                {
                    VectorStoreId = result.VectorStoreId,
                    Metadata = AssistantSampleMetadata,
                });
        try
        {
            await InvokeAgentAsync(""Who is the youngest employee?"");
            await InvokeAgentAsync(""Who works in sales?"");
            await InvokeAgentAsync(""I have a customer request, who can help me?"");
        }
        finally
        {
            await agent.DeleteThreadAsync(threadId);
            await agent.DeleteAsync();
            await vectorStoreClient.DeleteVectorStoreAsync(result.VectorStoreId);
            await fileClient.DeleteFileAsync(fileInfo.Id);
        }
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            await agent.AddChatMessageAsync(threadId, message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(threadId))
            {
                this.WriteAgentChatMessage(response);
            }
        }
    }
}"
"public class Step06_DependencyInjection(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string TutorName = ""Tutor"";
    private const string TutorInstructions =
        """"""
        Think step-by-step and rate the user input on creativity and expressiveness from 1-100.
        Respond in JSON format with the following JSON schema:
        {
            ""score"": ""integer (1-100)"",
            ""notes"": ""the reason for your score""
        }
        """""";
    [Fact]
    public async Task UseDependencyInjectionToCreateAgentAsync()
    {
        ServiceCollection serviceContainer = new();
        serviceContainer.AddLogging(c => c.AddConsole().SetMinimumLevel(LogLevel.Information));
        if (this.UseOpenAIConfig)
        {
            serviceContainer.AddOpenAIChatCompletion(
                TestConfiguration.OpenAI.ChatModelId,
                TestConfiguration.OpenAI.ApiKey);
        }
        else
        {
            serviceContainer.AddAzureOpenAIChatCompletion(
                TestConfiguration.AzureOpenAI.ChatDeploymentName,
                TestConfiguration.AzureOpenAI.Endpoint,
                TestConfiguration.AzureOpenAI.ApiKey);
        }
        serviceContainer.AddTransient<Kernel>();
        serviceContainer.AddTransient<AgentClient>();
        serviceContainer.AddKeyedSingleton<ChatCompletionAgent>(
            TutorName,
            (sp, key) =>
                new ChatCompletionAgent()
                {
                    Instructions = TutorInstructions,
                    Name = TutorName,
                    Kernel = sp.GetRequiredService<Kernel>().Clone(),
                });
        await using ServiceProvider serviceProvider = serviceContainer.BuildServiceProvider();
        AgentClient agentClient = serviceProvider.GetRequiredService<AgentClient>();
        await WriteAgentResponse(""The sunset is nice."");
        await WriteAgentResponse(""The sunset is setting over the mountains."");
        await WriteAgentResponse(""The sunset is setting over the mountains and filled the sky with a deep red flame, setting the clouds ablaze."");
        async Task WriteAgentResponse(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agentClient.RunDemoAsync(message))
            {
                this.WriteAgentChatMessage(response);
            }
        }
    }
    private sealed class AgentClient([FromKeyedServices(TutorName)] ChatCompletionAgent agent)
    {
        private readonly AgentGroupChat _chat = new();
        public IAsyncEnumerable<ChatMessageContent> RunDemoAsync(ChatMessageContent input)
        {
            this._chat.AddChatMessage(input);
            return this._chat.InvokeAsync(agent);
        }
    }
    private record struct WritingScore(int score, string notes);
}"
"public class Step08_Assistant(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string HostName = ""Host"";
    private const string HostInstructions = ""Answer questions about the menu."";
    [Fact]
    public async Task UseSingleAssistantAgentAsync()
    {
        OpenAIAssistantAgent agent =
            await OpenAIAssistantAgent.CreateAsync(
                clientProvider: this.GetClientProvider(),
                definition: new OpenAIAssistantDefinition(this.Model)
                {
                    Instructions = HostInstructions,
                    Name = HostName,
                    Metadata = AssistantSampleMetadata,
                },
                kernel: new Kernel());
        KernelPlugin plugin = KernelPluginFactory.CreateFromType<MenuPlugin>();
        agent.Kernel.Plugins.Add(plugin);
        string threadId = await agent.CreateThreadAsync(new OpenAIThreadCreationOptions { Metadata = AssistantSampleMetadata });
        try
        {
            await InvokeAgentAsync(""Hello"");
            await InvokeAgentAsync(""What is the special soup and its price?"");
            await InvokeAgentAsync(""What is the special drink and its price?"");
            await InvokeAgentAsync(""Thank you"");
        }
        finally
        {
            await agent.DeleteThreadAsync(threadId);
            await agent.DeleteAsync();
        }
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            await agent.AddChatMessageAsync(threadId, message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(threadId))
            {
                this.WriteAgentChatMessage(response);
            }
        }
    }
    [Fact]
    public async Task UseTemplateForAssistantAgentAsync()
    {
        string generateStoryYaml = EmbeddedResource.Read(""GenerateStory.yaml"");
        PromptTemplateConfig templateConfig = KernelFunctionYaml.ToPromptTemplateConfig(generateStoryYaml);
        OpenAIAssistantAgent agent =
            await OpenAIAssistantAgent.CreateFromTemplateAsync(
                clientProvider: this.GetClientProvider(),
                capabilities: new OpenAIAssistantCapabilities(this.Model)
                {
                    Metadata = AssistantSampleMetadata,
                },
                kernel: new Kernel(),
                defaultArguments: new KernelArguments()
                {
                    { ""topic"", ""Dog"" },
                    { ""length"", ""3"" },
                },
                templateConfig);
        string threadId = await agent.CreateThreadAsync(new OpenAIThreadCreationOptions { Metadata = AssistantSampleMetadata });
        try
        {
            await InvokeAgentAsync();
            await InvokeAgentAsync(
                new()
                {
                { ""topic"", ""Cat"" },
                { ""length"", ""3"" },
                });
        }
        finally
        {
            await agent.DeleteThreadAsync(threadId);
            await agent.DeleteAsync();
        }
        async Task InvokeAgentAsync(KernelArguments? arguments = null)
        {
            await foreach (ChatMessageContent response in agent.InvokeAsync(threadId, arguments))
            {
                WriteAgentChatMessage(response);
            }
        }
    }
    private sealed class MenuPlugin
    {
        [KernelFunction, Description(""Provides a list of specials from the menu."")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage(""Design"", ""CA1024:Use properties where appropriate"", Justification = ""Too smart"")]
        public string GetSpecials() =>
            """"""
            Special Soup: Clam Chowder
            Special Salad: Cobb Salad
            Special Drink: Chai Tea
            """""";
        [KernelFunction, Description(""Provides the price of the requested menu item."")]
        public string GetItemPrice(
            [Description(""The name of the menu item."")]
            string menuItem) =>
            ""$9.99"";
    }
}"
"public class Step02_Plugins(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string HostName = ""Host"";
    private const string HostInstructions = ""Answer questions about the menu."";
    [Fact]
    public async Task UseChatCompletionWithPluginAgentAsync()
    {
        ChatCompletionAgent agent =
            new()
            {
                Instructions = HostInstructions,
                Name = HostName,
                Kernel = this.CreateKernelWithChatCompletion(),
                Arguments = new KernelArguments(new OpenAIPromptExecutionSettings() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() }),
            };
        KernelPlugin plugin = KernelPluginFactory.CreateFromType<MenuPlugin>();
        agent.Kernel.Plugins.Add(plugin);
        ChatHistory chat = [];
        await InvokeAgentAsync(""Hello"");
        await InvokeAgentAsync(""What is the special soup?"");
        await InvokeAgentAsync(""What is the special drink?"");
        await InvokeAgentAsync(""Thank you"");
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            chat.Add(message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in agent.InvokeAsync(chat))
            {
                chat.Add(response);
                this.WriteAgentChatMessage(response);
            }
        }
    }
    private sealed class MenuPlugin
    {
        [KernelFunction, Description(""Provides a list of specials from the menu."")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage(""Design"", ""CA1024:Use properties where appropriate"", Justification = ""Too smart"")]
        public string GetSpecials() =>
            """"""
            Special Soup: Clam Chowder
            Special Salad: Cobb Salad
            Special Drink: Chai Tea
            """""";
        [KernelFunction, Description(""Provides the price of the requested menu item."")]
        public string GetItemPrice(
            [Description(""The name of the menu item."")]
            string menuItem) =>
            ""$9.99"";
    }
}"
"public class Step05_JsonResult(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const int ScoreCompletionThreshold = 70;
    private const string TutorName = ""Tutor"";
    private const string TutorInstructions =
        """"""
        Think step-by-step and rate the user input on creativity and expressiveness from 1-100.
        Respond in JSON format with the following JSON schema:
        {
            ""score"": ""integer (1-100)"",
            ""notes"": ""the reason for your score""
        }
        """""";
    [Fact]
    public async Task UseKernelFunctionStrategiesWithJsonResultAsync()
    {
        ChatCompletionAgent agent =
            new()
            {
                Instructions = TutorInstructions,
                Name = TutorName,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        AgentGroupChat chat =
            new()
            {
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy = new ThresholdTerminationStrategy()
                    }
            };
        await InvokeAgentAsync(""The sunset is very colorful."");
        await InvokeAgentAsync(""The sunset is setting over the mountains."");
        await InvokeAgentAsync(""The sunset is setting over the mountains and filled the sky with a deep red flame, setting the clouds ablaze."");
        async Task InvokeAgentAsync(string input)
        {
            ChatMessageContent message = new(AuthorRole.User, input);
            chat.AddChatMessage(message);
            this.WriteAgentChatMessage(message);
            await foreach (ChatMessageContent response in chat.InvokeAsync(agent))
            {
                this.WriteAgentChatMessage(response);
                Console.WriteLine($""[IS COMPLETED: {chat.IsComplete}]"");
            }
        }
    }
    private record struct WritingScore(int score, string notes);
    private sealed class ThresholdTerminationStrategy : TerminationStrategy
    {
        protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken)
        {
            string lastMessageContent = history[history.Count - 1].Content ?? string.Empty;
            WritingScore? result = JsonResultTranslator.Translate<WritingScore>(lastMessageContent);
            return Task.FromResult((result?.score ?? 0) >= ScoreCompletionThreshold);
        }
    }
}"
"public class Step07_Logging(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string ReviewerName = ""ArtDirector"";
    private const string ReviewerInstructions =
        """"""
        You are an art director who has opinions about copywriting born of a love for David Ogilvy.
        The goal is to determine if the given copy is acceptable to print.
        If so, state that it is approved.
        If not, provide insight on how to refine suggested copy without examples.
        """""";
    private const string CopyWriterName = ""CopyWriter"";
    private const string CopyWriterInstructions =
        """"""
        You are a copywriter with ten years of experience and are known for brevity and a dry humor.
        The goal is to refine and decide on the single best copy as an expert in the field.
        Only provide a single proposal per response.
        You're laser focused on the goal at hand.
        Don't waste time with chit chat.
        Consider suggestions when refining an idea.
        """""";
    [Fact]
    public async Task UseLoggerFactoryWithAgentGroupChatAsync()
    {
        ChatCompletionAgent agentReviewer =
            new()
            {
                Instructions = ReviewerInstructions,
                Name = ReviewerName,
                Kernel = this.CreateKernelWithChatCompletion(),
                LoggerFactory = this.LoggerFactory,
            };
        ChatCompletionAgent agentWriter =
            new()
            {
                Instructions = CopyWriterInstructions,
                Name = CopyWriterName,
                Kernel = this.CreateKernelWithChatCompletion(),
                LoggerFactory = this.LoggerFactory,
            };
        AgentGroupChat chat =
            new(agentWriter, agentReviewer)
            {
                LoggerFactory = this.LoggerFactory,
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy =
                            new ApprovalTerminationStrategy()
                            {
                                Agents = [agentReviewer],
                                MaximumIterations = 10,
                            }
                    }
            };
        ChatMessageContent input = new(AuthorRole.User, ""concept: maps made out of egg cartons."");
        chat.AddChatMessage(input);
        this.WriteAgentChatMessage(input);
        await foreach (ChatMessageContent response in chat.InvokeAsync())
        {
            this.WriteAgentChatMessage(response);
        }
        Console.WriteLine($""\n[IS COMPLETED: {chat.IsComplete}]"");
    }
    private sealed class ApprovalTerminationStrategy : TerminationStrategy
    {
        protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken)
            => Task.FromResult(history[history.Count - 1].Content?.Contains(""approve"", StringComparison.OrdinalIgnoreCase) ?? false);
    }
}"
"public class Step03_Chat(ITestOutputHelper output) : BaseAgentsTest(output)
{
    private const string ReviewerName = ""ArtDirector"";
    private const string ReviewerInstructions =
        """"""
        You are an art director who has opinions about copywriting born of a love for David Ogilvy.
        The goal is to determine if the given copy is acceptable to print.
        If so, state that it is approved.
        If not, provide insight on how to refine suggested copy without example.
        """""";
    private const string CopyWriterName = ""CopyWriter"";
    private const string CopyWriterInstructions =
        """"""
        You are a copywriter with ten years of experience and are known for brevity and a dry humor.
        The goal is to refine and decide on the single best copy as an expert in the field.
        Only provide a single proposal per response.
        You're laser focused on the goal at hand.
        Don't waste time with chit chat.
        Consider suggestions when refining an idea.
        """""";
    [Fact]
    public async Task UseAgentGroupChatWithTwoAgentsAsync()
    {
        ChatCompletionAgent agentReviewer =
            new()
            {
                Instructions = ReviewerInstructions,
                Name = ReviewerName,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        ChatCompletionAgent agentWriter =
            new()
            {
                Instructions = CopyWriterInstructions,
                Name = CopyWriterName,
                Kernel = this.CreateKernelWithChatCompletion(),
            };
        AgentGroupChat chat =
            new(agentWriter, agentReviewer)
            {
                ExecutionSettings =
                    new()
                    {
                        TerminationStrategy =
                            new ApprovalTerminationStrategy()
                            {
                                Agents = [agentReviewer],
                                MaximumIterations = 10,
                            }
                    }
            };
        ChatMessageContent input = new(AuthorRole.User, ""concept: maps made out of egg cartons."");
        chat.AddChatMessage(input);
        this.WriteAgentChatMessage(input);
        await foreach (ChatMessageContent response in chat.InvokeAsync())
        {
            this.WriteAgentChatMessage(response);
        }
        Console.WriteLine($""\n[IS COMPLETED: {chat.IsComplete}]"");
    }
    private sealed class ApprovalTerminationStrategy : TerminationStrategy
    {
        protected override Task<bool> ShouldAgentTerminateAsync(Agent agent, IReadOnlyList<ChatMessageContent> history, CancellationToken cancellationToken)
            => Task.FromResult(history[history.Count - 1].Content?.Contains(""approve"", StringComparison.OrdinalIgnoreCase) ?? false);
    }
}"
"public sealed class OpenAI_TextToAudio(ITestOutputHelper output) : BaseTest(output)
{
    private const string TextToAudioModel = ""tts-1"";
    [Fact(Skip = ""Uncomment the line to write the audio file output before running this test."")]
    public async Task TextToAudioAsync()
    {
        var kernel = Kernel.CreateBuilder()
            .AddOpenAITextToAudio(
                modelId: TextToAudioModel,
                apiKey: TestConfiguration.OpenAI.ApiKey)
            .Build();
        var textToAudioService = kernel.GetRequiredService<ITextToAudioService>();
        string sampleText = ""Hello, my name is John. I am a software engineer. I am working on a project to convert text to audio."";
        OpenAITextToAudioExecutionSettings executionSettings = new()
        {
            Voice = ""alloy"", 
            ResponseFormat = ""mp3"", 
            Speed = 1.0f 
        };
        AudioContent audioContent = await textToAudioService.GetAudioContentAsync(sampleText, executionSettings);
    }
}"
"public class ContextDependentAdvertising(ITestOutputHelper output) : BaseTest(output)
{
    [Fact]
    public async Task AdvertiseFunctionsDependingOnContextPerUserInteractionAsync()
    {
        Kernel kernel = CreateKernel();
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        int maxIteration = 10;
        int iteration = 0;
        var gameUtils = kernel.ImportPluginFromType<GameUtils>();
        KernelFunction createMaze = gameUtils[""CreateMaze""];
        KernelFunction addTraps = gameUtils[""AddTrapsToMaze""];
        KernelFunction addTreasures = gameUtils[""AddTreasuresToMaze""];
        KernelFunction playGame = gameUtils[""PlayGame""];
        ChatHistory chatHistory = [];
        chatHistory.AddUserMessage(""I would like to play a maze game with a lot of tricky traps and shiny treasures."");
        while (!chatHistory.Any(item => item.Content?.Contains(""Game started."") ?? false) && iteration < maxIteration)
        {
            List<KernelFunction> functionsToAdvertise = new();
            bool mazeCreated = chatHistory.Any(item => item.Content?.Contains(""Maze created."") ?? false);
            bool trapsAdded = chatHistory.Any(item => item.Content?.Contains(""Traps added to the maze."") ?? false);
            bool treasuresAdded = chatHistory.Any(item => item.Content?.Contains(""Treasures added to the maze."") ?? false);
            if (!mazeCreated)
            {
                functionsToAdvertise.Add(createMaze);
            }
            else if (mazeCreated && (!trapsAdded || !treasuresAdded))
            {
                functionsToAdvertise.Add(addTraps);
                functionsToAdvertise.Add(addTreasures);
            }
            else if (treasuresAdded && trapsAdded)
            {
                functionsToAdvertise.Add(playGame);
            }
            OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Required(functionsToAdvertise) };
            ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(chatHistory, settings, kernel);
            Console.WriteLine(result);
            iteration++;
        }
    }
    private static Kernel CreateKernel()
    {
        IKernelBuilder builder = Kernel.CreateBuilder();
        builder.AddOpenAIChatCompletion(TestConfiguration.OpenAI.ChatModelId, TestConfiguration.OpenAI.ApiKey);
        return builder.Build();
    }
    private sealed class GameUtils
    {
        [KernelFunction]
        public static string CreateMaze() => ""Maze created."";
        [KernelFunction]
        public static string AddTrapsToMaze() => ""Traps added to the maze."";
        [KernelFunction]
        public static string AddTreasuresToMaze() => ""Treasures added to the maze."";
        [KernelFunction]
        public static string PlayGame() => ""Game started."";
    }
}"
"public class FunctionCalling(ITestOutputHelper output) : BaseTest(output)
{
    [Fact]
    public async Task RunPromptWithAutoFunctionChoiceBehaviorAdvertisingAllKernelFunctionsInvokedAutomaticallyAsync()
    {
        Kernel kernel = CreateKernel();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() };
        Console.WriteLine(await kernel.InvokePromptAsync(""Given the current time of day and weather, what is the likely color of the sky in Boston?"", new(settings)));
    }
    [Fact]
    public async Task RunPromptWithRequiredFunctionChoiceBehaviorAdvertisingOneFunctionInvokedAutomaticallyAsync()
    {
        Kernel kernel = CreateKernel();
        KernelFunction getWeatherFunction = kernel.Plugins.GetFunction(""HelperFunctions"", ""GetWeatherForCity"");
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Required(functions: [getWeatherFunction]) };
        Console.WriteLine(await kernel.InvokePromptAsync(""Given that it is now the 9th of September 2024, 11:29 AM, what is the likely color of the sky in Boston?"", new(settings)));
    }
    [Fact]
    public async Task RunPromptWithNoneFunctionChoiceBehaviorAdvertisingAllKernelFunctionsAsync()
    {
        Kernel kernel = CreateKernel();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.None() };
        Console.WriteLine(await kernel.InvokePromptAsync(""Tell me which provided functions I would need to call to get the color of the sky in Boston on a specified date."", new(settings)));
    }
    [Fact]
    public async Task RunPromptTemplateConfigWithAutoFunctionChoiceBehaviorAdvertisingAllKernelFunctionsInvokedAutomaticallyAsync()
    {
        Kernel kernel = CreateKernel();
        string promptTemplateConfig = """"""
            template_format: semantic-kernel
            template: Given the current time of day and weather, what is the likely color of the sky in Boston?
            execution_settings:
              default:
                function_choice_behavior:
                  type: auto
            """""";
        KernelFunction promptFunction = KernelFunctionYaml.FromPromptYaml(promptTemplateConfig);
        Console.WriteLine(await kernel.InvokeAsync(promptFunction));
    }
    [Fact]
    public async Task RunPromptTemplateConfigWithAutoFunctionChoiceBehaviorAdvertisingOneFunctionInvokedAutomaticallyAsync()
    {
        Kernel kernel = CreateKernel();
        string promptTemplateConfig = """"""
            template_format: semantic-kernel
            template: Given that it is now the 9th of September 2024, 11:29 AM, what is the likely color of the sky in Boston?
            execution_settings:
              default:
                function_choice_behavior:
                  type: auto
                  functions:
                    - HelperFunctions.GetWeatherForCity
            """""";
        KernelFunction promptFunction = KernelFunctionYaml.FromPromptYaml(promptTemplateConfig);
        Console.WriteLine(await kernel.InvokeAsync(promptFunction));
    }
    [Fact]
    public async Task RunNonStreamingChatCompletionApiWithAutomaticFunctionInvocationAsync()
    {
        Kernel kernel = CreateKernel();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() };
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(
            ""Given the current time of day and weather, what is the likely color of the sky in Boston?"",
            settings,
            kernel);
        Console.WriteLine(result);
    }
    [Fact]
    public async Task RunStreamingChatCompletionApiWithAutomaticFunctionInvocationAsync()
    {
        Kernel kernel = CreateKernel();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() };
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        var stringBuilder = new StringBuilder();
        await foreach (var update in chatCompletionService.GetStreamingChatMessageContentsAsync(
            ""Given the current time of day and weather, what is the likely color of the sky in Boston?"",
            settings,
            kernel))
        {
            stringBuilder.Append(update.Content);
        }
        Console.WriteLine(stringBuilder.ToString());
    }
    [Fact]
    public async Task RunNonStreamingChatCompletionApiWithManualFunctionInvocationAsync()
    {
        Kernel kernel = CreateKernel();
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = Microsoft.SemanticKernel.FunctionChoiceBehavior.Auto(autoInvoke: false) };
        ChatHistory chatHistory = [];
        chatHistory.AddUserMessage(""Given the current time of day and weather, what is the likely color of the sky in Boston?"");
        while (true)
        {
            ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(chatHistory, settings, kernel);
            if (result.Content is not null)
            {
                Console.Write(result.Content);
            }
            IEnumerable<FunctionCallContent> functionCalls = FunctionCallContent.GetFunctionCalls(result);
            if (!functionCalls.Any())
            {
                break;
            }
            chatHistory.Add(result);
            foreach (FunctionCallContent functionCall in functionCalls)
            {
                try
                {
                    FunctionResultContent resultContent = await functionCall.InvokeAsync(kernel);
                    chatHistory.Add(resultContent.ToChatMessage());
                }
                catch (Exception ex)
                {
                    chatHistory.Add(new FunctionResultContent(functionCall, ex).ToChatMessage());
                }
            }
            Console.WriteLine();
        }
    }
    [Fact]
    public async Task RunStreamingChatCompletionApiWithManualFunctionCallingAsync()
    {
        Kernel kernel = CreateKernel();
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = Microsoft.SemanticKernel.FunctionChoiceBehavior.Auto(autoInvoke: false) };
        ChatHistory chatHistory = [];
        chatHistory.AddUserMessage(""Given the current time of day and weather, what is the likely color of the sky in Boston?"");
        while (true)
        {
            AuthorRole? authorRole = null;
            var fccBuilder = new FunctionCallContentBuilder();
            await foreach (var streamingContent in chatCompletionService.GetStreamingChatMessageContentsAsync(chatHistory, settings, kernel))
            {
                if (streamingContent.Content is not null)
                {
                    Console.Write(streamingContent.Content);
                }
                authorRole ??= streamingContent.Role;
                fccBuilder.Append(streamingContent);
            }
            var functionCalls = fccBuilder.Build();
            if (!functionCalls.Any())
            {
                break;
            }
            var fcContent = new ChatMessageContent(role: authorRole ?? default, content: null);
            chatHistory.Add(fcContent);
            foreach (var functionCall in functionCalls)
            {
                fcContent.Items.Add(functionCall);
                var functionResult = await functionCall.InvokeAsync(kernel);
                chatHistory.Add(functionResult.ToChatMessage());
            }
            Console.WriteLine();
        }
    }
    [Fact]
    public async Task RunNonStreamingPromptWithSimulatedFunctionAsync()
    {
        Kernel kernel = CreateKernel();
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = Microsoft.SemanticKernel.FunctionChoiceBehavior.Auto(autoInvoke: false) };
        ChatHistory chatHistory = [];
        chatHistory.AddUserMessage(""Given the current time of day and weather, what is the likely color of the sky in Boston?"");
        while (true)
        {
            ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(chatHistory, settings, kernel);
            if (result.Content is not null)
            {
                Console.Write(result.Content);
            }
            chatHistory.Add(result); 
            IEnumerable<FunctionCallContent> functionCalls = FunctionCallContent.GetFunctionCalls(result);
            if (!functionCalls.Any())
            {
                break;
            }
            foreach (FunctionCallContent functionCall in functionCalls)
            {
                FunctionResultContent resultContent = await functionCall.InvokeAsync(kernel); 
                chatHistory.Add(resultContent.ToChatMessage());
            }
            FunctionCallContent simulatedFunctionCall = new(""weather-alert"", id: ""call_123"");
            result.Items.Add(simulatedFunctionCall);
            string simulatedFunctionResult = ""A Tornado Watch has been issued, with potential for severe thunderstorms causing unusual sky colors like green, yellow, or dark gray. Stay informed and follow safety instructions from authorities."";
            chatHistory.Add(new FunctionResultContent(simulatedFunctionCall, simulatedFunctionResult).ToChatMessage());
            Console.WriteLine();
        }
    }
    [Fact]
    public async Task DisableFunctionCallingAsync()
    {
        Kernel kernel = CreateKernel();
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(functions: []) };
        Console.WriteLine(await kernel.InvokePromptAsync(""Given the current time of day and weather, what is the likely color of the sky in Boston?"", new(settings)));
    }
    [Fact]
    public async Task DisableFunctionCallingInPromptTemplateConfigAsync()
    {
        Kernel kernel = CreateKernel();
        string promptTemplateConfig = """"""
            template_format: semantic-kernel
            template: Given that it is now the 9th of September 2024, 11:29 AM, what is the likely color of the sky in Boston?
            execution_settings:
              default:
                function_choice_behavior:
                  type: auto
                  functions: []
            """""";
        KernelFunction promptFunction = KernelFunctionYaml.FromPromptYaml(promptTemplateConfig);
        Console.WriteLine(await kernel.InvokeAsync(promptFunction));
    }
    [Fact]
    public async Task RunNonStreamingChatCompletionApiWithConcurrentFunctionInvocationOptionAsync()
    {
        Kernel kernel = CreateKernel();
        FunctionChoiceBehaviorOptions options = new() { AllowConcurrentInvocation = true };
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(options: options) };
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(
            ""Good morning! What’s the current time and latest news headlines?"",
            settings,
            kernel);
        Console.WriteLine(result);
    }
    [Fact]
    public async Task RunNonStreamingChatCompletionApiWithParallelFunctionCallOptionAsync()
    {
        Kernel kernel = CreateKernel();
        FunctionChoiceBehaviorOptions options = new() { AllowParallelCalls = true };
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(options: options) };
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(
            ""Good morning! What’s the current time and latest news headlines?"",
            settings,
            kernel);
        Console.WriteLine(result);
    }
    [Fact]
    public async Task RunNonStreamingChatCompletionApiWithParallelFunctionCallAndConcurrentFunctionInvocationOptionsAsync()
    {
        Kernel kernel = CreateKernel();
        FunctionChoiceBehaviorOptions options = new() { AllowParallelCalls = true, AllowConcurrentInvocation = true };
        OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(options: options) };
        IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
        ChatMessageContent result = await chatCompletionService.GetChatMessageContentAsync(
            ""Good morning! What’s the current time and latest news headlines?"",
            settings,
            kernel);
        Console.WriteLine(result);
    }
    private static Kernel CreateKernel()
    {
        IKernelBuilder builder = Kernel.CreateBuilder();
        builder.AddOpenAIChatCompletion(TestConfiguration.OpenAI.ChatModelId, TestConfiguration.OpenAI.ApiKey);
        Kernel kernel = builder.Build();
        kernel.ImportPluginFromFunctions(""HelperFunctions"",
        [
            kernel.CreateFunctionFromMethod(() => new List<string> { ""Squirrel Steals Show"", ""Dog Wins Lottery"" }, ""GetLatestNewsTitles"", ""Retrieves latest news titles.""),
            kernel.CreateFunctionFromMethod(() => DateTime.UtcNow.ToString(""R""), ""GetCurrentUtcDateTime"", ""Retrieves the current date time in UTC.""),
            kernel.CreateFunctionFromMethod((string cityName, string currentDateTime) =>
                cityName switch
                {
                    ""Boston"" => ""61 and rainy"",
                    ""London"" => ""55 and cloudy"",
                    ""Miami"" => ""80 and sunny"",
                    ""Paris"" => ""60 and rainy"",
                    ""Tokyo"" => ""50 and sunny"",
                    ""Sydney"" => ""75 and sunny"",
                    ""Tel Aviv"" => ""80 and sunny"",
                    _ => ""31 and snowing"",
                }, ""GetWeatherForCity"", ""Gets the current weather for the specified city""),
        ]);
        return kernel;
    }
}"
"public class NexusRaven_FunctionCalling(ITestOutputHelper output) : BaseTest(output)
{
    private Uri RavenEndpoint => new(""http:
    [Fact]
    public async Task InvokeTextGenerationAsync()
    {
        Kernel kernel = Kernel.CreateBuilder()
            .AddHuggingFaceTextGeneration(endpoint: RavenEndpoint)
            .Build();
        var textGeneration = kernel.GetRequiredService<ITextGenerationService>();
        var prompt = ""What is deep learning?"";
        var result = await textGeneration.GetTextContentsAsync(prompt);
        Console.WriteLine(result[0].ToString());
    }
    [Fact]
    public async Task InvokeTextGenerationWithFunctionCallingAsync()
    {
        using var handler = new LoggingHandler(new HttpClientHandler(), this.Output);
        using var httpClient = new HttpClient(handler);
        Kernel kernel = Kernel.CreateBuilder()
            .AddHuggingFaceTextGeneration(
                endpoint: RavenEndpoint,
                httpClient: httpClient)
            .Build();
        var plugin = ImportFunctions(kernel);
        var textGeneration = kernel.GetRequiredService<ITextGenerationService>();
        var template =
        """"""""
        {{#each (functions)}}
        Function:
        {{Name}}{{Signature}}
        """"""
        {{Description}}
        """"""
        {{/each}}
        User Query:{{prompt}}<human_end>
        """""""";
        var prompt = ""What is the weather like in Dublin?"";
        var functions = plugin.Select(f => new FunctionDefinition { Name = f.Name, Description = f.Description, Signature = CreateSignature(f) }).ToList();
        var executionSettings = new HuggingFacePromptExecutionSettings { Temperature = 0.001F, MaxNewTokens = 1024, ReturnFullText = false, DoSample = false }; 
        KernelArguments arguments = new(executionSettings) { { ""prompt"", prompt }, { ""functions"", functions } };
        var factory = new HandlebarsPromptTemplateFactory();
        var promptTemplate = factory.Create(new PromptTemplateConfig(template) { TemplateFormat = ""handlebars"" });
        var rendered = await promptTemplate.RenderAsync(kernel, arguments);
        Console.WriteLine("" Prompt:\n"
"public class MultipleFunctionsVsParameters(ITestOutputHelper output) : BaseTest(output)
{
    [Fact]
    public async Task InvoiceSearchBySampleAsync()
    {
        IKernelBuilder kernelBuilder = Kernel.CreateBuilder();
        kernelBuilder.Services.AddSingleton<IAutoFunctionInvocationFilter>(
            new AutoFunctionInvocationFilter(this.Output));
        kernelBuilder.AddOpenAIChatCompletion(
            modelId: TestConfiguration.OpenAI.ChatModelId,
            apiKey: TestConfiguration.OpenAI.ApiKey);
        kernelBuilder.Plugins.AddFromType<InvoiceSearchBy>();
        Kernel kernel = kernelBuilder.Build();
        await InvokePromptsAsync(kernel);
    }
    [Fact]
    public async Task InvoiceSearchSampleAsync()
    {
        IKernelBuilder kernelBuilder = Kernel.CreateBuilder();
        kernelBuilder.Services.AddSingleton<IAutoFunctionInvocationFilter>(
            new AutoFunctionInvocationFilter(this.Output));
        kernelBuilder.AddOpenAIChatCompletion(
            modelId: TestConfiguration.OpenAI.ChatModelId,
            apiKey: TestConfiguration.OpenAI.ApiKey);
        kernelBuilder.Plugins.AddFromType<InvoiceSearch>();
        Kernel kernel = kernelBuilder.Build();
        await InvokePromptsAsync(kernel);
    }
    private async Task InvokePromptsAsync(Kernel kernel)
    {
        OpenAIPromptExecutionSettings settings = new() { ToolCallBehavior = ToolCallBehavior.AutoInvokeKernelFunctions };
        Console.WriteLine(""Prompt: Show me the invoices for customer named Contoso Industries."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for customer named Contoso Industries."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Show me the invoices for purchase order PO123."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for purchase order PO123."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Show me the invoices for vendor number VN123."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for vendor number VN123."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Show me the invoices for Contoso Industries."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for Contoso Industries."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Show me the invoices for PO123."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for PO123."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Show me the invoices for VN123."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Show me the invoices for VN123."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
        Console.WriteLine(""Prompt: Zeigen Sie mir die Rechnungen für Contoso Industries."");
        Console.WriteLine(await kernel.InvokePromptAsync(""Zeigen Sie mir die Rechnungen für Contoso Industries."", new(settings)));
        Console.WriteLine(""----------------------------------------------------"");
    }
    private sealed class AutoFunctionInvocationFilter(ITestOutputHelper output) : IAutoFunctionInvocationFilter
    {
        public async Task OnAutoFunctionInvocationAsync(AutoFunctionInvocationContext context, Func<AutoFunctionInvocationContext, Task> next)
        {
            var functionName = context.Function.Name;
            var arguments = context.Arguments;
            output.WriteLine($""Function: {functionName} {JsonSerializer.Serialize(arguments)}"");
            await next(context);
        }
    }
    private sealed class InvoiceSearchBy
    {
        [KernelFunction]
        [Description(""Search for invoices by customer name."")]
        public IEnumerable<Invoice> SearchByCustomerName([Description(""The customer name."")] string customerName)
        {
            return
                [
                    new Invoice { CustomerName = customerName, PurchaseOrder = ""PO123"", VendorNumber = ""VN123"" },
                    new Invoice { CustomerName = customerName, PurchaseOrder = ""PO124"", VendorNumber = ""VN124"" },
                    new Invoice { CustomerName = customerName, PurchaseOrder = ""PO125"", VendorNumber = ""VN125"" },
                ];
        }
        [KernelFunction]
        [Description(""Search for invoices by purchase order."")]
        public IEnumerable<Invoice> SearchByPurchaseOrder([Description(""The purchase order. Purchase orders begin with a PN prefix."")] string purchaseOrder)
        {
            return
                [
                    new Invoice { CustomerName = ""Customer1"", PurchaseOrder = purchaseOrder, VendorNumber = ""VN123"" },
                    new Invoice { CustomerName = ""Customer2"", PurchaseOrder = purchaseOrder, VendorNumber = ""VN124"" },
                    new Invoice { CustomerName = ""Customer3"", PurchaseOrder = purchaseOrder, VendorNumber = ""VN125"" },
                ];
        }
        [KernelFunction]
        [Description(""Search for invoices by vendor number"")]
        public IEnumerable<Invoice> SearchByVendorNumber([Description(""The vendor number. Vendor numbers begin with a VN prefix."")] string vendorNumber)
        {
            return
                [
                    new Invoice { CustomerName = ""Customer1"", PurchaseOrder = ""PO123"", VendorNumber = vendorNumber },
                    new Invoice { CustomerName = ""Customer2"", PurchaseOrder = ""PO124"", VendorNumber = vendorNumber },
                    new Invoice { CustomerName = ""Customer3"", PurchaseOrder = ""PO125"", VendorNumber = vendorNumber },
                ];
        }
    }
    private sealed class InvoiceSearch
    {
        [KernelFunction]
        [Description(""Search for invoices by customer name or purchase order or vendor number."")]
        public IEnumerable<Invoice> Search([Description(""The invoice search request. It must contain either a customer name or a purchase order or a vendor number"")] InvoiceSearchRequest searchRequest)
        {
            return
                [
                    new Invoice
                    {
                        CustomerName = searchRequest.CustomerName ?? ""Customer1"",
                        PurchaseOrder = searchRequest.PurchaseOrder ?? ""PO123"",
                        VendorNumber = searchRequest.VendorNumber ?? ""VN123""
                    },
                    new Invoice
                    {
                        CustomerName = searchRequest.CustomerName ?? ""Customer2"",
                        PurchaseOrder = searchRequest.PurchaseOrder ?? ""PO124"",
                        VendorNumber = searchRequest.VendorNumber ?? ""VN124""
                    },
                    new Invoice
                    {
                        CustomerName = searchRequest.CustomerName ?? ""Customer3"",
                        PurchaseOrder = searchRequest.PurchaseOrder ?? ""PO125"",
                        VendorNumber = searchRequest.VendorNumber ?? ""VN125""
                    },
                ];
        }
    }
    private sealed class Invoice
    {
        public string CustomerName { get; set; }
        public string PurchaseOrder { get; set; }
        public string VendorNumber { get; set; }
    }
    [Description(""The invoice search request."")]
    private sealed class InvoiceSearchRequest
    {
        [Description(""Optional, customer name."")]
        public string? CustomerName { get; set; }
        [Description(""Optional, purchase order. Purchase orders begin with a PN prefix."")]
        public string? PurchaseOrder { get; set; }
        [Description(""Optional, vendor number. Vendor numbers begin with a VN prefix."")]
        public string? VendorNumber { get; set; }
    }
}"
"public sealed class Gemini_FunctionCalling(ITestOutputHelper output) : BaseTest(output)
{
    [RetryFact]
    public async Task GoogleAIAsync()
    {
        Console.WriteLine("""
"public class VectorStore_ConsumeFromMemoryStore_Redis(ITestOutputHelper output, VectorStoreRedisContainerFixture redisFixture) : BaseTest(output), IClassFixture<VectorStoreRedisContainerFixture>
{
    private const int VectorSize = 1536;
    private const string MemoryStoreCollectionName = ""memorystorecollection"";
    [Fact]
    public async Task ConsumeExampleAsync()
    {
        await redisFixture.ManualInitializeAsync();
        var textEmbeddingService = new AzureOpenAITextEmbeddingGenerationService(
            TestConfiguration.AzureOpenAIEmbeddings.DeploymentName,
            TestConfiguration.AzureOpenAIEmbeddings.Endpoint,
            new AzureCliCredential());
        var memoryStore = new RedisMemoryStore(""localhost:6379"", VectorSize);
        var vectorStore = new RedisVectorStore(
            ConnectionMultiplexer.Connect(""localhost:6379"").GetDatabase(),
            new() { StorageType = RedisStorageType.HashSet });
        await VectorStore_ConsumeFromMemoryStore_Common.CreateCollectionAndAddSampleDataAsync(
            memoryStore,
            MemoryStoreCollectionName,
            textEmbeddingService);
        var collection = vectorStore.GetCollection<string, VectorStoreRecord>(MemoryStoreCollectionName);
        await collection.CreateCollectionIfNotExistsAsync();
        var record1 = await collection.GetAsync(""11111111-1111-1111-1111-111111111111"");
        var record2 = await collection.GetAsync(""22222222-2222-2222-2222-222222222222"");
        var record3 = await collection.GetAsync(""33333333-3333-3333-3333-333333333333"", new() { IncludeVectors = true });
        Console.WriteLine($""Record 1: Key: {record1!.Key} Timestamp: {DateTimeOffset.FromUnixTimeMilliseconds(record1.Timestamp)} Metadata: {record1.Metadata} Embedding {record1.Embedding}"");
        Console.WriteLine($""Record 2: Key: {record2!.Key} Timestamp: {DateTimeOffset.FromUnixTimeMilliseconds(record2.Timestamp)} Metadata: {record2.Metadata} Embedding {record2.Embedding}"");
        Console.WriteLine($""Record 3: Key: {record3!.Key} Timestamp: {DateTimeOffset.FromUnixTimeMilliseconds(record3.Timestamp)} Metadata: {record3.Metadata} Embedding {record3.Embedding}"");
    }
    private sealed class VectorStoreRecord
    {
        [VectorStoreRecordKey]
        public string Key { get; set; }
        [VectorStoreRecordData(StoragePropertyName = ""metadata"")]
        public string Metadata { get; set; }
        [VectorStoreRecordData(StoragePropertyName = ""timestamp"")]
        public long Timestamp { get; set; }
        [VectorStoreRecordVector(VectorSize, StoragePropertyName = ""embedding"")]
        public ReadOnlyMemory<float> Embedding { get; set; }
    }
}"
"public class VectorStore_DataIngestion_Simple(ITestOutputHelper output, VectorStoreQdrantContainerFixture qdrantFixture) : BaseTest(output), IClassFixture<VectorStoreQdrantContainerFixture>
{
    [Fact]
    public async Task ExampleAsync()
    {
        var textEmbeddingGenerationService = new AzureOpenAITextEmbeddingGenerationService(
                TestConfiguration.AzureOpenAIEmbeddings.DeploymentName,
                TestConfiguration.AzureOpenAIEmbeddings.Endpoint,
                new AzureCliCredential());
        await qdrantFixture.ManualInitializeAsync();
        var vectorStore = new QdrantVectorStore(new QdrantClient(""localhost""));
        var collection = vectorStore.GetCollection<ulong, Glossary>(""skglossary"");
        await collection.CreateCollectionIfNotExistsAsync();
        var glossaryEntries = CreateGlossaryEntries().ToList();
        var tasks = glossaryEntries.Select(entry => Task.Run(async () =>
        {
            entry.DefinitionEmbedding = await textEmbeddingGenerationService.GenerateEmbeddingAsync(entry.Definition);
        }));
        await Task.WhenAll(tasks);
        var upsertedKeysTasks = glossaryEntries.Select(x => collection.UpsertAsync(x));
        var upsertedKeys = await Task.WhenAll(upsertedKeysTasks);
        var upsertedRecord = await collection.GetAsync(upsertedKeys.First(), new() { IncludeVectors = true });
        Console.WriteLine($""Upserted keys: {string.Join("", "", upsertedKeys)}"");
        Console.WriteLine($""Upserted record: {JsonSerializer.Serialize(upsertedRecord)}"");
    }
    private sealed class Glossary
    {
        [VectorStoreRecordKey]
        public ulong Key { get; set; }
        [VectorStoreRecordData]
        public string Term { get; set; }
        [VectorStoreRecordData]
        public string Definition { get; set; }
        [VectorStoreRecordVector(1536)]
        public ReadOnlyMemory<float> DefinitionEmbedding { get; set; }
    }
    private static IEnumerable<Glossary> CreateGlossaryEntries()
    {
        yield return new Glossary
        {
            Key = 1,
            Term = ""API"",
            Definition = ""Application Programming Interface. A set of rules and specifications that allow software components to communicate and exchange data.""
        };
        yield return new Glossary
        {
            Key = 2,
            Term = ""Connectors"",
            Definition = ""Connectors allow you to integrate with various services provide AI capabilities, including LLM, AudioToText, TextToAudio, Embedding generation, etc.""
        };
        yield return new Glossary
        {
            Key = 3,
            Term = ""RAG"",
            Definition = ""Retrieval Augmented Generation - a term that refers to the process of retrieving additional data to provide as context to an LLM to use when generating a response (completion) to a user’s question (prompt).""
        };
    }
}"
